<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>F# Reflections</title>
        <description>Blog about F# and FP Programming</description>
        <link>http://kcieslak.io/</link>
        <atom:link href="http://kcieslak.io/feed.xml" rel="self" type="application/rss+xml"/>
        <pubDate>Mon, 29 Jan 2018 15:32:56 +0100</pubDate>
        <lastBuildDate>Mon, 29 Jan 2018 15:32:56 +0100</lastBuildDate>
        <generator>Jekyll v3.4.3</generator>
        
            <item>
                <title>Reinventing MVC pattern for web programming with F#</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;A couple of weeks ago, I’ve posted &lt;a href=&quot;https://twitter.com/k_cieslak/status/944349420937793536&quot;&gt;yet-another-controversial-tweet&lt;/a&gt; - this time criticizing F# libraries for web programming and saying that “they focus on wrong problem”. In this post I’d like to expand this thought a bit, describe what is, in my opinion, problem with those libraries, and introduce a project that will try to fix those problems.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;DISCLAIMER: In the original tweet I’ve mentioned three libraries - &lt;a href=&quot;https://suave.io/&quot;&gt;Suave&lt;/a&gt;, &lt;a href=&quot;https://github.com/giraffe-fsharp/Giraffe&quot;&gt;Giraffe&lt;/a&gt;, and &lt;a href=&quot;https://freya.io/&quot;&gt;Freya&lt;/a&gt;. First of all, if we were to talk about all major F# web solutions we should also mention &lt;a href=&quot;https://websharper.com/&quot;&gt;WebSharper&lt;/a&gt;. Secondly, my experience with Freya and WebSharper is fairly limited - I’ve never used any of them in commercial application - so in this post I won’t talk about them but focus on Suave and Giraffe&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;DISCLAIMER 2: I really like both Suave and Giraffe - I’ve been using Suave for years in multiple commercial applications and I think it’s really good project. Also I’ve been investigating and testing Giraffe for last couple of months and I also believe it’s good project with a bright future.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;h1&gt;The model&lt;/h1&gt;

&lt;p&gt;So let’s start with describing a programming model that Suave and Giraffe use. Both libraries are using a really similar model of building applications from small functions that takes &lt;code&gt;HttpContext&lt;/code&gt; as an input and returns a modified &lt;code&gt;HttpContext&lt;/code&gt; and then they use combinators functions to combine those small functions and build application with them. This model is really powerful, it provides full control over the flow of the program, and follows some FP principles (building applications as a composition of functions).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There are some small differences between Suave and Giraffe implementation of this model, but going into such details is not in scope of this post.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;The problem&lt;/h1&gt;

&lt;p&gt;While I love the programming model I also believe that both Suave and Giraffe missed an opportunity to build on top of this model. Helper functions provided by both libraries that are the main building block of the applications are really “low level” - they mostly focus on the details of the HTTP protocol. And I think that while this is an useful level of abstraction for some use cases, my experience with building business applications with Suave / Giraffe suggests that this is not a level of abstraction that’s useful for typical, boring-line-of-business applications - and that’s most common use case for most software developers. If we compare Suave / Giraffe with other ecosystems it often feels like writing ASP.Net applications with just middleware - without using MVC / WebAPI abstractions, or writing Elixir web applications with just Plugs - without &lt;a href=&quot;http://phoenixframework.org/&quot;&gt;Phoenix Framework&lt;/a&gt;. Of course there are cases where this lower level of abstraction is a good choice, but success and popularity of such libraries like &lt;a href=&quot;http://rubyonrails.org/&quot;&gt;Rails&lt;/a&gt;, ASP.Net MVC, or Phoenix shows us that developers want to use some higher level of abstraction and focus on solving their business domain problems instead of worrying about the details of the HTTP protocol.&lt;/p&gt;

&lt;h1&gt;Developer experience&lt;/h1&gt;

&lt;p&gt;The previous paragraph was focused on technical issues but let’s now move to something a bit different. Working on OSS tooling for the last couple of years has thought me one important thing - good user experience is sometimes more valuable for project than technical superiority. I also strongly believe that tooling can be a great way to allow people ramp up faster and to teach users some new concepts. A great example of that is &lt;a href=&quot;https://www.jetbrains.com/resharper/&quot;&gt;ReSharper&lt;/a&gt; - while it’s not super popular in F# community ( ;-) ) and some of the features for C# are probably overkill, I strongly believe that ReSharper is one of the most impactful source of information about new language features for C# developers - not every developer is following all news, conferences and announcements but it’s hard to miss when tool starts to give warnings and shows automatic refactorings introducing new language features. In web space great example for such behavior is Phoenix - everything it does in regards of tooling, from new project template through opinionated structure of the project to generators that let users to scaffold some new controllers is designed to make the introduction of most important concepts used in Phoenix easier for new developer.&lt;/p&gt;

&lt;p&gt;I strongly believe that lack of opinionated tooling and opinionated, commonly used way to build web applications is another important issue of Suave and Giraffe. Developers don’t want to focus on making decisions about structuring the project, or wonder how they need to combine things together, or what are best practices - they want to focus on problems of their business. Again, frameworks like Phoenix and Rails are great example of how having such an opinionated way of building web applications works great in practice.&lt;/p&gt;

&lt;h1&gt;Introducing Saturn&lt;/h1&gt;

&lt;p&gt;For the last couple of weeks I’ve been working on &lt;a href=&quot;https://github.com/SaturnFramework/Saturn&quot;&gt;Saturn&lt;/a&gt; - a new F# OSS project that will attempt to solve the problems mentioned above. It’s strongly inspired by some concepts from Phoenix. Before going into details of Saturn an important thing about it is that it builds on top of the existing ecosystem - and to be precise on top of Giraffe - in similar fashion that Phoenix builds on top of Plugs abstraction.&lt;/p&gt;

&lt;h3&gt;Library&lt;/h3&gt;

&lt;p&gt;A core part of Saturn is a library that can be put on top of any existing Giraffe application. This library contains a set of helper functions, tries to hide some complexity of Giraffe (for example manual passing of &lt;code&gt;next&lt;/code&gt; in every function), and what’s most important it introduces several higher level building blocks that can be used to model a web application. Those building blocks are using a nice high level, declarative DSL using computation expressions with custom keywords. Currently in Saturn there exists 4 such higher level building blocks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pipelines&lt;/li&gt;
  &lt;li&gt;Scopes&lt;/li&gt;
  &lt;li&gt;Controllers&lt;/li&gt;
  &lt;li&gt;Applications&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;and now I shall explain each with a code sample.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;pipeline&lt;/code&gt; - the simplest building block provided by Saturn. It can be used to combine multiple &lt;code&gt;HttpHandlers&lt;/code&gt; in a more declarative way without using custom operators. It also provides custom operations that hide some of the Giraffe complexity.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let browser = pipeline {
    plug acceptHtml
    plug putSecureBrowserHeaders
    fetchSession
    set_header &quot;x-pipeline-type&quot; &quot;Browser&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;scope&lt;/code&gt; - it is a DSL that can be used to define routing and combining this routing together with the &lt;code&gt;pipelines&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let defaultView = scope {
    get &quot;/&quot; (renderHtml Index.layout)
    get &quot;/index.html&quot; (redirectTo false &quot;/&quot;)
    get &quot;/default.html&quot; (redirectTo false &quot;/&quot;)
}

let browserRouter = scope {
    error_handler (renderHtml NotFound.layout) //Use the default 404 webpage
    pipe_through browser //Use the default browser pipeline

    forward &quot;&quot; defaultView //Use the default view
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;controller&lt;/code&gt; - it is a DSL for building typical HTTP controllers. It’s using predefined routing inspired by Phoenix’s &lt;code&gt;resource&lt;/code&gt; macro.s&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let resource = controller {
    index indexAction
    show showAction
    add addAction
    edit editAction
    create createAction
    update updateAction
    delete deleteAction
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;application&lt;/code&gt; - it’s a DSL used for defining application settings and ASP.Net configuration. It aims to replace some cumbersome configuration of some ASP.Net features with declarative feature toggles.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;let app = application {
    pipe_through endpointPipe

    error_handler (fun ex _ -&amp;gt; HttpHandlers.renderHtml (InternalError.layout ex))
    router Router.router
    url &quot;http://0.0.0.0:8085/&quot;
    memory_cache
    use_static &quot;static&quot;
    use_gzip
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important thing about Saturn’s computation expression and those higher level building blocks - &lt;code&gt;pipeline&lt;/code&gt;, &lt;code&gt;scope&lt;/code&gt; and &lt;code&gt;controller&lt;/code&gt; is that they are not introducing any additional abstraction in terms of types - they are transformed to standard Giraffe &lt;code&gt;HttpHandler&lt;/code&gt; which means they are composable with each other and with other, existing &lt;code&gt;HttpHandlers&lt;/code&gt; that you may have.&lt;/p&gt;

&lt;h3&gt;Tooling&lt;/h3&gt;

&lt;p&gt;The other, as important as core library, part of Saturn is additional, opinionated tooling for scaffolding new projects, generating controllers, models, database layer and migration scripts, controlling database migrations etc.&lt;/p&gt;

&lt;p&gt;This tooling comes in 2 parts - first one is a project template that creates default the project structure, and a set of helper files. This is a normal &lt;code&gt;dotnet&lt;/code&gt; project template distributed through NuGet which means you will be able to use &lt;code&gt;dotnet new saturn&lt;/code&gt; to create Saturn applications. The second part of the tooling is a &lt;code&gt;dotnet&lt;/code&gt; extension tool, again, distributed by NuGet. It’s automatically referenced when creating a new Saturn project. So after creating new project you will be able to go to the project folder and run, for example, the &lt;code&gt;dotnet saturn gen&lt;/code&gt; command to generate new controller, views, model and a database layer.&lt;/p&gt;

&lt;h3&gt;Design choices&lt;/h3&gt;

&lt;p&gt;Some parts of the Saturn library and the whole tooling is really opinionated - for example there is no choice to change the way the routing for &lt;code&gt;controller&lt;/code&gt; is created, you can just decide not to implement some of the actions. This may seem restrictive at first, but I strongly believe that it is a good design for the most common use cases. And since everything is based on the composable &lt;code&gt;HttpHandler&lt;/code&gt; model if the default implementation of &lt;code&gt;controller&lt;/code&gt; is not working for you, you can easily recreate it with lower level abstractions such as the &lt;code&gt;scope&lt;/code&gt; DSL.&lt;/p&gt;

&lt;p&gt;Similarly the tooling is really opinionated - the default template out of the box uses &lt;a href=&quot;https://fsprojects.github.io/Paket/&quot;&gt;Paket&lt;/a&gt; for dependency management, &lt;a href=&quot;https://fake.build/&quot;&gt;FAKE&lt;/a&gt; for build script, &lt;a href=&quot;https://github.com/StackExchange/Dapper&quot;&gt;Dapper&lt;/a&gt; for data access, &lt;a href=&quot;https://github.com/canton7/Simple.Migrations&quot;&gt;Simple.Migrations&lt;/a&gt; to handle database migrations. The &lt;code&gt;dotnet saturn&lt;/code&gt; tool generates code assuming certain project structure was created as by the default template, and probably won’t work in other situation.&lt;/p&gt;

&lt;h3&gt;Resources&lt;/h3&gt;

&lt;p&gt;Both Saturn library and tooling are open-source projects that can be found on GitHub and NuGet:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Saturn library - &lt;a href=&quot;https://github.com/SaturnFramework/Saturn&quot;&gt;https://github.com/SaturnFramework/Saturn&lt;/a&gt; and &lt;a href=&quot;https://www.nuget.org/packages/Saturn/&quot;&gt;https://www.nuget.org/packages/Saturn/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Saturn template - &lt;a href=&quot;https://github.com/SaturnFramework/Saturn.Template&quot;&gt;https://github.com/SaturnFramework/Saturn.Template&lt;/a&gt; and &lt;a href=&quot;https://www.nuget.org/packages/Saturn.Template/&quot;&gt;https://www.nuget.org/packages/Saturn.Template/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Saturn &lt;code&gt;dotnet&lt;/code&gt; tool - &lt;a href=&quot;https://github.com/SaturnFramework/Saturn.Dotnet&quot;&gt;https://github.com/SaturnFramework/Saturn.Dotnet&lt;/a&gt; and &lt;a href=&quot;https://www.nuget.org/packages/Saturn.Dotnet/&quot;&gt;https://www.nuget.org/packages/Saturn.Dotnet/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Saturn sample project created using template and generator tool - &lt;a href=&quot;https://github.com/SaturnFramework/Saturn.Sample&quot;&gt;https://github.com/SaturnFramework/Saturn.Sample&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post I’ve tried to point out some problems of Suave and Giraffe and explain why I’ve decided to create new library for web programming with F#.&lt;/p&gt;
</description>
                <pubDate>Thu, 25 Jan 2018 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/Reinventing-MVC-for-web-programming-with-F</link>
                <guid isPermaLink="true">http://kcieslak.io/Reinventing-MVC-for-web-programming-with-F</guid>
                
                <category>F#</category>
                
                <category>Saturn</category>
                
                <category>Web</category>
                
                
            </item>
        
            <item>
                <title>Path to Community based Open Source Software</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Open Source movement has changed the software development world as much as only few things before. Nowadays, it’s almost impossible to develop any project without using OSS - we can be sure that some parts of our stack are developed in the open - from the libraries we download from the package managers, through runtime, to compilers that we are using. Even most conservative, and not-so-long-time-ago actively hostile to OSS companies are now trying to embrace Open Source development.&lt;/p&gt;

&lt;p&gt;But putting code in open by uploading to GitHub, using one of the licenses formally accepted by the &lt;a href=&quot;https://opensource.org/&quot;&gt;Open Source Initiative&lt;/a&gt; is just first step. In my opinion, the real value of the Open Source is not just license, and publicly available code (although, those things are also valuable on their own) but rather possible change in governance model, collaboration with Community and embracing “OSS Culture”.&lt;/p&gt;

&lt;p&gt;In this post I’ll describe different “stages of enlightenment” that company can go through in its path to the Open Source development model that will bring most value to both company and community.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Open Source License&lt;/h1&gt;

&lt;p&gt;Even though, as I’ve mentioned I believe that embracing OSS goes much beyond just having OSS license we can’t really forgot about importance and impact of it. Having OSS license is necessary condition for any project that wants to be called OSS projects. There exist formal definition created by Open Source Initiative called &lt;a href=&quot;https://opensource.org/docs/osd&quot;&gt;Open Source Definition&lt;/a&gt; that sets strict rules that license must follow to be called OSS license.&lt;/p&gt;

&lt;h1&gt;Stage 1 - Code dump&lt;/h1&gt;

&lt;p&gt;At this level, company publishes online projects that its no longer going to invest into or maintain. Probably project failed, was deprecated, or is not profitable. Usually it means that company is no longer interested in the code base - there will be no maintainers, no merged PRs, no responses to issues, and no updates. Rarely, it’s desperation step and company is trying to save project… more often company is trying to save itself from outrage of existing community and userbase after cancelling product. The only way it can end well is when there already exist active project community that will fork project, and continue to maintain project. And usually that’s not a case - since product was developed as a closed sourced project it usually don’t have huge community of developers that are engaged enough to pick up dropped ball.&lt;/p&gt;

&lt;h1&gt;Stage 2 - Open facade&lt;/h1&gt;

&lt;p&gt;In this model company still actively develops the application. Publicly available code is updated regularly, some people from the company are responding to the issues (it’s often used only as a public bug tracker). But all decisions, discussions about new features, bug fixes are done internally in company using private communications channels - community has no impact on the direction of the product, communication is often only one-way - community tries to give it feedback, and suggest way forward but usually there is no respond from the company (even if some of those suggestions are taken into account by some members of the development team), PRs are ignored or actively discouraged. In terms of building community this level is often even worse than previous stage - at least fact that no one cares about project forces the community to step up (if there is need for the project), in this stage community is discouraged to do anything - it has no impact, and someone else is developing the project. In longer term it’s really bad - it creates community that is 100% reliant on the company building the product, and that is unable to step up when needed (for example to extend ecosystem of the project).&lt;/p&gt;

&lt;h1&gt;Stage 3 - Development in the open&lt;/h1&gt;

&lt;p&gt;That’s the level when company can see first real advantages of the Open Source methodologies, it’s also level where most companies trying to embrace OSS are at. In this stage company develops product in the open - code development is done directly on GitHub (or other provider), discussions about product future (or at least some of them) are done using public channels such as issues. Bug reports are treated seriously, feature requests are discussed in with the community in the public, PRs are getting accepted as long as they follow the direction of the project set by company. This level creates decently engaged community - even though community and external developers can’t dictate future of the project, and direction it’s going to be developed in they still can at least quickly fix the bugs and problems they encounter. They also feels that company is taking their feedback seriously - as long as the communication works decently, most external developers can understand why some features are not going to be implemented, or they are not priority. Company can expect decent feedback focused on the technical level - the implementation details, as that’s something that’s focus point of the community. However, communication is still mostly “initialized” by the community - they report bugs, or suggest feature requests and then development team from the company responds to that. Also the company goals are still focal point of the development - they dictate development plans and what feature requests are accepted.&lt;/p&gt;

&lt;h1&gt;Stage 4 - Enlightened despot&lt;/h1&gt;

&lt;p&gt;At this level company starts to understand that short term business goals are less important for the success than long term growth of the community. In terms of development practices it’s really similar to previous level - development is done in the open, things are discussed in public channels, PRs are getting accepted. The difference is really subtle but important - the company is actively trying to look for the feedback about product future (and not only particular features), communication is often initialized by development team, the short term road maps (for example monthly iteration plans) are published so the community knows what the development team is going to focus on. The project is still in the formal control of the company (only members of the company have write access to the repository) but the product is developed with community being focal point of the process. This model creates really engaged community as it puts lot of weight on communication with community. It also makes community feel that it has real impact on the project and that company cares not only about business goals but also abut growth of ecosystem. In this model company can expect lot of really good feedback (both positive and negative), which increases chances of making right decisions about everything… from general decisions about project future to implementation details.&lt;/p&gt;

&lt;h1&gt;Stage 5 - Community based Open Source&lt;/h1&gt;

&lt;p&gt;At this stage company not only focuses on the community, it becomes part of the community equals to all other contributors. Decisions are made by consensus between all parts of the community. The write access to repository is given to the external developers that are not hired by the company, developers that are hired by the company are not getting automatically write access just because they are hired - they need to follow same path as any other member of the community, proof to be a good actor in the community. Community starts to self govern itself - there no longer exist one entity that’s formally more important than other parts of the community. There are no private commination channels as every member of the community has access to information. Really often general project roadmaps stops existing - there is no way of forcing everyone in the community to work on some particular set of features, people tend to work on features they want to have implemented (of course, as long as they are in the scope of the projects and community generally agrees that it’s needed feature). This model brings to the project not only great discussions, great developers (that you wouldn’t necessarily be able to hire) but also great leaders, maintainers and evangelists - people that really care about your project, that will be willing to spend lot of time and effort to develop product and its ecosystem.&lt;/p&gt;

&lt;h1&gt;Problems with embracing Community based OSS&lt;/h1&gt;

&lt;p&gt;Companies are often really afraid of the governance model in which they give up parts of their privileges connected with absolute power over the project. They often state that they need to maintain control to make sure that the product will be developed in right direction (even if they are OK with putting community in the center of this direction, or at least consult it with community). I believe that there are two points that are often missed when this argument is raised. First of all - development team hired by the company still can focus on those features, and those parts of the project that are most important for your business - company still can have its roadmaps and plans that are important for hired development team. Secondly, if we assume that whole community will agree on given direction, community itself will be the best entity that will ensure that product is developed in direction that was agreed on by all parts. As long as the company understands that growth of the community and ecosystem is good for the business in long term, everything should be fine.&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this blog post I’ve described several different models for embracing Open Source development methodologies. I belive that it’s clear that even though putting code in public with OSS license is good move, the real power of the OSS is collaboration with the community - and more effort is put into this collaboration, more control is given over to communing, the better results will be - from creating really engaged user base that cares enough to report bugs and suggest new features on its own, through getting some technical feedback and small bug fixes, to creating real self governing community that will create its own leaders, and evangelists, that will include some people that you couldn’t bring to project otherwise.&lt;/p&gt;

</description>
                <pubDate>Mon, 12 Jun 2017 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Path-to-community-based-OSS</link>
                <guid isPermaLink="true">http://kcieslak.io/Path-to-community-based-OSS</guid>
                
                <category>Open Source</category>
                
                <category>Community</category>
                
                
            </item>
        
            <item>
                <title>Using Paket with Azure Functions</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://azure.microsoft.com/en-us/services/functions/&quot;&gt;Azure Functions&lt;/a&gt; is Microsoft’s implementation of serverless architecture hosted on Azure. It is a solution for easily running small pieces of code, or “functions,” in the cloud. You can write just the code you need for the problem at hand, without worrying about a whole application or the infrastructure to run it. Functions can be written in many different languages, including F#.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Workflow problem&lt;/h1&gt;

&lt;p&gt;Azure Functions can be developed using online editor avaliable on Azure Portal - unfortunetlly it doesn’t provides any rich editing features (autocomplete, tooltips etc) we all like in our normal editors. Luckily, Azure Functions can be also created (and tested) locally, and configured to use GitHub repository (or couple other sources) as source of code, creating very nice Continues Deployment process (coding on local machine -&amp;gt; pushing code to GitHub -&amp;gt; deployment to Azure is automatically triggered). This way we should be able to use our rich editor tooling to develop Functions.&lt;/p&gt;

&lt;p&gt;However, there is small problem. For sake of simplicity, dependency menagment in Azure Functions is using quite a lot of &lt;em&gt;magic&lt;/em&gt;. Essensially, all you need to do is create &lt;code&gt;project.json&lt;/code&gt;, put there your dependency… and then you can just put &lt;code&gt;#r dependency_name&lt;/code&gt; in your deployed &lt;code&gt;.fsx&lt;/code&gt; file to reference it. But as we know, that’s not exactly how things work in normal F# scripting - usually we need to add relative path to &lt;code&gt;.dll&lt;/code&gt;, not just a name of reference. What’s more I haven’t found a way to restore dependencies using Azure Functions CLI tool (which follows Microsoft’s tradition of calling totally unusable software &lt;code&gt;beta&lt;/code&gt;).&lt;/p&gt;

&lt;h1&gt;Paket Strikes Back&lt;/h1&gt;

&lt;p&gt;Instead of fighting with bad workflow suggested by Microsoft, I’ve decided to do what F# developers usually do - use created by Community tool. And our solution to dependency management problem is &lt;a href=&quot;https://fsprojects.github.io/Paket/&quot;&gt;Paket&lt;/a&gt;
We normally initialize Paket, put &lt;code&gt;paket.bootstraper.exe&lt;/code&gt; in &lt;code&gt;.paket&lt;/code&gt; folder, create &lt;code&gt;paket.dependencies&lt;/code&gt; file, install dependency. Thanks to that we can use &lt;code&gt;#r&lt;/code&gt; reference with relative path to our dependency (which is downloaded to packages folder). For example: &lt;code&gt;#r &quot;../packages/Tesseract/lib/net45/Tesseract.dll&quot;&lt;/code&gt;. This let us to use full power of our editors to develop Azure Functions locally.&lt;/p&gt;

&lt;h1&gt;Deployment to Azure&lt;/h1&gt;

&lt;p&gt;Now we need to force Azure to run Paket after deploying code from our repository to cloud. Doing it is fairly simple, but not documented too well.&lt;/p&gt;

&lt;p&gt;First of all, in root of our repository we create &lt;code&gt;build.cmd&lt;/code&gt; file running Paket.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;@echo off
cls

.paket\paket.bootstrapper.exe
if errorlevel 1 (
  exit /b %errorlevel%
)

.paket\paket.exe restore --force
if errorlevel 1 (
  exit /b %errorlevel%
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second step is using deployment configuration file to run our &lt;code&gt;build.cmd&lt;/code&gt;. We create &lt;code&gt;.deployment&lt;/code&gt; file and add there following entry:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[config]
SCM_POST_DEPLOYMENT_ACTIONS_PATH = ../wwwroot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It configures where deployment utility will look for any post deployment scripts (and &lt;code&gt;.cmd&lt;/code&gt; file) after cloning and coping our repository. &lt;code&gt;wwwroot&lt;/code&gt; is root folder which will contain our Function after deployment.&lt;/p&gt;

&lt;p&gt;Having those 2 files, we can push code to GitHub, go to Azure Portal, check deployments of our Function App. If everything is OK we should see Paket output in post deployment actions log.&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post, I’ve presented how to use Paket together with Azure Functions to create nice workflow for developing applications using this modern platform. The sample code can be found on GitHub - https://github.com/Krzysztof-Cieslak/AzureFunctionsSamples&lt;/p&gt;
</description>
                <pubDate>Tue, 22 Nov 2016 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/Using-Paket-with-Azure-Functions</link>
                <guid isPermaLink="true">http://kcieslak.io/Using-Paket-with-Azure-Functions</guid>
                
                <category>F#</category>
                
                <category>Paket</category>
                
                <category>Azure Functions</category>
                
                
            </item>
        
            <item>
                <title>Dynamically extending F# applications</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Changing requirements, introducing different data format, extending applications with new features. All those things requires us (developers) to go to code, do changes, add API versioning system (to be backward compatible), add configuration for turning on/off new features, compile application, and at the end release new application (what itself may be complex process). It’s often lot of work required for every, even very small, change.&lt;/p&gt;

&lt;p&gt;In this post I’ll present way to add new features to our F# application - dynamically, on runtime, without any recompiling and redeployment of application. What’s more extensions will be also defined using F#… in fact they will be simple F# script files.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Sample application&lt;/h1&gt;

&lt;p&gt;Our sample application for this blog post will be rather simple - it will be F# console application, taking user input as string, performing set of transformations on this input and just printing out result. Transformation for our input will be dynamically loaded on runtime - initially, before user add any plugins, application just returns same value as user typed in.&lt;/p&gt;

&lt;p&gt;We can simply define our transformation as &lt;code&gt;type Transformation = string -&amp;gt; string&lt;/code&gt; and operation we perform on input as &lt;code&gt;let output = lstOfTransformations |&amp;gt; List.fold (fun state transform -&amp;gt; transform state ) input&lt;/code&gt;.&lt;/p&gt;

&lt;h1&gt;Evaluating plugins files&lt;/h1&gt;

&lt;p&gt;As I’ve mentioned our aim is to define extensions as simple F# script files. But while we can easily read text put in &lt;code&gt;.fsx&lt;/code&gt; file, F# doesn’t have anything like JavaScript’s &lt;code&gt;eval()&lt;/code&gt; function built-in, no way to take text containing code and evaluating its value. But this is a moment where &lt;code&gt;FSharp.Compiler.Services&lt;/code&gt; enters the scene. FCS (not to confuse with FSC which is F# compiler) is fork of F# compiler that exposes additional functionality for implementing F# editor features, and additional tools based on the compiler. It also includes F# interactive service that can be used for embedding F# scripting into your applications.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you want learn more about &lt;code&gt;FSharp.Compiler.Services&lt;/code&gt; visit &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/&quot;&gt;FCS webpage&lt;/a&gt; to see documentation of available features, APIs, and list of projects using FCS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For our purpose we need two things - first we’ll create embedded in our application F# Interactive session, and then we will use it to load file with plugin and evaluate it.&lt;/p&gt;

&lt;p&gt;Creating FSI session is pretty straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;open Microsoft.FSharp.Compiler.Interactive.Shell

let sbOut = StringBuilder()
let sbErr = StringBuilder()

let fsi =
    let inStream = new StringReader(&quot;&quot;)
    let outStream = new StringWriter(sbOut)
    let errStream = new StringWriter(sbErr)
    let fsiConfig = FsiEvaluationSession.GetDefaultConfiguration()
    let argv = [| &quot;/temo/fsi.exe&quot;; |]
    FsiEvaluationSession.Create(fsiConfig, argv, inStream, outStream, errStream)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we can use FSI session to load file with extension and evaluate it’s content.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt; let evaluate path =
    let mdl = getOpen path
    let load = getLoad path

    fsi.EvalInteractionNonThrowing(sprintf &quot;#load \&quot;%s\&quot;;;&quot; load)
    fsi.EvalInteractionNonThrowing(sprintf &quot;open %s;;&quot; mdl)
    fsi.EvalExpressionNonThrowing &quot;map&quot;

    match res with
    | Choice1Of2 (Some f) -&amp;gt;
        f.ReflectionValue :?&amp;gt; Transformation |&amp;gt; Some
    | _ -&amp;gt; None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we find full path to file we want to load, and name of default module for this file (it’s name of the file with first character uppercase).&lt;/p&gt;

&lt;p&gt;We execute in FSI &lt;code&gt;#load&lt;/code&gt; statement to load content of extension file, and then we open default module. Last operation is executing &lt;code&gt;map&lt;/code&gt; in FSI which will return value of this expression (so function).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For sake of simplicity in sample, we make several assumptions about extensions files - we don’t define modules inside of &lt;code&gt;.fsx&lt;/code&gt; files and they contain only single function  &lt;code&gt;map : string -&amp;gt; string&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If everything is working we can now load F# script file and get from it normal F# function which we can execute somewhere else in our code!&lt;/p&gt;

&lt;h1&gt;Loading plugins on runtime&lt;/h1&gt;

&lt;p&gt;Next important feature of our application is dynamically loading (and unloading) scripts when users creates (or removes) them. For this we will use built-in .Net FileSystemWatcher class which let developer to perform operations whenever new file is created, file is removed etc. in given directory.&lt;/p&gt;

&lt;p&gt;We just create really simple functions which takes 2 functions (one executed when file is added, second one when file is removed) and directory to watch for changes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;let create addCb rmCb dir =
    if Directory.Exists dir |&amp;gt; not then Directory.CreateDirectory dir |&amp;gt; ignore

    let watcher = new FileSystemWatcher()
    watcher.Filter &amp;lt;- &quot;*.fsx&quot;
    watcher.Path &amp;lt;- dir
    watcher.Created.Add (fun n -&amp;gt; n.FullPath |&amp;gt; addCb)
    watcher.Deleted.Add (fun n -&amp;gt; n.FullPath |&amp;gt; rmCb)
    watcher.Renamed.Add (fun n -&amp;gt; n.OldFullPath |&amp;gt; rmCb; n.FullPath |&amp;gt; addCb)
    watcher.Changed.Add (fun n -&amp;gt; n.FullPath |&amp;gt; rmCb; n.FullPath |&amp;gt; addCb)
    watcher.SynchronizingObject &amp;lt;- null
    watcher.EnableRaisingEvents &amp;lt;- true

    watcher
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Plugins register&lt;/h1&gt;

&lt;p&gt;The last important part is storing list of the transformations in memory when application is running. Since FileWatcher is running asynchronously in background of our applications we are afraid of any potential race conditions so we won’t use any global mutable state to do so. Instead we will encapsulate state of our application in agent.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;To learn more about F# Agents visit Scott Wlaschin’s &lt;a href=&quot;https://fsharpforfunandprofit.com/posts/concurrency-actor-model/&quot;&gt;post about them&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;type private Msg =
    | Add of string * Transformation
    | Remove of string
    | Get of AsyncReplyChannel&amp;lt;Transformation list&amp;gt;

let private register =
    MailboxProcessor.Start (fun inbox -&amp;gt;
        let rec loop lst = async {
            let! msg = inbox.Receive()
            match msg with
            | Add (n,f) -&amp;gt;
                return! loop ((n,f)::lst)
            | Remove n -&amp;gt;
                return! loop (lst |&amp;gt; List.filter(fun (f,_) -&amp;gt; f &amp;lt;&amp;gt; n))
            | Get rc -&amp;gt;
                let l = lst |&amp;gt; List.map snd
                rc.Reply l
                return! loop lst
        }
        loop [] )

let add name fnc =
    (name, fnc) |&amp;gt; Add |&amp;gt; register.Post

let remove name =
    name |&amp;gt; Remove |&amp;gt; register.Post

let get () =
    register.PostAndReply Get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our agent can perform 3 operations - add transformation, remove it, or return list of all transformations.&lt;/p&gt;

&lt;h1&gt;Putting things together&lt;/h1&gt;

&lt;p&gt;The last step is putting whole application together:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;EntryPoint&amp;gt;]
let main argv =
    let remove path =
        let fn = Path.GetFileNameWithoutExtension path
        Register.remove fn

    let add path =
        let fn = Path.GetFileNameWithoutExtension path
        match Evaluator.evaluate path |&amp;gt; Option.map (fun ev -&amp;gt; Register.add fn ev ) with
        | Some _ -&amp;gt; ()
        | None -&amp;gt; printfn &quot;File `%s` couldn't be parsed&quot; path

    let watcher = Watcher.create add remove &quot;scripts&quot;

    while true do
        let input = System.Console.ReadLine ()
        let lst = Register.get ()
        let res = lst |&amp;gt; List.fold (fun s e -&amp;gt; e s ) input
        printfn &quot;Result: %s&quot; res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we define callbacks for file watcher - on file remove we just send message to extensions register to remove it, when file is added we try to evaluate it and if it was successful we send message to agent to add it to list.&lt;/p&gt;

&lt;p&gt;Then we create watcher using those 2 functions watching &lt;code&gt;scripts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;Last step is loop which waits for user input, gets all transformations, apply them to input, and print out result at the end. Here is small demo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/gifs/FunctionLoader.gif&quot; alt=&quot;Function Loader demo&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post I’ve shown how to use &lt;code&gt;FSharp.Compiler.Services&lt;/code&gt; to add dynamic extensibility mechanism to F# applications. Sample presented in this blog post was really simple, but I believe that this technique can be also used for more complex, real world applications (hopefully, I’ll be able to create some more complex project using this method soon ;) ). Full code for sample application can be found on &lt;a href=&quot;https://gitlab.com/Krzysztof-Cieslak/FunctionLoader&quot;&gt;GitLab (!)&lt;/a&gt;&lt;/p&gt;
</description>
                <pubDate>Mon, 03 Oct 2016 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Dynamically-extending-F-applications</link>
                <guid isPermaLink="true">http://kcieslak.io/Dynamically-extending-F-applications</guid>
                
                <category>F#</category>
                
                <category>FSharp.Compiler.Services</category>
                
                
            </item>
        
            <item>
                <title>Working with F# projects in VSCode</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, OS X and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages (C++, C#, Python, PHP) and runtimes. The F# support for VSCode is provided by &lt;a href=&quot;http://ionide.io&quot;&gt;Ionide&lt;/a&gt; - set of extensions adding F# support, as well as Paket and FAKE.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you’re new VSCode user installing extensions is pretty easy - press extensions button on left panel, search for Ionide, press install for all Ionide extensions, wait untill all are installed and restart VSCode.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ionide-FSharp provides wide set of features useful for F# developer - from simple autocomplete and tooltips, through F# Interactive integration, to navigating to symbols or finding all usages of symbol.&lt;/p&gt;

&lt;p&gt;It also comes with decent support for F# projects (defined using &lt;code&gt;.fsproj&lt;/code&gt; file).&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Working with existing projects&lt;/h1&gt;

&lt;p&gt;Working with existing projects (created using Visual Studio or other IDE) should be pretty straightforward - opening root of your repository / solution will start Ionide. Plugin should find all project files in repository and parse them.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Warning - this process can take some time, especially on huge solutions. You can still edit files without any problem, but it make take a while before are features are started - the priority is put on providing features like tooltips, autocomplete or error highlighting for currently opened files. Solution level features (finding all errors in solution, navigating to any symbol in solution, rename, etc ) take bit longer to start.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;Creating new projects&lt;/h1&gt;

&lt;p&gt;Ionide thanks to &lt;a href=&quot;https://github.com/fsprojects/Forge&quot;&gt;Forge&lt;/a&gt; integration provides ability to create new F# projects without using full IDE. Creating new project is as simple as running &lt;code&gt;F#: New Project&lt;/code&gt; command.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;All VSCode commands can be run using command palette, it can be started using &lt;code&gt;Ctrl(Cmd)+Shift+P&lt;/code&gt; keybord shortcut.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ionide will ask about project name, directory where place new project, and project template. Currently there are about 15 different project templates, hopefully more will come in the future thanks to Community contributions to Forge.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Warning - even if you just create new project, you should have VS Code open in empty directory. It does not create “solution” directory, and assumes that is run from repository root.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Creating new project will also initialize Paket and FAKE, and create sample build script in repository root. This won’t happen if you’re just adding new project to existing solution with Paket and FAKE.&lt;/p&gt;

&lt;h1&gt;Handling files in project&lt;/h1&gt;

&lt;p&gt;As you probably know, &lt;code&gt;fsproj&lt;/code&gt; files contain list of F# (&lt;code&gt;.fs&lt;/code&gt;) files which will be compiled during build process. What’s important is that ordering of those files matters… and it’s huge F# feature. But this topic was already covered in amazing &lt;a href=&quot;https://fsharpforfunandprofit.com/series/dependency-cycles.html&quot;&gt;Scott Wlaschin’s blog&lt;/a&gt;. So, back to the topic.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Warning - Forge tends to do some additional changes to project file, so for first few times (unless you’re already comfortable with usual Forge changes) I recommend doing git commit before running Forge commands - it will make easier for you to check what changes Forge makes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are few commands which makes handling files easier. First of all, you can add or remove currently open file from project using &lt;code&gt;F#: Add Current File To Project&lt;/code&gt; and &lt;code&gt;F#: Remove Current File To Project&lt;/code&gt;. Forge will try to find appropriate project file and add or remove file there.&lt;/p&gt;

&lt;p&gt;Another important operation is file ordering - to control it &lt;code&gt;F#: Move File Up&lt;/code&gt; and &lt;code&gt;F#: Move File Down&lt;/code&gt; commands exist.&lt;/p&gt;

&lt;h1&gt;Handling references&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;fsproj&lt;/code&gt; files contain also list of used references. Generally there are 3 types of those - external references from NuGet (this type is handled by Paket), project references and GAC references. To handle 2 later cases Ionide provides two commands.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;F#: Add Project Reference&lt;/code&gt; command will ask you which project you want to edit (there will be list of all projects found in current workspace), and after which project you want to reference. For GAC references Ionide provides &lt;code&gt;F#: Add Reference&lt;/code&gt; command which works in very similar way.&lt;/p&gt;

&lt;h1&gt;Solution-wide editor features&lt;/h1&gt;

&lt;p&gt;Ionide’s editor features are probably good topic for another post, but let’s quickly go through some features which works on solution level:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;On file save, Ionide parse all projects and find all error in solution. They can be viewed in error panel (&lt;code&gt;Ctrl(Cmd) + Shift + M&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Go-to-Definition (&lt;code&gt;F12&lt;/code&gt;), Find all references (&lt;code&gt;Shift+F12&lt;/code&gt;), Peek definition (&lt;code&gt;Alt + F12&lt;/code&gt;) works across all projects in solution&lt;/li&gt;
  &lt;li&gt;Rename (&lt;code&gt;F2&lt;/code&gt;) works across all projects in solution&lt;/li&gt;
  &lt;li&gt;Same for navigating to symbol (&lt;code&gt;Ctrl(Cmd)+T&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post, I’ve presented some Ionide’s features which makes supporting and handling F# projects in Visual Studio Code. There are still not as many project editing features as in Visual Studio or Xamarin Studio, but I belive that it’s good start point, and nice set of features for lightweight editor.&lt;/p&gt;
</description>
                <pubDate>Wed, 27 Jul 2016 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Working-with-F-Projects-In-VSCode</link>
                <guid isPermaLink="true">http://kcieslak.io/Working-with-F-Projects-In-VSCode</guid>
                
                <category>F#</category>
                
                <category>VS Code</category>
                
                <category>Tooling</category>
                
                
            </item>
        
            <item>
                <title>Creating custom project file for F#</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Let’s imagine a world where F# is independent language, with cross-platform tooling making life of every F# developer easier. In this world, after we’ve fixed dependency management problem with Paket, we could go one step further… and fix project file format and building. We would use same principles as Paket - very simple, human readable, file format which can be edited without any other tooling, and command line tool responsible for building such project.&lt;/p&gt;

&lt;p&gt;In such world I’ve decided to create new open-source project called &lt;code&gt;Chris&lt;/code&gt;&lt;/p&gt;

&lt;h1&gt;File format&lt;/h1&gt;

&lt;p&gt;For our hypothetical project file (called &lt;code&gt;project.chris&lt;/code&gt;) I’ve decided to use &lt;code&gt;toml&lt;/code&gt;. In this very simple file we would just specify few properties, files of our project, GAC references and external NuGet packages. It would look like as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[Info]
Name = &quot;Fancy_Test_Project&quot;
Author = &quot;Lambda Factory&quot;
Git = &quot;&quot;

[Stuff]
References = [&quot;mscorlib&quot;, &quot;System&quot;, &quot;System.Core&quot;, &quot;System.Numerics&quot;]
Files = [&quot;Message.fs&quot;, &quot;Test.fs&quot;]
Packages = []
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;

&lt;h1&gt;Build&lt;/h1&gt;

&lt;p&gt;Most important feature of every project system is ability to build project to executable version. As I’ve mentioned earlier one of the important points I’d like to address is ability to build project with command line with very simple commands. To build any F# project, in the end - no matter which project system we use, we have to execute F# Compiler with &lt;a href=&quot;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/compiler-options-%5bfsharp%5d&quot;&gt;appropriate arguments&lt;/a&gt; (defining references, different build options, and source files).&lt;/p&gt;

&lt;p&gt;In this case I’ve created really simple console application which user runs in project directory and it builds project, and produce &lt;code&gt;.exe&lt;/code&gt; file. To parse &lt;code&gt;toml&lt;/code&gt; I’ve decided to use &lt;a href=&quot;https://github.com/paiden/Nett&quot;&gt;Nett library&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First step is defining model representing our project, what is rather straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;type Info = {
    Name : string
    Author : string
    Git : string
}

type Stuff = {
    Files : string []
    References : string []
    Packages : string []
}

type Project = {
    Info : Info
    Stuff : Stuff
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next step is creating 2 helper functions - one loading &lt;code&gt;project.chris&lt;/code&gt; and parsing it to our model, second one transforming this model to right F# Compiler arguments. Again, nothing complex.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;let load (path : string) =
    let tmp = Toml.ReadFile path
    let info = tmp.Get&amp;lt;TomlTable&amp;gt; &quot;Info&quot;
    let stuff = tmp.Get&amp;lt;TomlTable&amp;gt; &quot;Stuff&quot;
    {
        Info = {
                Name = info.Get&amp;lt;string&amp;gt;(&quot;Name&quot;)
                Author = info.Get&amp;lt;string&amp;gt;(&quot;Author&quot;)
                Git = info.Get&amp;lt;string&amp;gt;(&quot;Git&quot;) }
        Stuff = {
                Files = stuff.Get&amp;lt;string []&amp;gt;(&quot;Files&quot;)
                References = stuff.Get&amp;lt;string []&amp;gt;(&quot;References&quot;)
                Packages = stuff.Get&amp;lt;string []&amp;gt;(&quot;Packages&quot;) }
    }, path

let toFSCParams (project, path) =
    let folder = Path.GetDirectoryName path
    let output = sprintf &quot;%s.exe&quot; project.Info.Name
    [|
        yield &quot;-out:&quot; + output
        yield @&quot;-r:C:\Program Files (x86)\Reference Assemblies\Microsoft\FSharp\.NETFramework\v4.0\4.3.1.0\FSharp.Core.dll&quot;
        for r in project.Stuff.References do
            yield sprintf @&quot;-r:C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5\%s.dll&quot; r

        yield &quot;--noframework&quot;
        for f in project.Stuff.Files do
            yield  Path.Combine (folder, f)
    |]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last step is creating function which runs F# Compiler. To do so we will use &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/&quot;&gt;FSharp.Compiler.Service&lt;/a&gt; - .Net library that exposes functionality for implementing F# language bindings, additional tools based on the compiler or refactoring tools. What’s most important in this case it also let’s &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/compiler.html&quot;&gt;host F# compiler inside other application&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;open Microsoft.FSharp.Compiler
open Microsoft.FSharp.Compiler.SourceCodeServices
open Microsoft.FSharp.Compiler.SimpleSourceCodeServices

let build (project,path) =
    let scs = SimpleSourceCodeServices()
    let parm =  (project, path) |&amp;gt; toFSCParams
    parm |&amp;gt; scs.Compile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And at the end we pipe it together:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;[&amp;lt;EntryPoint&amp;gt;]
let main argv =
    let errors, exit =
        &quot;project.chris&quot;
        |&amp;gt; Path.GetFullPath
        |&amp;gt; load
        |&amp;gt; build
    exit // return an integer exit code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can build our project!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/gifs/chris_build.gif&quot; alt=&quot;Build with Chris&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Editor support&lt;/h1&gt;

&lt;p&gt;Another important part of project system is providing information for F# Language Services which lets us to create rich editing environment across many different editors. Fortunatly FSharp.Compiler.Service is designed to be totally decoupled from project file format and requires its &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/reference/microsoft-fsharp-compiler-sourcecodeservices-fsharpprojectoptions.html&quot;&gt;custom type&lt;/a&gt; to provide all nice &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/editor.html&quot;&gt;Language Services features&lt;/a&gt;. Since we already have function loading &lt;code&gt;project.chris&lt;/code&gt; to memory all we need to do is creating function which maps our type to type required by FCS.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;let toFSharpProjectOptions (project, path) =
    let rsp = (project, path) |&amp;gt; toFSCParams
    {
      ProjectFileName = path
      ProjectFileNames = [||]
      OtherOptions = rsp
      ReferencedProjects = [||]
      IsIncompleteTypeCheckEnvironment = false
      UseScriptResolutionRules = false
      LoadTime = System.DateTime.Now
      UnresolvedReferences = None;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next step is actually adding support for &lt;code&gt;project.chris&lt;/code&gt; to our editor of choice. It’s pretty easy for all editors and tools using FSharp.Compiler.Service in the background, but for sake of simplicity I’ve chosen &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VS Code&lt;/a&gt; with &lt;a href=&quot;https://ionide.io&quot;&gt;Ionide&lt;/a&gt;. As you may know, VS Code is editor created using &lt;a href=&quot;http://electron.atom.io/&quot;&gt;Electron&lt;/a&gt; which is framework for building cross-platform, desktop applications using HTML, JS, and CSS. Such choice has many advantages, but one bug important drawback from F# editor tooling point of view - we can’t directly use .Net libraries in VS Code. To communicate with .Net libraries (and especially with FSharp.Compiler.Service) we are using &lt;a href=&quot;https://github.com/fsharp/FsAutoComplete&quot;&gt;FsAutoComplete&lt;/a&gt; - F# compiler service API exposed via a console application and HTTP server.&lt;/p&gt;

&lt;p&gt;Adding &lt;code&gt;project.chris&lt;/code&gt; support to FsAutoComplete is, again, fairly easy. First step is adding Chris project as reference to FsAutoComplete. Next we create helper function which will be executed if we try to load &lt;code&gt;project.chris&lt;/code&gt; file - it’s basically copy-paste of &lt;a href=&quot;https://github.com/fsharp/FsAutoComplete/blob/master/src/FsAutoComplete.Core/CompilerServiceInterface.fs#L189-L222&quot;&gt;same functions&lt;/a&gt; for &lt;code&gt;.fsproj&lt;/code&gt; and &lt;code&gt;project.json&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;  member x.TryGetChrisProjectOption (file : string) : Result&amp;lt;_&amp;gt; =
    if not (File.Exists file) then
      Failure (sprintf &quot;File '%s' does not exist&quot; file)
    else
      try
        let po = file |&amp;gt; Chris.load |&amp;gt; Chris.toFSharpProjectOptions
        let compileFiles = Seq.filter (fun (s:string) -&amp;gt; s.EndsWith(&quot;.fs&quot;)) po.OtherOptions
        let outputFile = Seq.tryPick (chooseByPrefix &quot;--out:&quot;) po.OtherOptions
        let references = Seq.choose (chooseByPrefix &quot;-r:&quot;) po.OtherOptions
        Success (po, Seq.toList compileFiles, outputFile, Seq.toList references, Map&amp;lt;string,string&amp;gt;([||]))
      with e -&amp;gt;
        Failure e.Message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last step is modifying &lt;a href=&quot;https://github.com/fsharp/FsAutoComplete/blob/master/src/FsAutoComplete.Core/FsAutoComplete.Core.fs#L51-L55&quot;&gt;handler for project request&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;let options =
    if file.EndsWith &quot;fsproj&quot; then
        checker.TryGetProjectOptions(file, verbose)
    elif file.EndsWith &quot;chris&quot; then
        checker.TryGetChrisProjectOption file
    else
        checker.TryGetCoreProjectOptions file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compile FSAC, copy modified version to Iondie plugin folder… and that’s all. Everything is working as always, just with &lt;code&gt;project.chris&lt;/code&gt;.
&lt;img src=&quot;images/gifs/chris_editor.gif&quot; alt=&quot;Editor with Chris&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Frequently Asked Question&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Q: You haven’t mentioned VS at all, it surely means you hate it and ignore, right?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: No, VS (with VFPT installed) is best F# IDE, but I don’t use it too much. Adding custom project file support to VS is definitely possible, it just requires knowledge I don’t have. Thus, I haven’t mentioned it in post.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: What about C# / F# interoperability, compatibility with existing F# projects?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: In worst case scenario - we have compatibility on compiled code / package level ( I can imagine some workflow using Paket which would make it not too problematic). In “best” case - custom MsBuild task, but again, I don’t have enough knowledge to judge how possible it is.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: You’re just one of those elitist, arrogant guys thinking they are better because they use this new-overhyped thing - functional programming. You just hate MsBuild because it’s C#!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: Yes, indeed. Move along. Nothing to see here.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: What about support for any other F# tooling such as FSharpLint?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: Any tool using FSharp.Compiler.Service should be very easy to port, as presented above on FsAutoComplete example.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: Where is code, I want to use it now!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: Code of this experiment is not published anywhere on purpose - I don’t want anyone to use it by any chance. It was just very simple proof of concept. Hopefully, one day F# Community will be ready for new project system.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: I &lt;strong&gt;really&lt;/strong&gt; want to use something like that&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: Ask &lt;a href=&quot;https://twitter.com/7sharp9_exhumed&quot;&gt;Dave Thomas&lt;/a&gt; about his Xebec project, and support &lt;a href=&quot;https://twitter.com/7sharp9_exhumed/status/745995222178480128&quot;&gt;fsprojexit&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post I’ve presented possible ways of expanding F# development environment with new project system. I haven’t shown here any ready solutions for the problem but I hope that this post shows that having new, better project system is possible. We just need as Community to start reasonable discussion about such possibility.&lt;/p&gt;
</description>
                <pubDate>Thu, 23 Jun 2016 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Creating-custom-project-file-for-F</link>
                <guid isPermaLink="true">http://kcieslak.io/Creating-custom-project-file-for-F</guid>
                
                <category>F#</category>
                
                <category>VS Code</category>
                
                <category>Tooling</category>
                
                
            </item>
        
            <item>
                <title>Getting started with Fable and Webpack</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/fsprojects/Fable&quot;&gt;Fable&lt;/a&gt; is new F# to JavaScript compiler created by &lt;a href=&quot;https://twitter.com/alfonsogcnunez&quot;&gt;Alfonso Garcia-Caro&lt;/a&gt;. In this post I’ll go, step by step, through process of creating client-side (browser) applications using it.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This post is targeted at F# developers without lot of knowladge about Node.js and JS ecosystem and it should let any F# developer to get started with Fable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Requirements&lt;/h3&gt;

&lt;p&gt;Fable requires having both &lt;a href=&quot;http://fsharp.org&quot;&gt;F# 4&lt;/a&gt; and &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;node 4.4&lt;/a&gt; or bigger installed in your computer.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Setting up project&lt;/h1&gt;

&lt;p&gt;The first thing we need to do is creating new directory and initializing node project:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir fable-test
cd fable-test
npm init
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;Npm&lt;/a&gt; is is the package manager for JavaScript. It lets users to find, share, and reuse packages of code or install additional tools&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;npm init&lt;/code&gt; will create &lt;code&gt;package.json&lt;/code&gt; file. This file is project file for any Node.js based project (both client and server side). At start it will contain only basic information about a project, something like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;name&quot;: &quot;fable-test&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;...&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Installing development tools.&lt;/h3&gt;

&lt;p&gt;Next step is installing all development dependencies (tools) which we’ll be using for our project. To do so we are using &lt;code&gt;npm install&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install --save-dev fable-compiler
npm install --save-dev webpack
npm install --save-dev source-map-loader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First line installs Fable compiler for our project. Second command installs &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt;. Webpack is a module bundler - it takes modules with dependencies and generates static assets representing those modules. In our case it would take generated by Fable files together with other JS libraries we will depend upon and create single file output which can be easily added to page. Last dependency is plugin to Webpack which will enable nice debugging story for our application (debugging F# files in the browser)&lt;/p&gt;

&lt;p&gt;It’s also worth noticing that those commands modified &lt;code&gt;package.json&lt;/code&gt; file, now it contains also following block:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;devDependencies&quot;: {
  &quot;fable-compiler&quot;: &quot;^0.2.12&quot;,
  &quot;source-map-loader&quot;: &quot;^0.1.5&quot;,
  &quot;webpack&quot;: &quot;^1.13.0&quot;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Installing dependencies&lt;/h3&gt;

&lt;p&gt;Now we will install our code dependencies using also &lt;code&gt;npm install&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install --save core-js
npm install --save fable-core
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;core-js&lt;/code&gt; is polyfill ensuring that code generated by Fable will run in any browser. &lt;code&gt;fable-core&lt;/code&gt; is standard Fable library.&lt;/p&gt;

&lt;p&gt;Those commands again modified &lt;code&gt;package.json&lt;/code&gt; file, this time adding following information:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;dependencies&quot;: {
    &quot;core-js&quot;: &quot;^2.4.0&quot;,
    &quot;fable-core&quot;: &quot;0.0.21&quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Creating F# script and HTML file&lt;/h3&gt;

&lt;p&gt;Fable supports both &lt;code&gt;fsproj&lt;/code&gt; and plain &lt;code&gt;fsx&lt;/code&gt; files. For simplicity in this example let’s use &lt;code&gt;fsx&lt;/code&gt; file. Create &lt;code&gt;source\code.fsx&lt;/code&gt; with follwing content:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;#r &quot;../node_modules/fable-core/Fable.Core.dll&quot;

open Fable.Core 
open Fable.Import
 
Node.require.Invoke(&quot;core-js&quot;) |&amp;gt; ignore

let element = Browser.document.getElementById &quot;sample&quot;
element.innerText &amp;lt;- &quot;Hello, world !!&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code should be pretty straightforward, only tricky part is &lt;code&gt;Node.require.Invoke(&quot;core-js&quot;)&lt;/code&gt; which is importing Node.js module (installed by &lt;code&gt;npm&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Let’s also create very simple HTML file &lt;code&gt;public\index.html&lt;/code&gt; ( &lt;code&gt;public&lt;/code&gt; will be our output folder):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta http-equiv='Content-Type' content='text/html; charset=utf-8'&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div id='sample'&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;script src=&quot;bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Configuration&lt;/h1&gt;

&lt;p&gt;First step is creating configuration for Fable compiler. It’s done by creating &lt;code&gt;fableconfig.json&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;module&quot;: &quot;commonjs&quot;,
  &quot;sourceMaps&quot;: true,
  &quot;projFile&quot;: &quot;./src/code.fsx&quot;,
  &quot;outDir&quot;: &quot;temp&quot;,
  &quot;scripts&quot;: {
    &quot;prebuild&quot;: &quot;npm install&quot;,
    &quot;postbuild&quot;: &quot;webpack&quot;
  },
  &quot;targets&quot;: {
    &quot;watch&quot;: {
      &quot;scripts&quot;: {
        &quot;postbuild&quot;: &quot;webpack --watch&quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we define module type - in our case it’s &lt;code&gt;commonjs&lt;/code&gt; (as it’s working well with &lt;code&gt;Webpack&lt;/code&gt;). Next we define that we want to use soruce maps (it allows F# file debugging), entry point of application, and output directory for compiled JS files.
Next step is defining some small scripts which will be run before and after every build - before we want to run &lt;code&gt;npm install&lt;/code&gt; to restore all dependencies, after build we run &lt;code&gt;webpack&lt;/code&gt; to create bundled output file. Last part defines additional target which will be executed in &lt;code&gt;watch&lt;/code&gt; mode. In such case we want to run &lt;code&gt;webpack&lt;/code&gt; also in &lt;code&gt;watch&lt;/code&gt; mode.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;watch&lt;/code&gt; mode will make Fable and Webpack to recompile project after every file save without need to execute any additional commands.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Webpack configuration&lt;/h3&gt;

&lt;p&gt;Second step is to create &lt;code&gt;webpack&lt;/code&gt; configuration. Let’s create &lt;code&gt;webpack.config.js&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var path = require(&quot;path&quot;);
var webpack = require(&quot;webpack&quot;);

var cfg = {
  devtool: &quot;source-map&quot;,
  entry: &quot;./temp/code.js&quot;,
  output: {
    path: path.join(__dirname, &quot;public&quot;),
    filename: &quot;bundle.js&quot;
  },
  module: {
    preLoaders: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: &quot;source-map-loader&quot;
      }
    ]
  }
};

module.exports = cfg;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this file we define that we want to use source maps, entry point for webpack ( so file generated by Fable), output path, and usage of any additional plugins (in our case it will be &lt;code&gt;source-map-loader&lt;/code&gt; installed before)&lt;/p&gt;

&lt;h3&gt;Npm scripts&lt;/h3&gt;

&lt;p&gt;Easiest way to run tools installed by &lt;code&gt;npm&lt;/code&gt; is by using scripts section in &lt;code&gt;packages.json&lt;/code&gt; file. Let’s put there following scripts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;scripts&quot;: {
  &quot;build&quot;: &quot;fable&quot;,
  &quot;watch&quot;: &quot;fable -w --target watch&quot;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;build&lt;/code&gt; just starts Fable. &lt;code&gt;watch&lt;/code&gt;, as name suggests, starts Fable in &lt;code&gt;watch&lt;/code&gt; mode, so code is regenerated every time we save F# file. We can run those scripts using &lt;code&gt;npm run &amp;lt;script_name&amp;gt;&lt;/code&gt; command.&lt;/p&gt;

&lt;h3&gt;VSCode configuration&lt;/h3&gt;

&lt;p&gt;Last, optional step is creating &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VSCode&lt;/a&gt; configuration. It’s fairly easy since editor has decent integration with &lt;code&gt;npm&lt;/code&gt;. All we need to do is create &lt;code&gt;.vscode\tasks.json&lt;/code&gt; file and put there following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;command&quot;: &quot;npm&quot;,
  &quot;isShellCommand&quot;: true,
  &quot;showOutput&quot;: &quot;always&quot;,
  &quot;suppressTaskName&quot;: true,
  &quot;tasks&quot;: [
    {
      &quot;taskName&quot;: &quot;install&quot;,
      &quot;args&quot;: [&quot;install&quot;]
    },
    {
      &quot;taskName&quot;: &quot;build&quot;,
      &quot;args&quot;: [&quot;run&quot;, &quot;build&quot;],
      &quot;isBuildCommand&quot;: true
    },
    {
      &quot;taskName&quot;: &quot;watch&quot;,
      &quot;args&quot;: [&quot;run&quot;, &quot;watch&quot;],
      &quot;isWatching&quot;: true
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we define that our tasks are using &lt;code&gt;npm&lt;/code&gt; and we define arguments send to &lt;code&gt;npm&lt;/code&gt; with every task. 
We can run those task usign &lt;code&gt;Tasks: Run Task&lt;/code&gt; command (&lt;code&gt;build&lt;/code&gt; task can be also run using &lt;code&gt;Tasks: Run Build Command&lt;/code&gt; command or &lt;code&gt;Ctrl + Shift + B&lt;/code&gt;)&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post we have shortly moved all steps necessary to create browser, client-side applications using F#, Fable and Webpack. Whole source code of this sample application is on GitHub - https://github.com/Krzysztof-Cieslak/fable-webpack-demo&lt;/p&gt;
</description>
                <pubDate>Mon, 16 May 2016 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Getting-Started-with-Fable-and-Webpack</link>
                <guid isPermaLink="true">http://kcieslak.io/Getting-Started-with-Fable-and-Webpack</guid>
                
                <category>F#</category>
                
                <category>Fable</category>
                
                <category>VS Code</category>
                
                <category>Webpack</category>
                
                <category>JS</category>
                
                
            </item>
        
            <item>
                <title>Creating VS Code plugins with F# and Fable</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;EDIT 22.03.2016&lt;/em&gt; Thanks to Alfonso’s help I was able to remove postbuild step fixing JS.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VS Code&lt;/a&gt; is new text editor (or rather lightweight IDE) created by Microsoft. Because it is product based on &lt;a href=&quot;http://electron.atom.io/&quot;&gt;Electron&lt;/a&gt; - cross platform engine allowing developers to write desktop applications using web technologies - its plugin system supports JavaScript (and TypeScript). Unfortunately both those languages are not nice choice for someone using statically typed functional programming languages like F#. Up to this moment in my VS Code extensions I was using F# library called &lt;a href=&quot;http://funscript.info/&quot;&gt;FunScript&lt;/a&gt; which compiles F# code to JavaScript. Whereas it sounds nice, library has some problems which makes writing code using it not nice experience. Fortunately recently, &lt;a href=&quot;https://twitter.com/alfonsogcnunez&quot;&gt;Alfonso Garcia-Caro&lt;/a&gt;, one of contributors to FunScript, has decided to create new project compiling F# to JS (with &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; as middle step) called &lt;a href=&quot;http://fable.io&quot;&gt;Fable&lt;/a&gt; which hopefully will solve some of the FunScript’s problems. I have decided to investigate how this new library can be used to create VS Code plugins… using VS Code to code and compile those plugins.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Requirements&lt;/h1&gt;

&lt;p&gt;You need to have &lt;a href=&quot;http://fsharp.org/&quot;&gt;F# 4&lt;/a&gt; and &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;node.js&lt;/a&gt; installed. Node has to be included in your &lt;code&gt;$PATH&lt;/code&gt;.&lt;/p&gt;

&lt;h1&gt;Initial steps&lt;/h1&gt;

&lt;p&gt;The simplest way to start building own VS Code plugin is using &lt;a href=&quot;http://yeoman.io/&quot;&gt;Yeoman&lt;/a&gt; to scaffold plugin project. Install Yeoman and &lt;a href=&quot;https://code.visualstudio.com/docs/tools/yocode&quot;&gt;VS Code Plugin Generator&lt;/a&gt; using following commands:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install -g yo
npm install -g generator-code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Yeoman generator will walk you through the steps required to create your customization or extension prompting for the required information. To launch the generator type the following in a command prompt:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;yo code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We pick &lt;code&gt;New Extension (JavaScript)&lt;/code&gt; option, go through all questions, and let Yeoman do its magic. After process is finished we enter newly created folder.Here we have to remove some unnecessary things generated by Yeoman - &lt;code&gt;extension.js&lt;/code&gt; file, and &lt;code&gt;typing&lt;/code&gt; and &lt;code&gt;tests&lt;/code&gt; folders (who need tests anyway ;) ). We add &lt;code&gt;out/&lt;/code&gt; entry to &lt;code&gt;.gitignore&lt;/code&gt; files - all output files will be generated as part of our build process and shouldn’t be commited to GitHub. Final step is creating empty &lt;code&gt;src&lt;/code&gt; folder - it will contain our F# source files.&lt;/p&gt;

&lt;h1&gt;Installing Fable and setting project.&lt;/h1&gt;

&lt;p&gt;Installing Fable and VS Code bindings for it is easy - all things are published as npm modules. So we can just run following commands to add those tools to our project&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install --save-dev fable-compiler fable-import-vscode
npm install --save fable-core
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next step is updating our &lt;code&gt;package.json&lt;/code&gt; file to include changes we have done and to create build targets which will compile F# code to JS.First of all we update &lt;code&gt;main&lt;/code&gt; entry - it defines where is our entry file of plugin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
...  
&quot;main&quot;: &quot;./out/extension&quot;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second, we update &lt;code&gt;scripts&lt;/code&gt; part - here we define possible build targets which can be used for our project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
...
&quot;scripts&quot;: {
    &quot;build&quot;: &quot;fable src/extension.fsx --outDir ../out -s -m commonjs&quot;
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;For more details about Fable and compiler options please check &lt;a href=&quot;http://fable.io/docs/compiling.html&quot;&gt;Fable documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;build&lt;/code&gt; target runs fable compiler to generate JS from our F# file.&lt;/p&gt;

&lt;h1&gt;Writing F# Code&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;For more details about VS Code extension API please visit &lt;a href=&quot;https://code.visualstudio.com/docs/extensions/overview&quot;&gt;extension documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At last we can write some F# code. Our sample extension will be simple - it will be just Hello World.To start in &lt;code&gt;src&lt;/code&gt; folder we create F# script file called &lt;code&gt;extension.fs&lt;/code&gt;. First step is referencing Fable core library and VS Code bindings&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;#r &quot;../node_modules/fable-core/Fable.Core.dll&quot;
 
open Fable.Core
open Fable.Core.JsInterop
open Fable.Import
open Fable.Import.vscode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Entry point of any VS Code plugin is activate function placed in file defined as entry point in &lt;code&gt;package.json&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;open Fable.Import.vscode.commands.Globals

let activate (context : vscode.ExtensionContext) = 
  registerCommand(&quot;extension.sayHello&quot;, fun _ -&amp;gt;
    showInformationMessage &quot;Hello world!&quot; |&amp;gt; unbox )
  |&amp;gt; context.subscriptions.Add    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see we can use both standard F# construct like &lt;code&gt;printfn&lt;/code&gt; function (which is mapped to JS &lt;code&gt;console.log&lt;/code&gt;) and functions defined in VS Code bindings. Here we print “Hello world” to console and register command which will display Hello World information in the popup. Now from console, we can run &lt;code&gt;npm build&lt;/code&gt; and compile our F# script to JavaScript. We shall see result in &lt;code&gt;out&lt;/code&gt; directory.&lt;/p&gt;

&lt;h1&gt;Integration with VS Code&lt;/h1&gt;

&lt;p&gt;Now, when we have set up project and can compile it, we need to integrate our solution with VS Code - first we define Task to run our build script from inside editor.
In &lt;code&gt;.vscode&lt;/code&gt; folder we create &lt;code&gt;tasks.json&lt;/code&gt; file and put there:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;command&quot;: &quot;npm&quot;,
  &quot;isShellCommand&quot;: true,
  &quot;tasks&quot;: [
    {
     &quot;taskName&quot;: &quot;run&quot;,
      &quot;isBuildCommand&quot;: true,
      &quot;args&quot;: [ &quot;build&quot; ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It’s just simple task running &lt;code&gt;npm run build&lt;/code&gt; - it is defined as build command which means it can be run using &lt;code&gt;Ctrl+Shift+B&lt;/code&gt; command. Next step is setting this target as task we want to invoke before we start debugging. To do this, we open &lt;code&gt;launch.json&lt;/code&gt; file and append &lt;code&gt;&quot;preLaunchTask&quot;: &quot;run&quot;&lt;/code&gt; to &lt;code&gt;Lanunch Extension&lt;/code&gt; configuration (we can remove &lt;code&gt;Launch test&lt;/code&gt; entry, we do not need tests anyway ;) ). Pressing F5 will run our extension - we can try it out by running &lt;code&gt;Hello World&lt;/code&gt; command in Command Palette.&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post we have shortly moved all steps necessary to create VS Code extension using F# and Fable. From my short experience with this tool it looks like it is much nicer option than FunScript, hopefully I will be able to port my other extensions to it! Whole source code of this sample application is on &lt;a href=&quot;https://github.com/Krzysztof-Cieslak/vscode-fable-demo&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
                <pubDate>Mon, 21 Mar 2016 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/Creating-VS-Code-plugins-with-F-and-Fable</link>
                <guid isPermaLink="true">http://kcieslak.io/Creating-VS-Code-plugins-with-F-and-Fable</guid>
                
                <category>F#</category>
                
                <category>Fable</category>
                
                <category>VS Code</category>
                
                
            </item>
        
            <item>
                <title>Using Node.js and NPM with Paket and FAKE</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Web development is great fit for F# and Functional Programming . Libraries like &lt;a href=&quot;http://suave.io&quot;&gt;Suave&lt;/a&gt; or &lt;a href=&quot;http://docs.freya.io/en/latest/&quot;&gt;Freya&lt;/a&gt; makes it easy to create well-architectures, composable web applications. But that’s backend part of story. Nowadays most web applications are required to have lot of user interactions and logic on the front-end side - in the browser.&lt;/p&gt;

&lt;p&gt;Two important tools for front-end JavaScript development are &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt; (JS backend server, used for running many JS development tools) and &lt;a href=&quot;npmjs.com&quot;&gt;npm&lt;/a&gt; - package manager for Node.js. Those 2 tools are often installed globally on developer PC, are used to define dependencies for front-end application, and define build pipeline for it.&lt;/p&gt;

&lt;p&gt;But, using different build tools for backend and front-end development in one application can get annoying and tiresome for developer, so it would be nice to use one build pipeline for all tasks. And it is possible with Paket and FAKE.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Installing Node and npm using Paket&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;In case you haven’t heard about Paket - it is alternative dependency management tool built by F# community, supporting NuGet, GitHub and git. For more information please visit : &lt;a href=&quot;http://fsprojects.github.io/Paket/&quot;&gt;http://fsprojects.github.io/Paket/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Installing Node.js and npm using Paket is as easy as installing any .Net package - luckily there exist up-to-date NuGet packages for both tools.&lt;/p&gt;

&lt;p&gt;Installing Node:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;paket add nuget Node.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Installing npm:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;paket add nuget Npm.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tools executable are respectively &lt;code&gt;.\packages\Node.js\node.exe&lt;/code&gt; and &lt;code&gt;.\packages\Npm.js\tools\npm.cmd&lt;/code&gt;.&lt;/p&gt;

&lt;h1&gt;Using package.json file&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;package.json&lt;/code&gt; is npm file defining project, its dependencies and build scripts we can run. For more information about it, please visit &lt;a href=&quot;https://docs.npmjs.com/files/package.json&quot;&gt;npm documentation on this topic&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Package.json&lt;/code&gt; file looks as in every normal project using npm. We define our project name, repository, dependencies and we create build scripts. There is one small difference - instead of just calling &lt;code&gt;node&lt;/code&gt; or &lt;code&gt;npm&lt;/code&gt; we have to give relative installation path to those tools.&lt;/p&gt;

&lt;p&gt;Example &lt;code&gt;scripts&lt;/code&gt; section of &lt;code&gt;package.json&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;scripts&quot;: {
  &quot;build:js&quot;: &quot;packages\\Node.js\\node.exe node_modules/uglifyjs-folder/cli.js
                web/content/app/ -eo web/content/dist/&quot;,
  &quot;build&quot;: &quot;packages\\Npm.js\\tools\\npm.cmd run build:js&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Running npm scripts using FAKE&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;FAKE - F# Make - is a build automation system with capabilities which are similar to make and rake. It is using an easy domain-specific language (DSL) so that you can start using it without learning F#. For more details visit: &lt;a href=&quot;http://fsharp.github.io/FAKE/&quot;&gt;http://fsharp.github.io/FAKE/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;FAKE is fantastic build system, that allows to create complex build scripts using F#. One of its big advantage is having built-in helpers for different tools from .Net space … and not only .Net. Fortunately, there exist FAKE helper for npm.&lt;/p&gt;

&lt;p&gt;Using npm helper is as simple as creating normal FAKE target and running &lt;code&gt;Npm&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Running &lt;code&gt;npm install&lt;/code&gt; - command downloading all dependencies specified in &lt;code&gt;package.json&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;Target &quot;NpmInstall&quot; (fun _ -&amp;gt;
  Npm (fun p -&amp;gt;
        { p with
          Command = Install Standard
          WorkingDirectory = &quot;./src/FAKESimple.Web/&quot;
        })
 )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running build script defined in &lt;code&gt;package.json&lt;/code&gt; file is not different:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;Target &quot;NpmInstall&quot; (fun _ -&amp;gt;
  Npm (fun p -&amp;gt;
        { p with
          Command = (Run &quot;build&quot;)
          WorkingDirectory = &quot;./src/FAKESimple.Web/&quot;
        })
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In the post we’ve shortly moved through all steps necessery to create build pipeline combingin our known F# tools - Paket and FAKE, with JavaScript tooling used for front-end development - Node and npm. This post was based on FsSnippet web page implementation where this technique is used - for more details, and “real world” usage feel free to check &lt;a href=&quot;https://github.com/fssnippets/fssnip-website&quot;&gt;FsSnippet source code on GitHub&lt;/a&gt;&lt;/p&gt;
</description>
                <pubDate>Tue, 01 Mar 2016 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/Using-Node-with-Paket-and-Fake</link>
                <guid isPermaLink="true">http://kcieslak.io/Using-Node-with-Paket-and-Fake</guid>
                
                <category>F#</category>
                
                <category>Paket</category>
                
                <category>FAKE</category>
                
                
            </item>
        
    </channel>
</rss>