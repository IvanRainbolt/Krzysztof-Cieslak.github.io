<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>F# Reflections</title>
        <description>Blog about F# and FP Programming</description>
        <link>http://kcieslak.io/</link>
        <atom:link href="http://kcieslak.io/feed.xml" rel="self" type="application/rss+xml"/>
        <pubDate>Thu, 16 Jun 2016 22:06:21 +0200</pubDate>
        <lastBuildDate>Thu, 16 Jun 2016 22:06:21 +0200</lastBuildDate>
        <generator>Jekyll v3.1.2</generator>
        
            <item>
                <title>Getting started with Fable and Webpack</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/fsprojects/Fable&quot;&gt;Fable&lt;/a&gt; is new F# to JavaScript compiler created by &lt;a href=&quot;https://twitter.com/alfonsogcnunez&quot;&gt;Alfonso Garcia-Caro&lt;/a&gt;. In this post I’ll go, step by step, through process of creating client-side (browser) applications using it.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This post is targeted at F# developers without lot of knowladge about Node.js and JS ecosystem and it should let any F# developer to get started with Fable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Requirements&lt;/h3&gt;

&lt;p&gt;Fable requires having both &lt;a href=&quot;http://fsharp.org&quot;&gt;F# 4&lt;/a&gt; and &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;node 4.4&lt;/a&gt; or bigger installed in your computer.&lt;/p&gt;

&lt;h1&gt;Setting up project&lt;/h1&gt;

&lt;p&gt;The first thing we need to do is creating new directory and initializing node project:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir fable-test
cd fable-test
npm init
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;Npm&lt;/a&gt; is is the package manager for JavaScript. It lets users to find, share, and reuse packages of code or install additional tools&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;npm init&lt;/code&gt; will create &lt;code&gt;package.json&lt;/code&gt; file. This file is project file for any Node.js based project (both client and server side). At start it will contain only basic information about a project, something like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;name&quot;: &quot;fable-test&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;...&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Installing development tools.&lt;/h3&gt;

&lt;p&gt;Next step is installing all development dependencies (tools) which we’ll be using for our project. To do so we are using &lt;code&gt;npm install&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install --save-dev fable-compiler
npm install --save-dev webpack
npm install --save-dev source-map-loader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First line installs Fable compiler for our project. Second command installs &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt;. Webpack is a module bundler - it takes modules with dependencies and generates static assets representing those modules. In our case it would take generated by Fable files together with other JS libraries we will depend upon and create single file output which can be easily added to page. Last dependency is plugin to Webpack which will enable nice debugging story for our application (debugging F# files in the browser)&lt;/p&gt;

&lt;p&gt;It’s also worth noticing that those commands modified &lt;code&gt;package.json&lt;/code&gt; file, now it contains also following block:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;devDependencies&quot;: {
  &quot;fable-compiler&quot;: &quot;^0.2.12&quot;,
  &quot;source-map-loader&quot;: &quot;^0.1.5&quot;,
  &quot;webpack&quot;: &quot;^1.13.0&quot;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Installing dependencies&lt;/h3&gt;

&lt;p&gt;Now we will install our code dependencies using also &lt;code&gt;npm install&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install --save core-js
npm install --save fable-core
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;core-js&lt;/code&gt; is polyfill ensuring that code generated by Fable will run in any browser. &lt;code&gt;fable-core&lt;/code&gt; is standard Fable library.&lt;/p&gt;

&lt;p&gt;Those commands again modified &lt;code&gt;package.json&lt;/code&gt; file, this time adding following information:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;dependencies&quot;: {
    &quot;core-js&quot;: &quot;^2.4.0&quot;,
    &quot;fable-core&quot;: &quot;0.0.21&quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Creating F# script and HTML file&lt;/h3&gt;

&lt;p&gt;Fable supports both &lt;code&gt;fsproj&lt;/code&gt; and plain &lt;code&gt;fsx&lt;/code&gt; files. For simplicity in this example let’s use &lt;code&gt;fsx&lt;/code&gt; file. Create &lt;code&gt;source\code.fsx&lt;/code&gt; with follwing content:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;#r &quot;../node_modules/fable-core/Fable.Core.dll&quot;

open Fable.Core 
open Fable.Import
 
Node.require.Invoke(&quot;core-js&quot;) |&amp;gt; ignore

let element = Browser.document.getElementById &quot;sample&quot;
element.innerText &amp;lt;- &quot;Hello, world !!&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code should be pretty straightforward, only tricky part is &lt;code&gt;Node.require.Invoke(&quot;core-js&quot;)&lt;/code&gt; which is importing Node.js module (installed by &lt;code&gt;npm&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Let’s also create very simple HTML file &lt;code&gt;public\index.html&lt;/code&gt; ( &lt;code&gt;public&lt;/code&gt; will be our output folder):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta http-equiv=&#39;Content-Type&#39; content=&#39;text/html; charset=utf-8&#39;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div id=&#39;sample&#39;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;script src=&quot;bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Configuration&lt;/h1&gt;

&lt;p&gt;First step is creating configuration for Fable compiler. It’s done by creating &lt;code&gt;fableconfig.json&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;module&quot;: &quot;commonjs&quot;,
  &quot;sourceMaps&quot;: true,
  &quot;projFile&quot;: &quot;./src/code.fsx&quot;,
  &quot;outDir&quot;: &quot;temp&quot;,
  &quot;scripts&quot;: {
    &quot;prebuild&quot;: &quot;npm install&quot;,
    &quot;postbuild&quot;: &quot;webpack&quot;
  },
  &quot;targets&quot;: {
    &quot;watch&quot;: {
      &quot;scripts&quot;: {
        &quot;postbuild&quot;: &quot;webpack --watch&quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we define module type - in our case it’s &lt;code&gt;commonjs&lt;/code&gt; (as it’s working well with &lt;code&gt;Webpack&lt;/code&gt;). Next we define that we want to use soruce maps (it allows F# file debugging), entry point of application, and output directory for compiled JS files.
Next step is defining some small scripts which will be run before and after every build - before we want to run &lt;code&gt;npm install&lt;/code&gt; to restore all dependencies, after build we run &lt;code&gt;webpack&lt;/code&gt; to create bundled output file. Last part defines additional target which will be executed in &lt;code&gt;watch&lt;/code&gt; mode. In such case we want to run &lt;code&gt;webpack&lt;/code&gt; also in &lt;code&gt;watch&lt;/code&gt; mode.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;watch&lt;/code&gt; mode will make Fable and Webpack to recompile project after every file save without need to execute any additional commands.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Webpack configuration&lt;/h3&gt;

&lt;p&gt;Second step is to create &lt;code&gt;webpack&lt;/code&gt; configuration. Let’s create &lt;code&gt;webpack.config.js&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var path = require(&quot;path&quot;);
var webpack = require(&quot;webpack&quot;);

var cfg = {
  devtool: &quot;source-map&quot;,
  entry: &quot;./temp/code.js&quot;,
  output: {
    path: path.join(__dirname, &quot;public&quot;),
    filename: &quot;bundle.js&quot;
  },
  module: {
    preLoaders: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: &quot;source-map-loader&quot;
      }
    ]
  }
};

module.exports = cfg;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this file we define that we want to use source maps, entry point for webpack ( so file generated by Fable), output path, and usage of any additional plugins (in our case it will be &lt;code&gt;source-map-loader&lt;/code&gt; installed before)&lt;/p&gt;

&lt;h3&gt;Npm scripts&lt;/h3&gt;

&lt;p&gt;Easiest way to run tools installed by &lt;code&gt;npm&lt;/code&gt; is by using scripts section in &lt;code&gt;packages.json&lt;/code&gt; file. Let’s put there following scripts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;scripts&quot;: {
  &quot;build&quot;: &quot;fable&quot;,
  &quot;watch&quot;: &quot;fable -w --target watch&quot;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;build&lt;/code&gt; just starts Fable. &lt;code&gt;watch&lt;/code&gt;, as name suggests, starts Fable in &lt;code&gt;watch&lt;/code&gt; mode, so code is regenerated every time we save F# file. We can run those scripts using &lt;code&gt;npm run &amp;lt;script_name&amp;gt;&lt;/code&gt; command.&lt;/p&gt;

&lt;h3&gt;VSCode configuration&lt;/h3&gt;

&lt;p&gt;Last, optional step is creating &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VSCode&lt;/a&gt; configuration. It’s fairly easy since editor has decent integration with &lt;code&gt;npm&lt;/code&gt;. All we need to do is create &lt;code&gt;.vscode\tasks.json&lt;/code&gt; file and put there following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;command&quot;: &quot;npm&quot;,
  &quot;isShellCommand&quot;: true,
  &quot;showOutput&quot;: &quot;always&quot;,
  &quot;suppressTaskName&quot;: true,
  &quot;tasks&quot;: [
    {
      &quot;taskName&quot;: &quot;install&quot;,
      &quot;args&quot;: [&quot;install&quot;]
    },
    {
      &quot;taskName&quot;: &quot;build&quot;,
      &quot;args&quot;: [&quot;run&quot;, &quot;build&quot;],
      &quot;isBuildCommand&quot;: true
    },
    {
      &quot;taskName&quot;: &quot;watch&quot;,
      &quot;args&quot;: [&quot;run&quot;, &quot;watch&quot;],
      &quot;isWatching&quot;: true
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we define that our tasks are using &lt;code&gt;npm&lt;/code&gt; and we define arguments send to &lt;code&gt;npm&lt;/code&gt; with every task. 
We can run those task usign &lt;code&gt;Tasks: Run Task&lt;/code&gt; command (&lt;code&gt;build&lt;/code&gt; task can be also run using &lt;code&gt;Tasks: Run Build Command&lt;/code&gt; command or &lt;code&gt;Ctrl + Shift + B&lt;/code&gt;)&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post we have shortly moved all steps necessary to create browser, client-side applications using F#, Fable and Webpack. Whole source code of this sample application is on GitHub - https://github.com/Krzysztof-Cieslak/fable-webpack-demo&lt;/p&gt;
</description>
                <pubDate>Mon, 16 May 2016 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Getting-Started-with-Fable-and-Webpack</link>
                <guid isPermaLink="true">http://kcieslak.io/Getting-Started-with-Fable-and-Webpack</guid>
                
                <category>F#</category>
                
                <category>Fable</category>
                
                <category>VSCode</category>
                
                <category>Webpack</category>
                
                <category>JS</category>
                
                
            </item>
        
            <item>
                <title>Creating VS Code plugins with F# and Fable</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;EDIT 22.03.2016&lt;/em&gt; Thanks to Alfonso’s help I was able to remove postbuild step fixing JS.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VS Code&lt;/a&gt; is new text editor (or rather lightweight IDE) created by Microsoft. Because it is product based on &lt;a href=&quot;http://electron.atom.io/&quot;&gt;Electron&lt;/a&gt; - cross platform engine allowing developers to write desktop applications using web technologies - its plugin system supports JavaScript (and TypeScript). Unfortunately both those languages are not nice choice for someone using statically typed functional programming languages like F#. Up to this moment in my VS Code extensions I was using F# library called &lt;a href=&quot;http://funscript.info/&quot;&gt;FunScript&lt;/a&gt; which compiles F# code to JavaScript. Whereas it sounds nice, library has some problems which makes writing code using it not nice experience. Fortunately recently, &lt;a href=&quot;https://twitter.com/alfonsogcnunez&quot;&gt;Alfonso Garcia-Caro&lt;/a&gt;, one of contributors to FunScript, has decided to create new project compiling F# to JS (with &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; as middle step) called &lt;a href=&quot;https://github.com/fsprojects/Fable&quot;&gt;Fable&lt;/a&gt; which hopefully will solve some of the FunScript’s problems. I have decided to investigate how this new library can be used to create VS Code plugins… using VS Code to code and compile those plugins.&lt;/p&gt;

&lt;h1&gt;Requirements&lt;/h1&gt;

&lt;p&gt;You need to have &lt;a href=&quot;http://fsharp.org/&quot;&gt;F# 4&lt;/a&gt; and &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;node.js&lt;/a&gt; installed. Node has to be included in your &lt;code&gt;$PATH&lt;/code&gt;.&lt;/p&gt;

&lt;h1&gt;Initial steps&lt;/h1&gt;

&lt;p&gt;The simplest way to start building own VS Code plugin is using &lt;a href=&quot;http://yeoman.io/&quot;&gt;Yeoman&lt;/a&gt; to scaffold plugin project. Install Yeoman and &lt;a href=&quot;https://code.visualstudio.com/docs/tools/yocode&quot;&gt;VS Code Plugin Generator&lt;/a&gt; using following commands:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install -g yo
npm install -g generator-code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Yeoman generator will walk you through the steps required to create your customization or extension prompting for the required information. To launch the generator type the following in a command prompt:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;yo code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We pick &lt;code&gt;New Extension (JavaScript)&lt;/code&gt; option, go through all questions, and let Yeoman do its magic. After process is finished we enter newly created folder.Here we have to remove some unnecessary things generated by Yeoman - &lt;code&gt;extension.js&lt;/code&gt; file, and &lt;code&gt;typing&lt;/code&gt; and &lt;code&gt;tests&lt;/code&gt; folders (who need tests anyway ;) ). We add &lt;code&gt;out/&lt;/code&gt; entry to &lt;code&gt;.gitignore&lt;/code&gt; files - all output files will be generated as part of our build process and shouldn’t be commited to GitHub. Final step is creating empty &lt;code&gt;src&lt;/code&gt; folder - it will contain our F# source files.&lt;/p&gt;

&lt;h1&gt;Installing Fable and setting project.&lt;/h1&gt;

&lt;p&gt;Installing Fable and VS Code bindings for it is easy - all things are published as npm modules. So we can just run following commands to add those tools to our project&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install --save-dev fable-compiler
npm install --save-dev fable-import fable-import-vscode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next step is updating our &lt;code&gt;package.json&lt;/code&gt; file to include changes we have done and to create build targets which will compile F# code to JS.First of all we update &lt;code&gt;main&lt;/code&gt; entry - it defines where is our entry file of plugin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
...  
&quot;main&quot;: &quot;./out/extension&quot;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second, we update &lt;code&gt;scripts&lt;/code&gt; part - here we define possible build targets which can be used for our project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
...
&quot;scripts&quot;: {
    &quot;build&quot;: &quot;fable src/extension.fsx --outDir ../out -m --env node&quot;
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;For more details about Fabel and compiler options please visit &lt;a href=&quot;https://github.com/fsprojects/Fable&quot;&gt;Fable on GitHub&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;build&lt;/code&gt; target runs fable compiler to generate JS from our F# file.&lt;/p&gt;

&lt;h1&gt;Writing F# Code&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;For more details about VS Code extension API please visit &lt;a href=&quot;https://code.visualstudio.com/docs/extensions/overview&quot;&gt;extension documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At last we can write some F# code. Our sample extension will be simple - it will be just Hello World.To start in &lt;code&gt;src&lt;/code&gt; folder we create F# script file called &lt;code&gt;extension.fs&lt;/code&gt;. First step is referencing Fable core library and VS Code bindings&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;#r &quot;../node_modules/fable-import/Fable.Import.dll&quot;
#load &quot;../node_modules/fable-import-vscode/Fable.Import.VSCode.fs&quot;
 
open Fable.Core
open Fable.Import
open Fable.Import.vscode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Entry point of any VS Code plugin is activate function placed in file defined as entry point in &lt;code&gt;package.json&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;open Fable.Import.vscode.commands.Globals

let activate (context : vscode.ExtensionContext) = 
  registerCommand(&quot;extension.sayHello&quot;, fun _ -&amp;gt;
    showInformationMessage &quot;Hello world!&quot; |&amp;gt; unbox )
  |&amp;gt; context.subscriptions.Add    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see we can use both standard F# construct like &lt;code&gt;printfn&lt;/code&gt; function (which is mapped to JS &lt;code&gt;console.log&lt;/code&gt;) and functions defined in VS Code bindings. Here we print “Hello world” to console and register command which will display Hello World information in the popup. Now from console, we can run &lt;code&gt;npm build&lt;/code&gt; and compile our F# script to JavaScript. We shall see result in &lt;code&gt;out&lt;/code&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;Node.Globals.exports?activate &amp;lt;- activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last step is adding &lt;code&gt;activate&lt;/code&gt; to &lt;code&gt;exports&lt;/code&gt; object using Fable dynamic operator (&lt;code&gt;?&lt;/code&gt;)&lt;/p&gt;

&lt;h1&gt;Integration with VS Code&lt;/h1&gt;

&lt;p&gt;Now, when we have set up project and can compile it, we need to integrate our solution with VS Code - first we define Task to run our build script from inside editor.
In &lt;code&gt;.vscode&lt;/code&gt; folder we create &lt;code&gt;tasks.json&lt;/code&gt; file and put there:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;command&quot;: &quot;npm&quot;,
  &quot;isShellCommand&quot;: true,
  &quot;tasks&quot;: [
    {
     &quot;taskName&quot;: &quot;run&quot;,
      &quot;isBuildCommand&quot;: true,
      &quot;args&quot;: [ &quot;build&quot; ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It’s just simple task running &lt;code&gt;npm run build&lt;/code&gt; - it is defined as build command which means it can be run using &lt;code&gt;Ctrl+Shift+B&lt;/code&gt; command. Next step is setting this target as task we want to invoke before we start debugging. To do this, we open &lt;code&gt;launch.json&lt;/code&gt; file and append &lt;code&gt;&quot;preLaunchTask&quot;: &quot;run&quot;&lt;/code&gt; to &lt;code&gt;Lanunch Extension&lt;/code&gt; configuration (we can remove &lt;code&gt;Launch test&lt;/code&gt; entry, we do not need tests anyway ;) ). Pressing F5 will run our extension - we can try it out by running &lt;code&gt;Hello World&lt;/code&gt; command in Command Palette.&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post we have shortly moved all steps necessary to create VS Code extension using F# and Fable. From my short experience with this tool it looks like it is much nicer option than FunScript, hopefully I will be able to port my other extensions to it! Whole source code of this sample application is on &lt;a href=&quot;https://github.com/Krzysztof-Cieslak/vscode-fable-demo&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
                <pubDate>Mon, 21 Mar 2016 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/Creating-VS-Code-plugins-with-F-and-Fable</link>
                <guid isPermaLink="true">http://kcieslak.io/Creating-VS-Code-plugins-with-F-and-Fable</guid>
                
                <category>F#</category>
                
                <category>Fable</category>
                
                <category>VSCode</category>
                
                <category>VS Code</category>
                
                
            </item>
        
            <item>
                <title>Using Node.js and NPM with Paket and FAKE</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Web development is great fit for F# and Functional Programming . Libraries like &lt;a href=&quot;http://suave.io&quot;&gt;Suave&lt;/a&gt; or &lt;a href=&quot;http://docs.freya.io/en/latest/&quot;&gt;Freya&lt;/a&gt; makes it easy to create well-architectures, composable web applications. But that’s backend part of story. Nowadays most web applications are required to have lot of user interactions and logic on the front-end side - in the browser.&lt;/p&gt;

&lt;p&gt;Two important tools for front-end JavaScript development are &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt; (JS backend server, used for running many JS development tools) and &lt;a href=&quot;npmjs.com&quot;&gt;npm&lt;/a&gt; - package manager for Node.js. Those 2 tools are often installed globally on developer PC, are used to define dependencies for front-end application, and define build pipeline for it.&lt;/p&gt;

&lt;p&gt;But, using different build tools for backend and front-end development in one application can get annoying and tiresome for developer, so it would be nice to use one build pipeline for all tasks. And it is possible with Paket and FAKE.&lt;/p&gt;

&lt;h1&gt;Installing Node and npm using Paket&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;In case you haven’t heard about Paket - it is alternative dependency management tool built by F# community, supporting NuGet, GitHub and git. For more information please visit : &lt;a href=&quot;http://fsprojects.github.io/Paket/&quot;&gt;http://fsprojects.github.io/Paket/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Installing Node.js and npm using Paket is as easy as installing any .Net package - luckily there exist up-to-date NuGet packages for both tools.&lt;/p&gt;

&lt;p&gt;Installing Node:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;paket add nuget Node.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Installing npm:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;paket add nuget Npm.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tools executable are respectively &lt;code&gt;.\packages\Node.js\node.exe&lt;/code&gt; and &lt;code&gt;.\packages\Npm.js\tools\npm.cmd&lt;/code&gt;.&lt;/p&gt;

&lt;h1&gt;Using package.json file&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;package.json&lt;/code&gt; is npm file defining project, its dependencies and build scripts we can run. For more information about it, please visit &lt;a href=&quot;https://docs.npmjs.com/files/package.json&quot;&gt;npm documentation on this topic&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Package.json&lt;/code&gt; file looks as in every normal project using npm. We define our project name, repository, dependencies and we create build scripts. There is one small difference - instead of just calling &lt;code&gt;node&lt;/code&gt; or &lt;code&gt;npm&lt;/code&gt; we have to give relative installation path to those tools.&lt;/p&gt;

&lt;p&gt;Example &lt;code&gt;scripts&lt;/code&gt; section of &lt;code&gt;package.json&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;scripts&quot;: {
  &quot;build:js&quot;: &quot;packages\\Node.js\\node.exe node_modules/uglifyjs-folder/cli.js
                web/content/app/ -eo web/content/dist/&quot;,
  &quot;build&quot;: &quot;packages\\Npm.js\\tools\\npm.cmd run build:js&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Running npm scripts using FAKE&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;FAKE - F# Make - is a build automation system with capabilities which are similar to make and rake. It is using an easy domain-specific language (DSL) so that you can start using it without learning F#. For more details visit: &lt;a href=&quot;http://fsharp.github.io/FAKE/&quot;&gt;http://fsharp.github.io/FAKE/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;FAKE is fantastic build system, that allows to create complex build scripts using F#. One of its big advantage is having built-in helpers for different tools from .Net space … and not only .Net. Fortunately, there exist FAKE helper for npm.&lt;/p&gt;

&lt;p&gt;Using npm helper is as simple as creating normal FAKE target and running &lt;code&gt;Npm&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Running &lt;code&gt;npm install&lt;/code&gt; - command downloading all dependencies specified in &lt;code&gt;package.json&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;Target &quot;NpmInstall&quot; (fun _ -&amp;gt;
  Npm (fun p -&amp;gt;
        { p with
          Command = Install Standard
          WorkingDirectory = &quot;./src/FAKESimple.Web/&quot;
        })
 )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running build script defined in &lt;code&gt;package.json&lt;/code&gt; file is not different:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;Target &quot;NpmInstall&quot; (fun _ -&amp;gt;
  Npm (fun p -&amp;gt;
        { p with
          Command = (Run &quot;build&quot;)
          WorkingDirectory = &quot;./src/FAKESimple.Web/&quot;
        })
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In the post we’ve shortly moved through all steps necessery to create build pipeline combingin our known F# tools - Paket and FAKE, with JavaScript tooling used for front-end development - Node and npm. This post was based on FsSnippet web page implementation where this technique is used - for more details, and “real world” usage feel free to check &lt;a href=&quot;https://github.com/fssnippets/fssnip-website&quot;&gt;FsSnippet source code on GitHub&lt;/a&gt;&lt;/p&gt;
</description>
                <pubDate>Tue, 01 Mar 2016 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/Using-Node-with-Paket-and-Fake</link>
                <guid isPermaLink="true">http://kcieslak.io/Using-Node-with-Paket-and-Fake</guid>
                
                <category>F#</category>
                
                <category>Paket</category>
                
                <category>FAKE</category>
                
                
            </item>
        
    </channel>
</rss>