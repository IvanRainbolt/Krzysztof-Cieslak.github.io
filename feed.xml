<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>F# Reflections</title>
        <description>Blog about F# and FP Programming</description>
        <link>http://kcieslak.io/</link>
        <atom:link href="http://kcieslak.io/feed.xml" rel="self" type="application/rss+xml"/>
        <pubDate>Mon, 03 Oct 2016 22:56:49 +0200</pubDate>
        <lastBuildDate>Mon, 03 Oct 2016 22:56:49 +0200</lastBuildDate>
        <generator>Jekyll v3.1.2</generator>
        
            <item>
                <title>Dynamically extending F# applications</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Changing requirements, introducing different data format, extending applications with new features. All those things requires us (developers) to go to code, do changes, add API versioning system (to be backward compatible), add configuration for turning on/off new features, compile application, and at the end release new application (what itself may be complex process). It’s often lot of work required for every, even very small, change.&lt;/p&gt;

&lt;p&gt;In this post I’ll present way to add new features to our F# application - dynamically, on runtime, without any recompiling and redeployment of application. What’s more extensions will be also defined using F#… in fact they will be simple F# script files.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Sample application&lt;/h1&gt;

&lt;p&gt;Our sample application for this blog post will be rather simple - it will be F# console application, taking user input as string, performing set of transformations on this input and just printing out result. Transformation for our input will be dynamically loaded on runtime - initially, before user add any plugins, application just returns same value as user typed in.&lt;/p&gt;

&lt;p&gt;We can simply define our transformation as &lt;code&gt;type Transformation = string -&amp;gt; string&lt;/code&gt; and operation we perform on input as &lt;code&gt;let output = lstOfTransformations |&amp;gt; List.fold (fun state transform -&amp;gt; transform state ) input&lt;/code&gt;.&lt;/p&gt;

&lt;h1&gt;Evaluating plugins files&lt;/h1&gt;

&lt;p&gt;As I’ve mentioned our aim is to define extensions as simple F# script files. But while we can easily read text put in &lt;code&gt;.fsx&lt;/code&gt; file, F# doesn’t have anything like JavaScript’s &lt;code&gt;eval()&lt;/code&gt; function built-in, no way to take text containing code and evaluating its value. But this is a moment where &lt;code&gt;FSharp.Compiler.Services&lt;/code&gt; enters the scene. FCS (not to confuse with FSC which is F# compiler) is fork of F# compiler that exposes additional functionality for implementing F# editor features, and additional tools based on the compiler. It also includes F# interactive service that can be used for embedding F# scripting into your applications.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you want learn more about &lt;code&gt;FSharp.Compiler.Services&lt;/code&gt; visit &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/&quot;&gt;FCS webpage&lt;/a&gt; to see documentation of available features, APIs, and list of projects using FCS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For our purpose we need two things - first we’ll create embedded in our application F# Interactive session, and then we will use it to load file with plugin and evaluate it.&lt;/p&gt;

&lt;p&gt;Creating FSI session is pretty straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;open Microsoft.FSharp.Compiler.Interactive.Shell

let sbOut = StringBuilder()
let sbErr = StringBuilder()

let fsi =
    let inStream = new StringReader(&quot;&quot;)
    let outStream = new StringWriter(sbOut)
    let errStream = new StringWriter(sbErr)
    let fsiConfig = FsiEvaluationSession.GetDefaultConfiguration()
    let argv = [| &quot;/temo/fsi.exe&quot;; |]
    FsiEvaluationSession.Create(fsiConfig, argv, inStream, outStream, errStream)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we can use FSI session to load file with extension and evaluate it’s content.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt; let evaluate path =
    let mdl = getOpen path
    let load = getLoad path

    fsi.EvalInteractionNonThrowing(sprintf &quot;#load \&quot;%s\&quot;;;&quot; load)
    fsi.EvalInteractionNonThrowing(sprintf &quot;open %s;;&quot; mdl)
    fsi.EvalExpressionNonThrowing &quot;map&quot;

    match res with
    | Choice1Of2 (Some f) -&amp;gt;
        f.ReflectionValue :?&amp;gt; Transformation |&amp;gt; Some
    | _ -&amp;gt; None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we find full path to file we want to load, and name of default module for this file (it’s name of the file with first character uppercase).&lt;/p&gt;

&lt;p&gt;We execute in FSI &lt;code&gt;#load&lt;/code&gt; statement to load content of extension file, and then we open default module. Last operation is executing &lt;code&gt;map&lt;/code&gt; in FSI which will return value of this expression (so function).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For sake of simplicity in sample, we make several assumptions about extensions files - we don’t define modules inside of &lt;code&gt;.fsx&lt;/code&gt; files and they contain only single function  &lt;code&gt;map : string -&amp;gt; string&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If everything is working we can now load F# script file and get from it normal F# function which we can execute somewhere else in our code!&lt;/p&gt;

&lt;h1&gt;Loading plugins on runtime&lt;/h1&gt;

&lt;p&gt;Next important feature of our application is dynamically loading (and unloading) scripts when users creates (or removes) them. For this we will use built-in .Net FileSystemWatcher class which let developer to perform operations whenever new file is created, file is removed etc. in given directory.&lt;/p&gt;

&lt;p&gt;We just create really simple functions which takes 2 functions (one executed when file is added, second one when file is removed) and directory to watch for changes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;let create addCb rmCb dir =
    if Directory.Exists dir |&amp;gt; not then Directory.CreateDirectory dir |&amp;gt; ignore

    let watcher = new FileSystemWatcher()
    watcher.Filter &amp;lt;- &quot;*.fsx&quot;
    watcher.Path &amp;lt;- dir
    watcher.Created.Add (fun n -&amp;gt; n.FullPath |&amp;gt; addCb)
    watcher.Deleted.Add (fun n -&amp;gt; n.FullPath |&amp;gt; rmCb)
    watcher.Renamed.Add (fun n -&amp;gt; n.OldFullPath |&amp;gt; rmCb; n.FullPath |&amp;gt; addCb)
    watcher.Changed.Add (fun n -&amp;gt; n.FullPath |&amp;gt; rmCb; n.FullPath |&amp;gt; addCb)
    watcher.SynchronizingObject &amp;lt;- null
    watcher.EnableRaisingEvents &amp;lt;- true

    watcher
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Plugins register&lt;/h1&gt;

&lt;p&gt;The last important part is storing list of the transformations in memory when application is running. Since FileWatcher is running asynchronously in background of our applications we are afraid of any potential race conditions so we won’t use any global mutable state to do so. Instead we will encapsulate state of our application in agent.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;To learn more about F# Agents visit Scott Wlaschin’s &lt;a href=&quot;https://fsharpforfunandprofit.com/posts/concurrency-actor-model/&quot;&gt;post about them&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;type private Msg =
    | Add of string * Transformation
    | Remove of string
    | Get of AsyncReplyChannel&amp;lt;Transformation list&amp;gt;

let private register =
    MailboxProcessor.Start (fun inbox -&amp;gt;
        let rec loop lst = async {
            let! msg = inbox.Receive()
            match msg with
            | Add (n,f) -&amp;gt;
                return! loop ((n,f)::lst)
            | Remove n -&amp;gt;
                return! loop (lst |&amp;gt; List.filter(fun (f,_) -&amp;gt; f &amp;lt;&amp;gt; n))
            | Get rc -&amp;gt;
                let l = lst |&amp;gt; List.map snd
                rc.Reply l
                return! loop lst
        }
        loop [] )

let add name fnc =
    (name, fnc) |&amp;gt; Add |&amp;gt; register.Post

let remove name =
    name |&amp;gt; Remove |&amp;gt; register.Post

let get () =
    register.PostAndReply Get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our agent can perform 3 operations - add transformation, remove it, or return list of all transformations.&lt;/p&gt;

&lt;h1&gt;Putting things together&lt;/h1&gt;

&lt;p&gt;The last step is putting whole application together:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;EntryPoint&amp;gt;]
let main argv =
    let remove path =
        let fn = Path.GetFileNameWithoutExtension path
        Register.remove fn

    let add path =
        let fn = Path.GetFileNameWithoutExtension path
        match Evaluator.evaluate path |&amp;gt; Option.map (fun ev -&amp;gt; Register.add fn ev ) with
        | Some _ -&amp;gt; ()
        | None -&amp;gt; printfn &quot;File `%s` couldn&#39;t be parsed&quot; path

    let watcher = Watcher.create add remove &quot;scripts&quot;

    while true do
        let input = System.Console.ReadLine ()
        let lst = Register.get ()
        let res = lst |&amp;gt; List.fold (fun s e -&amp;gt; e s ) input
        printfn &quot;Result: %s&quot; res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we define callbacks for file watcher - on file remove we just send message to extensions register to remove it, when file is added we try to evaluate it and if it was successful we send message to agent to add it to list.&lt;/p&gt;

&lt;p&gt;Then we create watcher using those 2 functions watching &lt;code&gt;scripts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;Last step is loop which waits for user input, gets all transformations, apply them to input, and print out result at the end. Here is small demo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/gifs/FunctionLoader.gif&quot; alt=&quot;Function Loader demo&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post I’ve shown how to use &lt;code&gt;FSharp.Compiler.Services&lt;/code&gt; to add dynamic extensibility mechanism to F# applications. Sample presented in this blog post was really simple, but I believe that this technique can be also used for more complex, real world applications (hopefully, I’ll be able to create some more complex project using this method soon ;) ). Full code for sample application can be found on &lt;a href=&quot;https://gitlab.com/Krzysztof-Cieslak/FunctionLoader&quot;&gt;GitLab (!)&lt;/a&gt;&lt;/p&gt;
</description>
                <pubDate>Mon, 03 Oct 2016 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Dynamically-extending-F-applications</link>
                <guid isPermaLink="true">http://kcieslak.io/Dynamically-extending-F-applications</guid>
                
                <category>F#</category>
                
                <category>FSharp.Compiler.Services</category>
                
                
            </item>
        
            <item>
                <title>Working with F# projects in VSCode</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, OS X and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages (C++, C#, Python, PHP) and runtimes. The F# support for VSCode is provided by &lt;a href=&quot;http://ionide.io&quot;&gt;Ionide&lt;/a&gt; - set of extensions adding F# support, as well as Paket and FAKE.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you’re new VSCode user installing extensions is pretty easy - press extensions button on left panel, search for Ionide, press install for all Ionide extensions, wait untill all are installed and restart VSCode.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ionide-FSharp provides wide set of features useful for F# developer - from simple autocomplete and tooltips, through F# Interactive integration, to navigating to symbols or finding all usages of symbol.&lt;/p&gt;

&lt;p&gt;It also comes with decent support for F# projects (defined using &lt;code&gt;.fsproj&lt;/code&gt; file).&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Working with existing projects&lt;/h1&gt;

&lt;p&gt;Working with existing projects (created using Visual Studio or other IDE) should be pretty straightforward - opening root of your repository / solution will start Ionide. Plugin should find all project files in repository and parse them.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Warning - this process can take some time, especially on huge solutions. You can still edit files without any problem, but it make take a while before are features are started - the priority is put on providing features like tooltips, autocomplete or error highlighting for currently opened files. Solution level features (finding all errors in solution, navigating to any symbol in solution, rename, etc ) take bit longer to start.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;Creating new projects&lt;/h1&gt;

&lt;p&gt;Ionide thanks to &lt;a href=&quot;https://github.com/fsprojects/Forge&quot;&gt;Forge&lt;/a&gt; integration provides ability to create new F# projects without using full IDE. Creating new project is as simple as running &lt;code&gt;F#: New Project&lt;/code&gt; command.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;All VSCode commands can be run using command palette, it can be started using &lt;code&gt;Ctrl(Cmd)+Shift+P&lt;/code&gt; keybord shortcut.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ionide will ask about project name, directory where place new project, and project template. Currently there are about 15 different project templates, hopefully more will come in the future thanks to Community contributions to Forge.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Warning - even if you just create new project, you should have VS Code open in empty directory. It does not create “solution” directory, and assumes that is run from repository root.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Creating new project will also initialize Paket and FAKE, and create sample build script in repository root. This won’t happen if you’re just adding new project to existing solution with Paket and FAKE.&lt;/p&gt;

&lt;h1&gt;Handling files in project&lt;/h1&gt;

&lt;p&gt;As you probably know, &lt;code&gt;fsproj&lt;/code&gt; files contain list of F# (&lt;code&gt;.fs&lt;/code&gt;) files which will be compiled during build process. What’s important is that ordering of those files matters… and it’s huge F# feature. But this topic was already covered in amazing &lt;a href=&quot;https://fsharpforfunandprofit.com/series/dependency-cycles.html&quot;&gt;Scott Wlaschin’s blog&lt;/a&gt;. So, back to the topic.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Warning - Forge tends to do some additional changes to project file, so for first few times (unless you’re already comfortable with usual Forge changes) I recommend doing git commit before running Forge commands - it will make easier for you to check what changes Forge makes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are few commands which makes handling files easier. First of all, you can add or remove currently open file from project using &lt;code&gt;F#: Add Current File To Project&lt;/code&gt; and &lt;code&gt;F#: Remove Current File To Project&lt;/code&gt;. Forge will try to find appropriate project file and add or remove file there.&lt;/p&gt;

&lt;p&gt;Another important operation is file ordering - to control it &lt;code&gt;F#: Move File Up&lt;/code&gt; and &lt;code&gt;F#: Move File Down&lt;/code&gt; commands exist.&lt;/p&gt;

&lt;h1&gt;Handling references&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;fsproj&lt;/code&gt; files contain also list of used references. Generally there are 3 types of those - external references from NuGet (this type is handled by Paket), project references and GAC references. To handle 2 later cases Ionide provides two commands.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;F#: Add Project Reference&lt;/code&gt; command will ask you which project you want to edit (there will be list of all projects found in current workspace), and after which project you want to reference. For GAC references Ionide provides &lt;code&gt;F#: Add Reference&lt;/code&gt; command which works in very similar way.&lt;/p&gt;

&lt;h1&gt;Solution-wide editor features&lt;/h1&gt;

&lt;p&gt;Ionide’s editor features are probably good topic for another post, but let’s quickly go through some features which works on solution level:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;On file save, Ionide parse all projects and find all error in solution. They can be viewed in error panel (&lt;code&gt;Ctrl(Cmd) + Shift + M&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Go-to-Definition (&lt;code&gt;F12&lt;/code&gt;), Find all references (&lt;code&gt;Shift+F12&lt;/code&gt;), Peek definition (&lt;code&gt;Alt + F12&lt;/code&gt;) works across all projects in solution&lt;/li&gt;
  &lt;li&gt;Rename (&lt;code&gt;F2&lt;/code&gt;) works across all projects in solution&lt;/li&gt;
  &lt;li&gt;Same for navigating to symbol (&lt;code&gt;Ctrl(Cmd)+T&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post, I’ve presented some Ionide’s features which makes supporting and handling F# projects in Visual Studio Code. There are still not as many project editing features as in Visual Studio or Xamarin Studio, but I belive that it’s good start point, and nice set of features for lightweight editor.&lt;/p&gt;
</description>
                <pubDate>Wed, 27 Jul 2016 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Working-with-F-Projects-In-VSCode</link>
                <guid isPermaLink="true">http://kcieslak.io/Working-with-F-Projects-In-VSCode</guid>
                
                <category>F#</category>
                
                <category>VS Code</category>
                
                <category>Tooling</category>
                
                
            </item>
        
            <item>
                <title>Creating custom project file for F#</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Let’s imagine a world where F# is independent language, with cross-platform tooling making life of every F# developer easier. In this world, after we’ve fixed dependency management problem with Paket, we could go one step further… and fix project file format and building. We would use same principles as Paket - very simple, human readable, file format which can be edited without any other tooling, and command line tool responsible for building such project.&lt;/p&gt;

&lt;p&gt;In such world I’ve decided to create new open-source project called &lt;code&gt;Chris&lt;/code&gt;&lt;/p&gt;

&lt;h1&gt;File format&lt;/h1&gt;

&lt;p&gt;For our hypothetical project file (called &lt;code&gt;project.chris&lt;/code&gt;) I’ve decided to use &lt;code&gt;toml&lt;/code&gt;. In this very simple file we would just specify few properties, files of our project, GAC references and external NuGet packages. It would look like as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[Info]
Name = &quot;Fancy_Test_Project&quot;
Author = &quot;Lambda Factory&quot;
Git = &quot;&quot;

[Stuff]
References = [&quot;mscorlib&quot;, &quot;System&quot;, &quot;System.Core&quot;, &quot;System.Numerics&quot;]
Files = [&quot;Message.fs&quot;, &quot;Test.fs&quot;]
Packages = []
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;

&lt;h1&gt;Build&lt;/h1&gt;

&lt;p&gt;Most important feature of every project system is ability to build project to executable version. As I’ve mentioned earlier one of the important points I’d like to address is ability to build project with command line with very simple commands. To build any F# project, in the end - no matter which project system we use, we have to execute F# Compiler with &lt;a href=&quot;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/compiler-options-%5bfsharp%5d&quot;&gt;appropriate arguments&lt;/a&gt; (defining references, different build options, and source files).&lt;/p&gt;

&lt;p&gt;In this case I’ve created really simple console application which user runs in project directory and it builds project, and produce &lt;code&gt;.exe&lt;/code&gt; file. To parse &lt;code&gt;toml&lt;/code&gt; I’ve decided to use &lt;a href=&quot;https://github.com/paiden/Nett&quot;&gt;Nett library&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First step is defining model representing our project, what is rather straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;type Info = {
    Name : string
    Author : string
    Git : string
}

type Stuff = {
    Files : string []
    References : string []
    Packages : string []
}

type Project = {
    Info : Info
    Stuff : Stuff
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next step is creating 2 helper functions - one loading &lt;code&gt;project.chris&lt;/code&gt; and parsing it to our model, second one transforming this model to right F# Compiler arguments. Again, nothing complex.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;let load (path : string) =
    let tmp = Toml.ReadFile path
    let info = tmp.Get&amp;lt;TomlTable&amp;gt; &quot;Info&quot;
    let stuff = tmp.Get&amp;lt;TomlTable&amp;gt; &quot;Stuff&quot;
    {
        Info = {
                Name = info.Get&amp;lt;string&amp;gt;(&quot;Name&quot;)
                Author = info.Get&amp;lt;string&amp;gt;(&quot;Author&quot;)
                Git = info.Get&amp;lt;string&amp;gt;(&quot;Git&quot;) }
        Stuff = {
                Files = stuff.Get&amp;lt;string []&amp;gt;(&quot;Files&quot;)
                References = stuff.Get&amp;lt;string []&amp;gt;(&quot;References&quot;)
                Packages = stuff.Get&amp;lt;string []&amp;gt;(&quot;Packages&quot;) }
    }, path

let toFSCParams (project, path) =
    let folder = Path.GetDirectoryName path
    let output = sprintf &quot;%s.exe&quot; project.Info.Name
    [|
        yield &quot;-out:&quot; + output
        yield @&quot;-r:C:\Program Files (x86)\Reference Assemblies\Microsoft\FSharp\.NETFramework\v4.0\4.3.1.0\FSharp.Core.dll&quot;
        for r in project.Stuff.References do
            yield sprintf @&quot;-r:C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5\%s.dll&quot; r

        yield &quot;--noframework&quot;
        for f in project.Stuff.Files do
            yield  Path.Combine (folder, f)
    |]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last step is creating function which runs F# Compiler. To do so we will use &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/&quot;&gt;FSharp.Compiler.Service&lt;/a&gt; - .Net library that exposes functionality for implementing F# language bindings, additional tools based on the compiler or refactoring tools. What’s most important in this case it also let’s &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/compiler.html&quot;&gt;host F# compiler inside other application&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;open Microsoft.FSharp.Compiler
open Microsoft.FSharp.Compiler.SourceCodeServices
open Microsoft.FSharp.Compiler.SimpleSourceCodeServices

let build (project,path) =
    let scs = SimpleSourceCodeServices()
    let parm =  (project, path) |&amp;gt; toFSCParams
    parm |&amp;gt; scs.Compile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And at the end we pipe it together:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;[&amp;lt;EntryPoint&amp;gt;]
let main argv =
    let errors, exit =
        &quot;project.chris&quot;
        |&amp;gt; Path.GetFullPath
        |&amp;gt; load
        |&amp;gt; build
    exit // return an integer exit code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can build our project!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/gifs/chris_build.gif&quot; alt=&quot;Build with Chris&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Editor support&lt;/h1&gt;

&lt;p&gt;Another important part of project system is providing information for F# Language Services which lets us to create rich editing environment across many different editors. Fortunatly FSharp.Compiler.Service is designed to be totally decoupled from project file format and requires its &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/reference/microsoft-fsharp-compiler-sourcecodeservices-fsharpprojectoptions.html&quot;&gt;custom type&lt;/a&gt; to provide all nice &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/editor.html&quot;&gt;Language Services features&lt;/a&gt;. Since we already have function loading &lt;code&gt;project.chris&lt;/code&gt; to memory all we need to do is creating function which maps our type to type required by FCS.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;let toFSharpProjectOptions (project, path) =
    let rsp = (project, path) |&amp;gt; toFSCParams
    {
      ProjectFileName = path
      ProjectFileNames = [||]
      OtherOptions = rsp
      ReferencedProjects = [||]
      IsIncompleteTypeCheckEnvironment = false
      UseScriptResolutionRules = false
      LoadTime = System.DateTime.Now
      UnresolvedReferences = None;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next step is actually adding support for &lt;code&gt;project.chris&lt;/code&gt; to our editor of choice. It’s pretty easy for all editors and tools using FSharp.Compiler.Service in the background, but for sake of simplicity I’ve chosen &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VS Code&lt;/a&gt; with &lt;a href=&quot;https://ionide.io&quot;&gt;Ionide&lt;/a&gt;. As you may know, VS Code is editor created using &lt;a href=&quot;http://electron.atom.io/&quot;&gt;Electron&lt;/a&gt; which is framework for building cross-platform, desktop applications using HTML, JS, and CSS. Such choice has many advantages, but one bug important drawback from F# editor tooling point of view - we can’t directly use .Net libraries in VS Code. To communicate with .Net libraries (and especially with FSharp.Compiler.Service) we are using &lt;a href=&quot;https://github.com/fsharp/FsAutoComplete&quot;&gt;FsAutoComplete&lt;/a&gt; - F# compiler service API exposed via a console application and HTTP server.&lt;/p&gt;

&lt;p&gt;Adding &lt;code&gt;project.chris&lt;/code&gt; support to FsAutoComplete is, again, fairly easy. First step is adding Chris project as reference to FsAutoComplete. Next we create helper function which will be executed if we try to load &lt;code&gt;project.chris&lt;/code&gt; file - it’s basically copy-paste of &lt;a href=&quot;https://github.com/fsharp/FsAutoComplete/blob/master/src/FsAutoComplete.Core/CompilerServiceInterface.fs#L189-L222&quot;&gt;same functions&lt;/a&gt; for &lt;code&gt;.fsproj&lt;/code&gt; and &lt;code&gt;project.json&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;  member x.TryGetChrisProjectOption (file : string) : Result&amp;lt;_&amp;gt; =
    if not (File.Exists file) then
      Failure (sprintf &quot;File &#39;%s&#39; does not exist&quot; file)
    else
      try
        let po = file |&amp;gt; Chris.load |&amp;gt; Chris.toFSharpProjectOptions
        let compileFiles = Seq.filter (fun (s:string) -&amp;gt; s.EndsWith(&quot;.fs&quot;)) po.OtherOptions
        let outputFile = Seq.tryPick (chooseByPrefix &quot;--out:&quot;) po.OtherOptions
        let references = Seq.choose (chooseByPrefix &quot;-r:&quot;) po.OtherOptions
        Success (po, Seq.toList compileFiles, outputFile, Seq.toList references, Map&amp;lt;string,string&amp;gt;([||]))
      with e -&amp;gt;
        Failure e.Message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last step is modifying &lt;a href=&quot;https://github.com/fsharp/FsAutoComplete/blob/master/src/FsAutoComplete.Core/FsAutoComplete.Core.fs#L51-L55&quot;&gt;handler for project request&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;let options =
    if file.EndsWith &quot;fsproj&quot; then
        checker.TryGetProjectOptions(file, verbose)
    elif file.EndsWith &quot;chris&quot; then
        checker.TryGetChrisProjectOption file
    else
        checker.TryGetCoreProjectOptions file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compile FSAC, copy modified version to Iondie plugin folder… and that’s all. Everything is working as always, just with &lt;code&gt;project.chris&lt;/code&gt;.
&lt;img src=&quot;images/gifs/chris_editor.gif&quot; alt=&quot;Editor with Chris&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Frequently Asked Question&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Q: You haven’t mentioned VS at all, it surely means you hate it and ignore, right?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: No, VS (with VFPT installed) is best F# IDE, but I don’t use it too much. Adding custom project file support to VS is definitely possible, it just requires knowledge I don’t have. Thus, I haven’t mentioned it in post.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: What about C# / F# interoperability, compatibility with existing F# projects?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: In worst case scenario - we have compatibility on compiled code / package level ( I can imagine some workflow using Paket which would make it not too problematic). In “best” case - custom MsBuild task, but again, I don’t have enough knowledge to judge how possible it is.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: You’re just one of those elitist, arrogant guys thinking they are better because they use this new-overhyped thing - functional programming. You just hate MsBuild because it’s C#!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: Yes, indeed. Move along. Nothing to see here.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: What about support for any other F# tooling such as FSharpLint?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: Any tool using FSharp.Compiler.Service should be very easy to port, as presented above on FsAutoComplete example.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: Where is code, I want to use it now!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: Code of this experiment is not published anywhere on purpose - I don’t want anyone to use it by any chance. It was just very simple proof of concept. Hopefully, one day F# Community will be ready for new project system.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: I &lt;strong&gt;really&lt;/strong&gt; want to use something like that&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: Ask &lt;a href=&quot;https://twitter.com/7sharp9_exhumed&quot;&gt;Dave Thomas&lt;/a&gt; about his Xebec project, and support &lt;a href=&quot;https://twitter.com/7sharp9_exhumed/status/745995222178480128&quot;&gt;fsprojexit&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post I’ve presented possible ways of expanding F# development environment with new project system. I haven’t shown here any ready solutions for the problem but I hope that this post shows that having new, better project system is possible. We just need as Community to start reasonable discussion about such possibility.&lt;/p&gt;
</description>
                <pubDate>Thu, 23 Jun 2016 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Creating-custom-project-file-for-F</link>
                <guid isPermaLink="true">http://kcieslak.io/Creating-custom-project-file-for-F</guid>
                
                <category>F#</category>
                
                <category>VS Code</category>
                
                <category>Tooling</category>
                
                
            </item>
        
            <item>
                <title>Getting started with Fable and Webpack</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/fsprojects/Fable&quot;&gt;Fable&lt;/a&gt; is new F# to JavaScript compiler created by &lt;a href=&quot;https://twitter.com/alfonsogcnunez&quot;&gt;Alfonso Garcia-Caro&lt;/a&gt;. In this post I’ll go, step by step, through process of creating client-side (browser) applications using it.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This post is targeted at F# developers without lot of knowladge about Node.js and JS ecosystem and it should let any F# developer to get started with Fable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Requirements&lt;/h3&gt;

&lt;p&gt;Fable requires having both &lt;a href=&quot;http://fsharp.org&quot;&gt;F# 4&lt;/a&gt; and &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;node 4.4&lt;/a&gt; or bigger installed in your computer.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Setting up project&lt;/h1&gt;

&lt;p&gt;The first thing we need to do is creating new directory and initializing node project:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir fable-test
cd fable-test
npm init
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;Npm&lt;/a&gt; is is the package manager for JavaScript. It lets users to find, share, and reuse packages of code or install additional tools&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;npm init&lt;/code&gt; will create &lt;code&gt;package.json&lt;/code&gt; file. This file is project file for any Node.js based project (both client and server side). At start it will contain only basic information about a project, something like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;name&quot;: &quot;fable-test&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;...&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Installing development tools.&lt;/h3&gt;

&lt;p&gt;Next step is installing all development dependencies (tools) which we’ll be using for our project. To do so we are using &lt;code&gt;npm install&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install --save-dev fable-compiler
npm install --save-dev webpack
npm install --save-dev source-map-loader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First line installs Fable compiler for our project. Second command installs &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt;. Webpack is a module bundler - it takes modules with dependencies and generates static assets representing those modules. In our case it would take generated by Fable files together with other JS libraries we will depend upon and create single file output which can be easily added to page. Last dependency is plugin to Webpack which will enable nice debugging story for our application (debugging F# files in the browser)&lt;/p&gt;

&lt;p&gt;It’s also worth noticing that those commands modified &lt;code&gt;package.json&lt;/code&gt; file, now it contains also following block:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;devDependencies&quot;: {
  &quot;fable-compiler&quot;: &quot;^0.2.12&quot;,
  &quot;source-map-loader&quot;: &quot;^0.1.5&quot;,
  &quot;webpack&quot;: &quot;^1.13.0&quot;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Installing dependencies&lt;/h3&gt;

&lt;p&gt;Now we will install our code dependencies using also &lt;code&gt;npm install&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install --save core-js
npm install --save fable-core
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;core-js&lt;/code&gt; is polyfill ensuring that code generated by Fable will run in any browser. &lt;code&gt;fable-core&lt;/code&gt; is standard Fable library.&lt;/p&gt;

&lt;p&gt;Those commands again modified &lt;code&gt;package.json&lt;/code&gt; file, this time adding following information:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;dependencies&quot;: {
    &quot;core-js&quot;: &quot;^2.4.0&quot;,
    &quot;fable-core&quot;: &quot;0.0.21&quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Creating F# script and HTML file&lt;/h3&gt;

&lt;p&gt;Fable supports both &lt;code&gt;fsproj&lt;/code&gt; and plain &lt;code&gt;fsx&lt;/code&gt; files. For simplicity in this example let’s use &lt;code&gt;fsx&lt;/code&gt; file. Create &lt;code&gt;source\code.fsx&lt;/code&gt; with follwing content:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;#r &quot;../node_modules/fable-core/Fable.Core.dll&quot;

open Fable.Core 
open Fable.Import
 
Node.require.Invoke(&quot;core-js&quot;) |&amp;gt; ignore

let element = Browser.document.getElementById &quot;sample&quot;
element.innerText &amp;lt;- &quot;Hello, world !!&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code should be pretty straightforward, only tricky part is &lt;code&gt;Node.require.Invoke(&quot;core-js&quot;)&lt;/code&gt; which is importing Node.js module (installed by &lt;code&gt;npm&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Let’s also create very simple HTML file &lt;code&gt;public\index.html&lt;/code&gt; ( &lt;code&gt;public&lt;/code&gt; will be our output folder):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta http-equiv=&#39;Content-Type&#39; content=&#39;text/html; charset=utf-8&#39;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div id=&#39;sample&#39;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;script src=&quot;bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Configuration&lt;/h1&gt;

&lt;p&gt;First step is creating configuration for Fable compiler. It’s done by creating &lt;code&gt;fableconfig.json&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;module&quot;: &quot;commonjs&quot;,
  &quot;sourceMaps&quot;: true,
  &quot;projFile&quot;: &quot;./src/code.fsx&quot;,
  &quot;outDir&quot;: &quot;temp&quot;,
  &quot;scripts&quot;: {
    &quot;prebuild&quot;: &quot;npm install&quot;,
    &quot;postbuild&quot;: &quot;webpack&quot;
  },
  &quot;targets&quot;: {
    &quot;watch&quot;: {
      &quot;scripts&quot;: {
        &quot;postbuild&quot;: &quot;webpack --watch&quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we define module type - in our case it’s &lt;code&gt;commonjs&lt;/code&gt; (as it’s working well with &lt;code&gt;Webpack&lt;/code&gt;). Next we define that we want to use soruce maps (it allows F# file debugging), entry point of application, and output directory for compiled JS files.
Next step is defining some small scripts which will be run before and after every build - before we want to run &lt;code&gt;npm install&lt;/code&gt; to restore all dependencies, after build we run &lt;code&gt;webpack&lt;/code&gt; to create bundled output file. Last part defines additional target which will be executed in &lt;code&gt;watch&lt;/code&gt; mode. In such case we want to run &lt;code&gt;webpack&lt;/code&gt; also in &lt;code&gt;watch&lt;/code&gt; mode.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;watch&lt;/code&gt; mode will make Fable and Webpack to recompile project after every file save without need to execute any additional commands.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Webpack configuration&lt;/h3&gt;

&lt;p&gt;Second step is to create &lt;code&gt;webpack&lt;/code&gt; configuration. Let’s create &lt;code&gt;webpack.config.js&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var path = require(&quot;path&quot;);
var webpack = require(&quot;webpack&quot;);

var cfg = {
  devtool: &quot;source-map&quot;,
  entry: &quot;./temp/code.js&quot;,
  output: {
    path: path.join(__dirname, &quot;public&quot;),
    filename: &quot;bundle.js&quot;
  },
  module: {
    preLoaders: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: &quot;source-map-loader&quot;
      }
    ]
  }
};

module.exports = cfg;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this file we define that we want to use source maps, entry point for webpack ( so file generated by Fable), output path, and usage of any additional plugins (in our case it will be &lt;code&gt;source-map-loader&lt;/code&gt; installed before)&lt;/p&gt;

&lt;h3&gt;Npm scripts&lt;/h3&gt;

&lt;p&gt;Easiest way to run tools installed by &lt;code&gt;npm&lt;/code&gt; is by using scripts section in &lt;code&gt;packages.json&lt;/code&gt; file. Let’s put there following scripts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;scripts&quot;: {
  &quot;build&quot;: &quot;fable&quot;,
  &quot;watch&quot;: &quot;fable -w --target watch&quot;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;build&lt;/code&gt; just starts Fable. &lt;code&gt;watch&lt;/code&gt;, as name suggests, starts Fable in &lt;code&gt;watch&lt;/code&gt; mode, so code is regenerated every time we save F# file. We can run those scripts using &lt;code&gt;npm run &amp;lt;script_name&amp;gt;&lt;/code&gt; command.&lt;/p&gt;

&lt;h3&gt;VSCode configuration&lt;/h3&gt;

&lt;p&gt;Last, optional step is creating &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VSCode&lt;/a&gt; configuration. It’s fairly easy since editor has decent integration with &lt;code&gt;npm&lt;/code&gt;. All we need to do is create &lt;code&gt;.vscode\tasks.json&lt;/code&gt; file and put there following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;command&quot;: &quot;npm&quot;,
  &quot;isShellCommand&quot;: true,
  &quot;showOutput&quot;: &quot;always&quot;,
  &quot;suppressTaskName&quot;: true,
  &quot;tasks&quot;: [
    {
      &quot;taskName&quot;: &quot;install&quot;,
      &quot;args&quot;: [&quot;install&quot;]
    },
    {
      &quot;taskName&quot;: &quot;build&quot;,
      &quot;args&quot;: [&quot;run&quot;, &quot;build&quot;],
      &quot;isBuildCommand&quot;: true
    },
    {
      &quot;taskName&quot;: &quot;watch&quot;,
      &quot;args&quot;: [&quot;run&quot;, &quot;watch&quot;],
      &quot;isWatching&quot;: true
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we define that our tasks are using &lt;code&gt;npm&lt;/code&gt; and we define arguments send to &lt;code&gt;npm&lt;/code&gt; with every task. 
We can run those task usign &lt;code&gt;Tasks: Run Task&lt;/code&gt; command (&lt;code&gt;build&lt;/code&gt; task can be also run using &lt;code&gt;Tasks: Run Build Command&lt;/code&gt; command or &lt;code&gt;Ctrl + Shift + B&lt;/code&gt;)&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post we have shortly moved all steps necessary to create browser, client-side applications using F#, Fable and Webpack. Whole source code of this sample application is on GitHub - https://github.com/Krzysztof-Cieslak/fable-webpack-demo&lt;/p&gt;
</description>
                <pubDate>Mon, 16 May 2016 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Getting-Started-with-Fable-and-Webpack</link>
                <guid isPermaLink="true">http://kcieslak.io/Getting-Started-with-Fable-and-Webpack</guid>
                
                <category>F#</category>
                
                <category>Fable</category>
                
                <category>VS Code</category>
                
                <category>Webpack</category>
                
                <category>JS</category>
                
                
            </item>
        
            <item>
                <title>Creating VS Code plugins with F# and Fable</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;EDIT 22.03.2016&lt;/em&gt; Thanks to Alfonso’s help I was able to remove postbuild step fixing JS.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VS Code&lt;/a&gt; is new text editor (or rather lightweight IDE) created by Microsoft. Because it is product based on &lt;a href=&quot;http://electron.atom.io/&quot;&gt;Electron&lt;/a&gt; - cross platform engine allowing developers to write desktop applications using web technologies - its plugin system supports JavaScript (and TypeScript). Unfortunately both those languages are not nice choice for someone using statically typed functional programming languages like F#. Up to this moment in my VS Code extensions I was using F# library called &lt;a href=&quot;http://funscript.info/&quot;&gt;FunScript&lt;/a&gt; which compiles F# code to JavaScript. Whereas it sounds nice, library has some problems which makes writing code using it not nice experience. Fortunately recently, &lt;a href=&quot;https://twitter.com/alfonsogcnunez&quot;&gt;Alfonso Garcia-Caro&lt;/a&gt;, one of contributors to FunScript, has decided to create new project compiling F# to JS (with &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; as middle step) called &lt;a href=&quot;https://github.com/fsprojects/Fable&quot;&gt;Fable&lt;/a&gt; which hopefully will solve some of the FunScript’s problems. I have decided to investigate how this new library can be used to create VS Code plugins… using VS Code to code and compile those plugins.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Requirements&lt;/h1&gt;

&lt;p&gt;You need to have &lt;a href=&quot;http://fsharp.org/&quot;&gt;F# 4&lt;/a&gt; and &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;node.js&lt;/a&gt; installed. Node has to be included in your &lt;code&gt;$PATH&lt;/code&gt;.&lt;/p&gt;

&lt;h1&gt;Initial steps&lt;/h1&gt;

&lt;p&gt;The simplest way to start building own VS Code plugin is using &lt;a href=&quot;http://yeoman.io/&quot;&gt;Yeoman&lt;/a&gt; to scaffold plugin project. Install Yeoman and &lt;a href=&quot;https://code.visualstudio.com/docs/tools/yocode&quot;&gt;VS Code Plugin Generator&lt;/a&gt; using following commands:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install -g yo
npm install -g generator-code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Yeoman generator will walk you through the steps required to create your customization or extension prompting for the required information. To launch the generator type the following in a command prompt:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;yo code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We pick &lt;code&gt;New Extension (JavaScript)&lt;/code&gt; option, go through all questions, and let Yeoman do its magic. After process is finished we enter newly created folder.Here we have to remove some unnecessary things generated by Yeoman - &lt;code&gt;extension.js&lt;/code&gt; file, and &lt;code&gt;typing&lt;/code&gt; and &lt;code&gt;tests&lt;/code&gt; folders (who need tests anyway ;) ). We add &lt;code&gt;out/&lt;/code&gt; entry to &lt;code&gt;.gitignore&lt;/code&gt; files - all output files will be generated as part of our build process and shouldn’t be commited to GitHub. Final step is creating empty &lt;code&gt;src&lt;/code&gt; folder - it will contain our F# source files.&lt;/p&gt;

&lt;h1&gt;Installing Fable and setting project.&lt;/h1&gt;

&lt;p&gt;Installing Fable and VS Code bindings for it is easy - all things are published as npm modules. So we can just run following commands to add those tools to our project&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install --save-dev fable-compiler
npm install --save-dev fable-import fable-import-vscode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next step is updating our &lt;code&gt;package.json&lt;/code&gt; file to include changes we have done and to create build targets which will compile F# code to JS.First of all we update &lt;code&gt;main&lt;/code&gt; entry - it defines where is our entry file of plugin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
...  
&quot;main&quot;: &quot;./out/extension&quot;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second, we update &lt;code&gt;scripts&lt;/code&gt; part - here we define possible build targets which can be used for our project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
...
&quot;scripts&quot;: {
    &quot;build&quot;: &quot;fable src/extension.fsx --outDir ../out -m --env node&quot;
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;For more details about Fabel and compiler options please visit &lt;a href=&quot;https://github.com/fsprojects/Fable&quot;&gt;Fable on GitHub&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;build&lt;/code&gt; target runs fable compiler to generate JS from our F# file.&lt;/p&gt;

&lt;h1&gt;Writing F# Code&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;For more details about VS Code extension API please visit &lt;a href=&quot;https://code.visualstudio.com/docs/extensions/overview&quot;&gt;extension documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At last we can write some F# code. Our sample extension will be simple - it will be just Hello World.To start in &lt;code&gt;src&lt;/code&gt; folder we create F# script file called &lt;code&gt;extension.fs&lt;/code&gt;. First step is referencing Fable core library and VS Code bindings&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;#r &quot;../node_modules/fable-import/Fable.Import.dll&quot;
#load &quot;../node_modules/fable-import-vscode/Fable.Import.VSCode.fs&quot;
 
open Fable.Core
open Fable.Import
open Fable.Import.vscode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Entry point of any VS Code plugin is activate function placed in file defined as entry point in &lt;code&gt;package.json&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;open Fable.Import.vscode.commands.Globals

let activate (context : vscode.ExtensionContext) = 
  registerCommand(&quot;extension.sayHello&quot;, fun _ -&amp;gt;
    showInformationMessage &quot;Hello world!&quot; |&amp;gt; unbox )
  |&amp;gt; context.subscriptions.Add    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see we can use both standard F# construct like &lt;code&gt;printfn&lt;/code&gt; function (which is mapped to JS &lt;code&gt;console.log&lt;/code&gt;) and functions defined in VS Code bindings. Here we print “Hello world” to console and register command which will display Hello World information in the popup. Now from console, we can run &lt;code&gt;npm build&lt;/code&gt; and compile our F# script to JavaScript. We shall see result in &lt;code&gt;out&lt;/code&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;Node.Globals.exports?activate &amp;lt;- activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last step is adding &lt;code&gt;activate&lt;/code&gt; to &lt;code&gt;exports&lt;/code&gt; object using Fable dynamic operator (&lt;code&gt;?&lt;/code&gt;)&lt;/p&gt;

&lt;h1&gt;Integration with VS Code&lt;/h1&gt;

&lt;p&gt;Now, when we have set up project and can compile it, we need to integrate our solution with VS Code - first we define Task to run our build script from inside editor.
In &lt;code&gt;.vscode&lt;/code&gt; folder we create &lt;code&gt;tasks.json&lt;/code&gt; file and put there:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;command&quot;: &quot;npm&quot;,
  &quot;isShellCommand&quot;: true,
  &quot;tasks&quot;: [
    {
     &quot;taskName&quot;: &quot;run&quot;,
      &quot;isBuildCommand&quot;: true,
      &quot;args&quot;: [ &quot;build&quot; ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It’s just simple task running &lt;code&gt;npm run build&lt;/code&gt; - it is defined as build command which means it can be run using &lt;code&gt;Ctrl+Shift+B&lt;/code&gt; command. Next step is setting this target as task we want to invoke before we start debugging. To do this, we open &lt;code&gt;launch.json&lt;/code&gt; file and append &lt;code&gt;&quot;preLaunchTask&quot;: &quot;run&quot;&lt;/code&gt; to &lt;code&gt;Lanunch Extension&lt;/code&gt; configuration (we can remove &lt;code&gt;Launch test&lt;/code&gt; entry, we do not need tests anyway ;) ). Pressing F5 will run our extension - we can try it out by running &lt;code&gt;Hello World&lt;/code&gt; command in Command Palette.&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post we have shortly moved all steps necessary to create VS Code extension using F# and Fable. From my short experience with this tool it looks like it is much nicer option than FunScript, hopefully I will be able to port my other extensions to it! Whole source code of this sample application is on &lt;a href=&quot;https://github.com/Krzysztof-Cieslak/vscode-fable-demo&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
                <pubDate>Mon, 21 Mar 2016 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/Creating-VS-Code-plugins-with-F-and-Fable</link>
                <guid isPermaLink="true">http://kcieslak.io/Creating-VS-Code-plugins-with-F-and-Fable</guid>
                
                <category>F#</category>
                
                <category>Fable</category>
                
                <category>VS Code</category>
                
                
            </item>
        
            <item>
                <title>Using Node.js and NPM with Paket and FAKE</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Web development is great fit for F# and Functional Programming . Libraries like &lt;a href=&quot;http://suave.io&quot;&gt;Suave&lt;/a&gt; or &lt;a href=&quot;http://docs.freya.io/en/latest/&quot;&gt;Freya&lt;/a&gt; makes it easy to create well-architectures, composable web applications. But that’s backend part of story. Nowadays most web applications are required to have lot of user interactions and logic on the front-end side - in the browser.&lt;/p&gt;

&lt;p&gt;Two important tools for front-end JavaScript development are &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt; (JS backend server, used for running many JS development tools) and &lt;a href=&quot;npmjs.com&quot;&gt;npm&lt;/a&gt; - package manager for Node.js. Those 2 tools are often installed globally on developer PC, are used to define dependencies for front-end application, and define build pipeline for it.&lt;/p&gt;

&lt;p&gt;But, using different build tools for backend and front-end development in one application can get annoying and tiresome for developer, so it would be nice to use one build pipeline for all tasks. And it is possible with Paket and FAKE.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Installing Node and npm using Paket&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;In case you haven’t heard about Paket - it is alternative dependency management tool built by F# community, supporting NuGet, GitHub and git. For more information please visit : &lt;a href=&quot;http://fsprojects.github.io/Paket/&quot;&gt;http://fsprojects.github.io/Paket/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Installing Node.js and npm using Paket is as easy as installing any .Net package - luckily there exist up-to-date NuGet packages for both tools.&lt;/p&gt;

&lt;p&gt;Installing Node:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;paket add nuget Node.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Installing npm:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;paket add nuget Npm.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tools executable are respectively &lt;code&gt;.\packages\Node.js\node.exe&lt;/code&gt; and &lt;code&gt;.\packages\Npm.js\tools\npm.cmd&lt;/code&gt;.&lt;/p&gt;

&lt;h1&gt;Using package.json file&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;package.json&lt;/code&gt; is npm file defining project, its dependencies and build scripts we can run. For more information about it, please visit &lt;a href=&quot;https://docs.npmjs.com/files/package.json&quot;&gt;npm documentation on this topic&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Package.json&lt;/code&gt; file looks as in every normal project using npm. We define our project name, repository, dependencies and we create build scripts. There is one small difference - instead of just calling &lt;code&gt;node&lt;/code&gt; or &lt;code&gt;npm&lt;/code&gt; we have to give relative installation path to those tools.&lt;/p&gt;

&lt;p&gt;Example &lt;code&gt;scripts&lt;/code&gt; section of &lt;code&gt;package.json&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;scripts&quot;: {
  &quot;build:js&quot;: &quot;packages\\Node.js\\node.exe node_modules/uglifyjs-folder/cli.js
                web/content/app/ -eo web/content/dist/&quot;,
  &quot;build&quot;: &quot;packages\\Npm.js\\tools\\npm.cmd run build:js&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Running npm scripts using FAKE&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;FAKE - F# Make - is a build automation system with capabilities which are similar to make and rake. It is using an easy domain-specific language (DSL) so that you can start using it without learning F#. For more details visit: &lt;a href=&quot;http://fsharp.github.io/FAKE/&quot;&gt;http://fsharp.github.io/FAKE/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;FAKE is fantastic build system, that allows to create complex build scripts using F#. One of its big advantage is having built-in helpers for different tools from .Net space … and not only .Net. Fortunately, there exist FAKE helper for npm.&lt;/p&gt;

&lt;p&gt;Using npm helper is as simple as creating normal FAKE target and running &lt;code&gt;Npm&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Running &lt;code&gt;npm install&lt;/code&gt; - command downloading all dependencies specified in &lt;code&gt;package.json&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;Target &quot;NpmInstall&quot; (fun _ -&amp;gt;
  Npm (fun p -&amp;gt;
        { p with
          Command = Install Standard
          WorkingDirectory = &quot;./src/FAKESimple.Web/&quot;
        })
 )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running build script defined in &lt;code&gt;package.json&lt;/code&gt; file is not different:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;Target &quot;NpmInstall&quot; (fun _ -&amp;gt;
  Npm (fun p -&amp;gt;
        { p with
          Command = (Run &quot;build&quot;)
          WorkingDirectory = &quot;./src/FAKESimple.Web/&quot;
        })
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In the post we’ve shortly moved through all steps necessery to create build pipeline combingin our known F# tools - Paket and FAKE, with JavaScript tooling used for front-end development - Node and npm. This post was based on FsSnippet web page implementation where this technique is used - for more details, and “real world” usage feel free to check &lt;a href=&quot;https://github.com/fssnippets/fssnip-website&quot;&gt;FsSnippet source code on GitHub&lt;/a&gt;&lt;/p&gt;
</description>
                <pubDate>Tue, 01 Mar 2016 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/Using-Node-with-Paket-and-Fake</link>
                <guid isPermaLink="true">http://kcieslak.io/Using-Node-with-Paket-and-Fake</guid>
                
                <category>F#</category>
                
                <category>Paket</category>
                
                <category>FAKE</category>
                
                
            </item>
        
    </channel>
</rss>