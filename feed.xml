<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>F# Reflections</title>
        <description>Blog about F# and FP Programming</description>
        <link>http://kcieslak.io/</link>
        <atom:link href="http://kcieslak.io/feed.xml" rel="self" type="application/rss+xml"/>
        <pubDate>Fri, 14 Dec 2018 21:21:47 +0100</pubDate>
        <lastBuildDate>Fri, 14 Dec 2018 21:21:47 +0100</lastBuildDate>
        <generator>Jekyll v3.3.1</generator>
        
            <item>
                <title>Introducing F# Analyzers</title>
                <description>&lt;h1&gt;Introducing F# Analyzers&lt;/h1&gt;

&lt;p&gt;One of the most exciting features of Roslyn (modern C# compiler) is ability to plug into it custom extensions called &lt;a href=&quot;https://docs.microsoft.com/en-us/visualstudio/extensibility/getting-started-with-roslyn-analyzers?view=vs-2017&quot;&gt;Roslyn Analyzers&lt;/a&gt;. They are live, real-time, project based plugins that enables to diagnose source code and surface custom errors, warnings and code fixes into Visual Studio. What’s really important is fact that there are project based, and distributed through NuGet which means they are easy to install, and ensure that all developers working on the project have exactly same analyzers installed. This is really useful if you want to ensure common best practices, style etc while working on the project.&lt;/p&gt;

&lt;p&gt;Today I’d like to introduce preview of the project called F# Analyzers which adds similar capabilities to &lt;a href=&quot;http://ionide.io&quot;&gt;Ionide&lt;/a&gt; (F# support in VS Code). Project is still in the early days, so design and technical details can change in time, but I’m really excited to share it with users even in its current state.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3&gt;Architecture overview&lt;/h3&gt;

&lt;p&gt;Before diving deeper into Analyzers themselves, it’s important to understand general architecture of Ionide, and where Analyzers fits into this architecture. This has really important impact on the Analyzers capabilities and limitations.&lt;/p&gt;

&lt;p&gt;On the one hand we have Ionide itself. It’s &lt;a href=&quot;https://code.visualstudio.com/docs/extensions/overview&quot;&gt;VS Code plugin&lt;/a&gt; which means it’s using NodeJS runtime, running as a child process of the editor, communicating with VS Code using set of APIs provided by VS Code. On the other hand we have F# compiler, or exactly speaking &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/index.html&quot;&gt;FSharp.Compiler.Service&lt;/a&gt; which is library version of F# compiler, exposing some additional APIs useful for creating tooling for F#. Of course, &lt;code&gt;FSharp.Compiler.Service&lt;/code&gt; is .Net library which means it can’t be used directly by NodeJS process.&lt;/p&gt;

&lt;p&gt;Last important part of the architecture is &lt;a href=&quot;https://github.com/fsharp/FsAutoComplete&quot;&gt;FsAutoComplete&lt;/a&gt;. It’s a project that provides communication layer and high level API between FCS and external world. It’s used by vim, emacs and Ionide as all those plugins are hosted in non .Net environments.&lt;/p&gt;

&lt;p&gt;The F# Analyzers are using extension point provided by the FsAutoComplete which means that in current shape they can be supported only by the editors using it (and they requires some work on the plugin side of things - currently only Ionide supports them). And it means that diagnostics provided by them are visible only in the editor, not during compilation.&lt;/p&gt;

&lt;h3&gt;Analyzers basics&lt;/h3&gt;

&lt;p&gt;Analyzer is normal F# function. As an input it takes Context object which contains current information about the file - Parse Tree, Type Abstract Syntax Tree, Symbols information, and returns list of the Diagnostics - records containing diagnostic message, type, description, and potentially list of fixes that can be used to fix the problem.&lt;/p&gt;

&lt;p&gt;F# Analyzer contains 3 parts - first one is an extension point in FSAC which is responsible for loading and running analyzers, second one is a editor handler (part of Ionide, in this case) that displays diagnostics and fixes. Last part is &lt;a href=&quot;https://github.com/Krzysztof-Cieslak/FSharp.Analyzers.SDK&quot;&gt;FSharp.Analayzers.SDK&lt;/a&gt; project that’s used to create analyzers.&lt;/p&gt;

&lt;h3&gt;Building your first analyzer&lt;/h3&gt;

&lt;p&gt;From infrastructure point of view, creating analyzer is simple - you need to create normal F# project, &lt;code&gt;netstandard2.0&lt;/code&gt; , add reference to &lt;code&gt;FSharp.Analyzers.SDK&lt;/code&gt; (avaliable on NuGet - &lt;a href=&quot;https://www.nuget.org/packages/FSharp.Analyzers.SDK/&quot;&gt;https://www.nuget.org/packages/FSharp.Analyzers.SDK&lt;/a&gt;) and create analyzer functions - normal F# functions taking Context returning list of diagnostics, and marked with Analyzer attribute.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Due to unresolved technical limitations your Analyzer must contain “Analyzer” in the name of output dll.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;However, from technical point of view creating analyzer is fairly difficult task - you need to be familiar with processing typed or untyped abstract syntax tree, or accessing FSharp Symbols information. Currently SDK doesn’t provide any helper functions, but we hope to add some higher level abstractions in the future. Currently, I recommend going through &lt;a href=&quot;http://fsharp.github.io/FSharp.Compiler.Service/&quot;&gt;FCS documentation&lt;/a&gt;, to get more familiar with the concepts&lt;/p&gt;

&lt;p&gt;Generally speaking processing Abstract Syntax Trees is usually done by recursive pattern matching on the DU representing syntax nodes. The following snippet shows how to travers Type Abstract Syntax Tree and call some function on every node that represents call of the member. While it looks bit scary, and complex if you take a look on it bit longer you will notice that it’s just big recursive pattern matching. Also, similar pattern matching will be base for most analyzers, which means you can reuse the code pretty easily.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/34c2a43c52119fde8d55315c7831244d.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Having this bit of infrastructure code, let’s now move to the analyzer itself. As I’ve mentioned before, analyzers are normal functions that have particular signature and are marked with attribute.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/42829ce7b5dcc937bece698a5af9ff2b.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;In the above snippet we create analyzer that will detect any call of &lt;code&gt;x.Value&lt;/code&gt; where x is an F# Option. As you probably know calling &lt;code&gt;.Value&lt;/code&gt; on an &lt;code&gt;option&lt;/code&gt; is not total function and can throw exception if an &lt;code&gt;option&lt;/code&gt; instance is &lt;code&gt;None&lt;/code&gt;, so checking for it may be good idea.&lt;/p&gt;

&lt;p&gt;The handler function in above example is executed for every member call. In it we check if the name of the function we call, and if it’s &lt;code&gt;Option.Value&lt;/code&gt; we add the range of the symbol into the state. After we’ve processed whole tree we map all ranges into the warnings that will be displayed in the editor. There also exist possibility of providing set of code fixes, but we don’t use it in this example.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Whole code of the sample analyzer is available on GitHub - &lt;a href=&quot;https://github.com/Krzysztof-Cieslak/FSharp.Analyzers.Sample&quot;&gt;https://github.com/Krzysztof-Cieslak/FSharp.Analyzers.Sample&lt;/a&gt;, and analyzer is published on NuGet - &lt;a href=&quot;https://www.nuget.org/packages/FSharp.Analyzers.Sample/&quot;&gt;https://www.nuget.org/packages/FSharp.Analyzers.Sample/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Using analyzer&lt;/h3&gt;

&lt;p&gt;Analyzers are enabled by &lt;code&gt;FSharp.enableAnalyzers&lt;/code&gt; setting inside VSCode. By default it’s disabled, so you need to edit settings to enable analyzers support. Using analyzers is as simple as adding Analyzer NuGet package with Paket - for out of the box support in Iondie you need to use Analyzer group for it.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/dc71359d81354129187584c502cc60e6.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;After the package is added to &lt;code&gt;paket.dependencies&lt;/code&gt; and restored, Ionide will automatically detect and load analyzers. It may require editor restart as analyzers are loaded on plugin startup.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ionide also contains setting &lt;code&gt;FSharp.analyzersPath&lt;/code&gt; that will enable you to configure paths from which Ionide loads analyzers, by default it’s using &lt;code&gt;packages/Analyzers&lt;/code&gt; and &lt;code&gt;analyzers&lt;/code&gt; folders.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example let’s test our new analyzer on the following snippet.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/c1962db70231ec9d2581955324f6ac82.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;This will result in underlying &lt;code&gt;x.Value&lt;/code&gt; with a warning saying that Option.Value shouldn’t be used&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*axoWiRB3EPANiOljA_PWzg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sample project using analyzer can be found on GitHub - &lt;a href=&quot;https://github.com/Krzysztof-Cieslak/FSharp.Analyzers.Sample.Usage&quot;&gt;https://github.com/Krzysztof-Cieslak/FSharp.Analyzers.Sample.Usage&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;So what’s next?&lt;/h3&gt;

&lt;p&gt;Currently there are several important limitation of the F# Analyzers. First of all they’re supported only by Ionide. Secondly to write analyzer you need to be familiar with F# (T)AST pretty well. And in the end writing fixes requires providing new version of code in textual form (unlike in case of Roslyn Analyzers where fixes can be provided as AST transformation), what may be difficult and error prone. Also, whole mechanism is currently in an experimental phase, relies on Reflection etc. so it can be bit unstable.&lt;/p&gt;

&lt;p&gt;However, I treat this as an experiment and proof of concept, that may be used as a base for discussing similar functionalities being added to F# compiler or other IDEs. Also I’m super excited to see what potentially great things can F# Community create having such extension point in the editor (Evil Hint: You can use this feature to run any code inside of the language server and return some information to editor… which sounds awesome and crazy at the same time)&lt;/p&gt;

&lt;h3&gt;Summary&lt;/h3&gt;

&lt;p&gt;In this post I’ve introduced preview of new tooling related project that enables users to add custom analyzers to your editor, bringing functionality similar to Roslyn Analyzers. While this is only experiment, and proof-of-concept I’m looking forward to seeing all innovative things it can enable. Analyzers support has been released in new Ionide version - &lt;code&gt;3.27.0&lt;/code&gt; - so it’s out there and ready for experimenting!&lt;/p&gt;
</description>
                <pubDate>Fri, 14 Sep 2018 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Introducing-F-Analyzers</link>
                <guid isPermaLink="true">http://kcieslak.io/Introducing-F-Analyzers</guid>
                
                <category>F#</category>
                
                <category>VS Code</category>
                
                <category>Tooling</category>
                
                
            </item>
        
            <item>
                <title>Building an MVP with F# and Saturn</title>
                <description>&lt;h1&gt;Building an MVP with F# and Saturn&lt;/h1&gt;

&lt;p&gt;Creating an MVP (minimum viable product) is one of the best way of bootstrapping your startup. As a new company getting a quick feedback from the application users, bringing an application to users as fast as possible, being able to adapt as quickly as possible to the market changes, and providing frequent application updates is crucial for the initial success of the product. But it’s also important to understand that an MVP software development is not synonymous with unfinished or a primitive product that was created in a hurry.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3&gt;What is an MVP?&lt;/h3&gt;

&lt;p&gt;Minimum Viable Product (MVP) is the smallest, most concise version of your product you can initially release for feedback. It enables a full turn of the feedback loop with the least amount of development time and effort. This allows the targeted users to try a product and evaluate it to make the complete version better. It is a frequently updated environment with the new features that could be seen and tested by clients. New registration page, an admin management panel, as well as email notifications, and any other new features you can imagine.&lt;/p&gt;

&lt;p&gt;MVP development allows early adopters to understand the vision or promise of the final product and provide valuable feedback to guide developers moving forward. The main advantages of the MVP software development are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;MVP has enough value that people can already use or buy it&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It demonstrates enough features to hook and retain early users&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It provides feedback loop to guide future development&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It shows enough future potential to start marketing around the project&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What’s important - MVP development is not only the strategy for startups. When you already have well-established company and customers, you also need to have some way to experiment with new potential products or features. In a lot of cases, the minimum viable product really is just a way to do that.&lt;/p&gt;

&lt;h3&gt;Few words about F&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://fsharp.org&quot;&gt;F# is a functional-first programming language&lt;/a&gt; running on the .Net platform. Paired with &lt;a href=&quot;https://www.microsoft.com/net&quot;&gt;.Net Core&lt;/a&gt; - modern, cross platform implementation of the .Net Framework - it is fantastic tool for writing modern applications. .Net Core provides industrial level of the performance, security, huge ecosystem of the libraries, and always growing open source community. F#, itself an open source language with fantastic community , thanks to expressiveness, functional-first approach, great developers tooling and advanced language features provides unmatched developer experience and fast development speed, so important for building MVPs. It can also be your secret weapon that makes you stand out from many different companies, and that let you hire more talented people that just want to work with more niche technology.&lt;/p&gt;

&lt;h3&gt;Introducing Saturn&lt;/h3&gt;

&lt;p&gt;F# due to its functional nature is perfect fit for the web applications. In the end HTTP web server may be treated as a function that takes Request and returns Response.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://saturnframework.org&quot;&gt;Saturn&lt;/a&gt; is a modern web framework for the F# focusing on high level abstractions and great developer experience, allowing developers focus on the things that matters for your business. Influenced by the popular frameworks such as Rails or Phoenix it comes with all the batteries included. Its ecosystem includes development tools that allows developers to quickly create new applications, add new features to existing applications, and test new features; it integrates with existing &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-2.1&quot;&gt;ASP.NET Core&lt;/a&gt; ecosystem that provides huge set of existing modules that you can use in your application; it provides pre-defined configurations that limits the number of decisions that developers need to make. And all this while using highly expressive and modern programming language.&lt;/p&gt;

&lt;h3&gt;Typical difficulties&lt;/h3&gt;

&lt;p&gt;While MVP development is really powerful technique, just like every other methodology it has its own drawbacks. First of all you need to understand it’s not about delivering product as fast as possible so customers can try it out. MVP development is about refined and validated learning. This simple fact must be understood by everyone - stakeholders, developers, customers. You have to understand that final product may drastically change due to user’s feedback. And this is something that must be embraced by the development team, and should impact the way in which they work. Developers needs to have regular feedback session, learn from them, prioritise features.&lt;/p&gt;

&lt;p&gt;As a result, this should have an impact on the technologies chosen for developing MVP:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;refactoring plays the key roles, when you see that some part of the product is not scalable or flexible enough, or that it just need changes based on the user’s feedback you need to be able to quickly change an existing code base&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;correctness is important, especially the one you can get for free. Using static type checking, code linting, and code quality tools is crucial to provide product that’s working well enough, without spending much development time on it&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;flexible but simple design - design of your product must be flexible enough to provide ability to change the product based on the feedback, but at the same time it must be relatively simple - for MVP development you want to get to the market as fast as possible, and you don’t want to spend time building sophisticated architecture that may not work after all changes that will happen in the future&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fortunately, F# and .Net Core are great solutions for all those problems - functional first approach naturally pushes you toward pit of success, and simple, flexible architecture, static typing with powerful type inference enables you to create correct software without much overhead, best in class editor tooling helps you to quickly refactor existing code.&lt;/p&gt;

&lt;h3&gt;Commercial support&lt;/h3&gt;

&lt;p&gt;The last important factor in choosing right technology is having an ability to hire someone to develop the product, or just get help. F# ecosystem is including wide range of the options for getting commercial support - starting from the established companies providing support for &lt;a href=&quot;https://safe-stack.github.io&quot;&gt;SAFE Stack&lt;/a&gt; through multiple independent consultants to &lt;a href=&quot;https://lambdafactory.io&quot;&gt;Lambda Factory&lt;/a&gt;. Lambda Factory specialises in creating web applications, F# training and consulting, MVP development, and developer relationships. We provide everything you need to transform your startup into prospecting business - help with creating MVP, iterating over the feedback loop, hiring talented developers, and DevRel marketing.&lt;/p&gt;
</description>
                <pubDate>Thu, 16 Aug 2018 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Building-an-MVP-with-F-and-Saturn</link>
                <guid isPermaLink="true">http://kcieslak.io/Building-an-MVP-with-F-and-Saturn</guid>
                
                <category>F#</category>
                
                <category>Saturn</category>
                
                <category>Web</category>
                
                <category>MVP</category>
                
                
            </item>
        
            <item>
                <title>Challenges of post-OSS world</title>
                <description>&lt;h1&gt;Challenges of post-OSS world&lt;/h1&gt;

&lt;p&gt;Open Source Software has won. After years of convincing people to use open source software, fighting with false dichotomy between OSS and industrial, commercial software, and defending against negative biases, position of OSS is no longer disputed - it’s been used by vast majority of companies around the world, it has become default choice when choosing technologies, it powers the internet, our PCs, mobile phones and most devices we use every day, it’s been accepted by huge, conservative companies that were against whole concept few years ago.&lt;/p&gt;

&lt;p&gt;But have we really been ready for that? For most of its history OSS community was busy fighting for survival. And we created strategy, methodologies, and public relations attitudes that were helping us fight for this survival. But the times have changed and now we face totally different set of problems that we need to solve.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3&gt;Outdated foundations&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;93% - percentage of npm packages with just one maintainer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;General understanding of the mechanism ruling the OSS ecosystem is relatively outdated. As mentioned above - our knowledge about foundation of community based software was shaped when OSS was treated as something bad and undesirable by mainstream programming industry. Organisations like Free Software Foundation, licenses like GPL have their roots in 80s and 90s. The amazing essay *“The Cathedral and the Bazaar” *that has shaped how we understand the community based software was published in 1999. Those were totally different times - when the software market was dominated by companies like IBM, Oracle and Microsoft that were clearly against any ideas of free software. And back then we need different ways of speaking about OSS - the Bazaar analogy was designed to win hearts of the developers, to show that they don’t need to be afraid of the open source software. And it has done that really, really well. However it shouldn’t be used in 2018 as a way of describing how OSS works - we now face different set of issues.&lt;/p&gt;

&lt;p&gt;While many of the ideas from *The Cathedral and the Bazaar” *have aged really well, and still apply to any kind of software development, OSS nowadays is not about creating huge communities, applying “given enough eyeballs, all bugs are shallow” law, or in principle following Bazaar model. On the contrary, given all the success that OSS has achieved the Bazaar model has been unsuccessful - only 3% of popular OSS projects are using such development model. Of course those 3% contains some hugely popular and impactful projects - such as Rails or Linux - but one could argue that they’re using this model as a result of their success and not other way round. In the end, no project starts as a community, there is always someone in charge, and communities around the projects are created only after they are successful.&lt;/p&gt;

&lt;h3&gt;Unlimited growth&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;28 millions of developers - number of registered users at GitHub.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;No-one in the 90s could predict the scale of the success that OSS will achieve. The number of developers doing OSS, number of projects, and number of users has raised by several orders of magnitude over last 20 years. The Bazaar model was created when huge percentage of the people using OSS were people developing OSS. But current state of the world is bit different. Let’s just compare some numbers.&lt;/p&gt;

&lt;p&gt;The number of downloads per 2 weeks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1998 - 180K downloads of Netscape (most popular OSS project at the time)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2017 - 21M downloads of Loadash (random JS library)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The number of registered users:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2001 - 208K on SourceForge&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2018 - 28M on GitHub&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The number of active projects:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2008 - 150K on SourceForge&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2017 - 29M on GitHub&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As we can see, OSS nowadays is massive, global and popular. But there are main 2 issues here. First one is yet increasing fragmentation of the ecosystem - unlike what was presented as big advantage of the Bazaar model, modern OSS is not about creating those singular points of focus for the communities. We don’t get “enough eyeballs”, instead we all rely on the projects that are very often driven forward by single maintainer and one or two other contributors. Second one is that growth of the user-base doesn’t resulted in proportional growth of contributors of the projects. And what’s even more important the growth of the contributors hasn’t resulted in the proportional growth of the maintainers - which results in more and more pressure put on the focal parts of our communities which itself is really huge issue.&lt;/p&gt;

&lt;h3&gt;Maintainers struggle&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;“The more successful you are, the more you get punished with GitHub notifications.” - &lt;a href=&quot;https://nolanlawson.com/2017/03/05/what-it-feels-like-to-be-an-open-source-maintainer/&quot;&gt;What it feels like to be an open-source maintainer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Maintainers are the focal points of the community of any OSS project. Not only they’re often main developers behind the project but also they have many other responsibilities - they need to keep users happy, they need to handle contributors to create good workflow that will enable new code contributions, they need to help first time contributors, they need to review PRs, handle releases, and keep general direction of the project.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Current status - anxious and depressed whenever I open my GitHub notifications. Programming is so much fun”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;However we don’t really get new maintainers too often. The number of users growth really fast, the number of developers grows - and while those 2 things are great, they create huge pressure on the maintainers. And the Bazaar analogy is part of the problem here - we expect someone to always step up, we expect contributors to become more and more involved. But the reality is bit different - 1/2 contributors contributes only once, and they account for around 2% of the commits. And every contribution is additional work for the maintainer, additional PR to review, and additional code to maintain later. Of course, every contribution is valuable, and welcomed but in general OSS community has huge “second time contribution” problem - we put lot of emphasis and work to optimise first contribution experience - but it unfortunately is not resulting in many long standing members of the community.&lt;/p&gt;

&lt;h3&gt;Sustainability&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;$143,000,000 - Estimated value of open source software in $1B Instagram acquisition&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;OSS movement was shaped in the times were most mainstream software was proprietary, it was not vastly used, and no business depended on it. But nowadays, OSS is everywhere - it powers internet, operating systems, software and products we use everyday. It’s hard to imagine building new software without using any OSS technologies and OSS is used by the biggest, most conservative (In terms of technological choices) companies of the world - 100% of Fortune 500 companies are using npm.&lt;/p&gt;

&lt;p&gt;And yet, even some most popular OSS projects ever struggle to get any founding, and build any notion of sustainability. But we continue to build businesses using those tools and libraries. One would hope that in the future we will start to think about open source software in terms of digital infrastructure - that, just like our normal infrastructure, requires constant funding to function properly.&lt;/p&gt;

&lt;h3&gt;How we talk about OSS&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Just like physical infrastructure, digital infrastructure needs regular upkeep and maintenance.” - &lt;a href=&quot;https://www.fordfoundation.org/about/library/reports-and-studies/roads-and-bridges-the-unseen-labor-behind-our-digital-infrastructure/&quot;&gt;Roads and Bridges: The Unseen Labor Behind Our Digital Infrastructure&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Probably to solve some of those problems we need to change a way we talk about OSS - instead of convincing our managers that we need to contribute because it is “good” behavior, or because it will improve “morale” of the team we should talk in business terms - risk and opportunity. Contributing to the projects decrease our risk as a business - it decrease risk that project maintainer will rage quit and we will be stuck with unmaintained project, it decrease risk of needing help of other people if we have some problems with the project. Contributing to the project is also opportunity - we can shape project, add new features that will enable us to make our business solutions better.&lt;/p&gt;

&lt;p&gt;And the other interesting value proposition for contributing to OSS is just plain marketing value - especially if your product targets technical communities. We know live in the times of Developers Relationships movement, were any company building software projects for developers spends lot of resources for promotion. Contributing to OSS is great way of such promotion. And even if your business is not building tools for developers - it will make hiring talented developers way easier.&lt;/p&gt;

&lt;h3&gt;Solutions? I have none&lt;/h3&gt;

&lt;p&gt;I don’t know how to solve the problems of the current OSS world. But it is pretty clear that OSS needs evolve - we need new definitions, new solutions and new leaders for the movement that already changed the world. OSS nowadays struggle with totally different set of the problems than it did 20 years ago, so using the analogies that were used 20 years ago, may not be the way forward. And I do believe that we need to find those solutions pretty fast… or it will turn out that we’ve built our great castle on the sand.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This blog post is adaptation of my “Challenges of post-OSS world” talk I’ve presented on couple of events. If you’d like to have me talk about OSS on your conference and your company feel free to reach me at krzysztof_cieslak@windowslive.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Both talk and this blog post has been deeply influenced by the work of &lt;a href=&quot;https://nadiaeghbal.com/&quot;&gt;Nadia Eghbal&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                <pubDate>Sat, 11 Aug 2018 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Challenges-of-post-OSS-world</link>
                <guid isPermaLink="true">http://kcieslak.io/Challenges-of-post-OSS-world</guid>
                
                <category>Open Source</category>
                
                <category>Community</category>
                
                
            </item>
        
            <item>
                <title>Using OAuth with Saturn</title>
                <description>&lt;h1&gt;Using OAuth with Saturn&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://saturnframework.org&quot;&gt;Saturn&lt;/a&gt; is new F# web framework that provides flexible, high level model of creating web applications using principles of functional programming and MVC architectural pattern. Main design goals of Saturn includes high level abstractions that lets developers focus on creating business code , and general developer experience. One of the features provided by Saturn is support for popular way of authentication - OAuth&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This blog post was created for Saturn version 0.7.5&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;h3&gt;OAuth intro&lt;/h3&gt;

&lt;p&gt;OAuth 2 is an authorization framework that enables applications to obtain limited access to user accounts on an HTTP service, such as Twitter, GitHub, or DigitalOcean. It works by delegating user authentication to the service that hosts the user account, and authorizing third-party applications to access the user account. OAuth 2 provides authorization flows for web and desktop applications, and mobile devices.&lt;/p&gt;

&lt;p&gt;While OAuth supports multiple different types of authorization, useful for different use cases, here we will talk about authorization code flow. The authorization code grant type is the most commonly used because it is optimized for server-side applications (such as web applications using Saturn), where source code is not publicly exposed, and Client Secret confidentiality can be maintained. This is a redirection-based flow, which means that the application must be capable of interacting with the user-agent (i.e. the user’s web browser) and receiving API authorization codes that are routed through the user-agent.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*qH2SyNHvrTa8UR4d8n08pA.png&quot; alt=&quot;Flow of Authorization Code OAuth grant&quot; /&gt;
&lt;em&gt;Flow of Authorization Code OAuth grant&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;First steps&lt;/h3&gt;

&lt;p&gt;The first step in creating application using OAuth is registering application in the OAuth provider. In this example I’ll use GitHub.&lt;/p&gt;

&lt;p&gt;To start off with, you will need to register an application by going to the &lt;a href=&quot;https://github.com/settings/developers&quot;&gt;GitHub Developer Settings&lt;/a&gt;. Click on the button to &lt;strong&gt;Register a new application&lt;/strong&gt;, and complete the information for your application. Specify http://localhost:5000/signin-github as the value for the &lt;strong&gt;Authorization callback URL&lt;/strong&gt; field:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*0Q88p6YUg0ijickJbqZD_g.png&quot; alt=&quot;Register a new OAuth application&quot; /&gt;
&lt;em&gt;Register a new OAuth application&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Take note of the values for &lt;strong&gt;Client ID&lt;/strong&gt; and &lt;strong&gt;Client Secret&lt;/strong&gt;, that will be shown on the next screen after pressing &lt;strong&gt;Register application&lt;/strong&gt; button, as you will need those shortly when registering the OAuth.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Path goes forward&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Next step is creating new Saturn application. This can be easily done using dotnet CLI tool.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir oauthBlogPost
cd oauthBlogPost
dotnet new saturn
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you don’t have Saturn template installed you can get it by running &lt;code&gt;dotnet new -i Saturn.Template&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Next step is installing Saturn.Extensions.Authorization - NuGet package that contains additional helpers for handling authorization, including GitHub provider.&lt;/p&gt;

&lt;p&gt;Open &lt;code&gt;paket.dependencies&lt;/code&gt; and &lt;code&gt;src\oauthBlogPost\paket.references&lt;/code&gt; file and add Saturn.Extensions.Authorization in there. After it’s done run &lt;code&gt;.paket\paket.exe&lt;/code&gt; install and &lt;code&gt;dotnet restore&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you’re on Linux / MacOS you will need &lt;code&gt;mono&lt;/code&gt; to run &lt;code&gt;paket.exe&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Diving deep&lt;/h3&gt;

&lt;p&gt;Now, at last, it’s time to look at some code. Open Program.fs file that contains basic configuration of your Saturn application. Firstly, edit URL to use port 5000. Secondly add new entry in the application block - &lt;code&gt;use_github_oauth&lt;/code&gt;. This custom operation takes couple of input parameters - Client ID, Client Secret, Callback URL, and the list of tuples used to mapping from GitHub’s JSON response to the claims that Saturn understands.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/d32be21f6f55e52ddd09569cd3d5a35e.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Second step is creating pipelines that will handle or require authentication. Create &lt;code&gt;User.fs&lt;/code&gt; file, and add it to &lt;code&gt;.fsproj&lt;/code&gt; file above the &lt;code&gt;Router.fs&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/5b53a1ff47edf5d323d788cce4913934.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;The &lt;code&gt;matchUpUsers&lt;/code&gt; function mock ups check of the data coming from GitHub with your real users database, &lt;code&gt;loggedIn&lt;/code&gt; pipeline forces authentication on the request, and &lt;code&gt;isAdmin&lt;/code&gt; pipeline checks if the request is done by someone with Admin role.&lt;/p&gt;

&lt;p&gt;Now, it’s time to plug it into our routing. Open &lt;code&gt;Router.fs&lt;/code&gt; file. We will create additional router that will display two views - one for logged in user, second one for the admin. Now you need to plug this new router into our top level router - &lt;code&gt;browserRouter&lt;/code&gt; . The last thing you need to do here is also handling the URL that will be called by GitHub after successful authentication. We will redirect it into logged user view.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/0018080f31ac43ed9e9050a72381973d.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Last step is creating some HTML views that we will return to user. Under Templates folder, create &lt;code&gt;UserView.fs&lt;/code&gt; file and add it to &lt;code&gt;.fsproj&lt;/code&gt; as last file in &lt;code&gt;Template/&lt;/code&gt; group.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/71776217054f1f7c935debee60bcb8fe.js&quot;&gt;&lt;/script&gt;

&lt;h3&gt;Light at the end&lt;/h3&gt;

&lt;p&gt;It’s time to run our application. But there is one small step you still need to do. Go to &lt;code&gt;src\oauthBlogPost&lt;/code&gt; folder and run from terminal&lt;code&gt; dotnet saturn migration&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This step is necessary because &lt;code&gt;dotnet new saturn&lt;/code&gt; creates pretty complex application scaffold including connection to local database&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now, from root of your repository, you can run &lt;code&gt;.\build.sh&lt;/code&gt; Run which will start the application. You can go to &lt;a href=&quot;http://localhost:5000/&quot;&gt;http://localhost:5000/&lt;/a&gt; to see standard startup page of the scaffolded application&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/4170/1*IdS_PnUyC_1PRt4C9KpvDw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If you will try to go to &lt;a href=&quot;http://localhost:5000/&quot;&gt;http://localhost:5000/members-only&lt;/a&gt; URL, you will get redirected to GitHub authorization page.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*uJQi6z3zOloSuEpyW9Xl5A.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And after authorization, you’ll get redirected back to our application.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2636/1*u8QOBaA-MVyjrLUB6kSL5A.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can also try going to &lt;a href=&quot;http://localhost:5000/&quot;&gt;http://localhost:5000/members-only/admin&lt;/a&gt; . If you are me (or you’ve updated the code ;-) ) you should see the admin page.&lt;/p&gt;

&lt;h3&gt;End of the way&lt;/h3&gt;

&lt;p&gt;In this post I’ve shown how to introduce OAuth authorization to your Saturn application. As you could see Saturn is using high level, declarative syntax that enables you to plug features like that easily into your application. Currently Saturn.Extensions.Authorization provides predefined authorization providers for Google and GitHub, but more will come to it soon. Feel free to PR your favorite OAuth provider!&lt;/p&gt;
</description>
                <pubDate>Fri, 03 Aug 2018 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Using-OAuth-with-Saturn</link>
                <guid isPermaLink="true">http://kcieslak.io/Using-OAuth-with-Saturn</guid>
                
                <category>F#</category>
                
                <category>Saturn</category>
                
                <category>Web</category>
                
                <category>OAuth</category>
                
                
            </item>
        
            <item>
                <title>Introducing Saturn on Functions</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Azure Functions is a service that provides serverless execution model while running code in the cloud. Serverless model is getting more and more popular nowadays, being great solution for building distributed, scalable, event-driven applications. However, those are not the only use cases - compute-on-demand story, automatic, low friction scalability and great pricing model means that Azure Functions can be used to host normal (REST-ish) APIs.&lt;/p&gt;

&lt;p&gt;On the other hand, Saturn is new F# web framework that provides flexible, high level model of creating web applications using principles of functional programming and MVC architectural pattern. Main design goals of Saturn includes high level abstractions that lets developers focus on creating business code , and general developer experience.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Saturn on Functions&lt;/h1&gt;

&lt;p&gt;Today I want to introduce new extension to Saturn that adds ability to easily host Saturn controllers and routers inside Azure Functions HTTP triggers. Saturn is a library built on top of Giraffe and ASP.NET Core which means it can easily integrate with existing .Net ecosystem. HTTP triggers in Azure Functions as one of the input parameters are getting standard &lt;code&gt;HttpRequest&lt;/code&gt; object that can be passed into Saturn’s &lt;code&gt;controller&lt;/code&gt; or &lt;code&gt;router&lt;/code&gt; (and any other &lt;code&gt;HttpHandler&lt;/code&gt;).&lt;/p&gt;

&lt;h1&gt;Computation Expression&lt;/h1&gt;

&lt;p&gt;To reduce amount of boilerplate required to call any &lt;code&gt;HttpHandler&lt;/code&gt; and provide, in Saturn’s spirit, opinionated way of hosting your controllers in Azure Functions we’ve created &lt;code&gt;Saturn.AzureFunctions&lt;/code&gt; project that adds new computation expression  - &lt;code&gt; azureFunction&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let testCntl = controller {
    index (fun ctx -&amp;gt; Controller.text ctx &quot;Hello world&quot;)
    show (fun ctx id -&amp;gt; id |&amp;gt; sprintf &quot;Hello world, %s&quot; |&amp;gt; Controller.text ctx)
}
let func log = azureFunction {
    host_prefix &quot;/api&quot;
    use_router testCntl
    logger log
    error_handler customErrorHandler
    not_found_handler customNotFoundHandler
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;azureFunction&lt;/code&gt; CE provides set of custom operations that can be used to configure Azure Functions adapter:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;host_prefix&lt;/code&gt;  -  prefix of the routes used by Azure Functions. By default Functions are using &lt;code&gt;/api&lt;/code&gt; prefix.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;use_router&lt;/code&gt;  -  plugs &lt;code&gt;HttpHandler&lt;/code&gt; that will be used. Setting it is required.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;logger &lt;/code&gt; -  enables passing &lt;code&gt;TraceWriter&lt;/code&gt; into your &lt;code&gt;HttpHandler&lt;/code&gt; . It’s passed into your functions by &lt;code&gt;ctx.Items.[&quot;TraceWriter&quot;]&lt;/code&gt; property. It’s also used for logging error in default error handler.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;error_handler&lt;/code&gt;  -  enables plugging custom error handler for unhandled exceptions.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;not_found_handler&lt;/code&gt;  -  enables plugging custom handler for not matched requests.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Using it together&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;azureFunction&lt;/code&gt; CE is transformed into a function that accepts &lt;code&gt;HttpRequest&lt;/code&gt; as an input and returns &lt;code&gt;Task&amp;lt;HttpResponse&amp;gt; &lt;/code&gt; -  something that is understood by Functions runtime, and as such can be easily used in normal Azure Functions endpoint.&lt;/p&gt;

&lt;p&gt;For example using &lt;code&gt;azureFunction&lt;/code&gt; defined above would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;FunctionName(&quot;HelloWorld&quot;)&amp;gt;]
let helloWorld ([&amp;lt;HttpTrigger(Extensions.Http.AuthorizationLevel.Anonymous, Route = &quot;{route?}&quot;)&amp;gt;]req: HttpRequest, log: TraceWriter) =
    func log req
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post I’ve presented new way of hosting your Saturn applications - using Azure Functions. As you can see Saturn will provide easy to use, opinionated way to embed Saturn controllers or routers in Azure Functions providing great, alternative way of hosting your web applications. &lt;/p&gt;

&lt;p&gt;&lt;code&gt;Saturn.AzureFunctions&lt;/code&gt; is currently still developed - if you’d like to check out current implementation, test it, or provide some feedback feel free to check this PR -  https://github.com/SaturnFramework/Saturn/pull/121&lt;/p&gt;
</description>
                <pubDate>Sat, 21 Jul 2018 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Introducing-Saturn-on-Functions</link>
                <guid isPermaLink="true">http://kcieslak.io/Introducing-Saturn-on-Functions</guid>
                
                <category>F#</category>
                
                <category>Saturn</category>
                
                <category>Web</category>
                
                <category>Azure Functions</category>
                
                
            </item>
        
            <item>
                <title>Magic of Saturn controllers</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://saturnframework.org&quot;&gt;Saturn&lt;/a&gt; is new F# web framework that implements well know design pattern - MVC - in more functional way. Despite Saturn being fairly young project it’s getting more and more popular among F# community and industrial users. One of the main Saturn’s goals is to create high level abstractions that will enable developers to focus on writing domain, business code instead of focusing on creating correct routing for your application or setting right response headers. One of such abstractions, that I want to talk about today, is &lt;code&gt;controller&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This article was created for Saturn version 0.7.x&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;h1&gt;Basic usage&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;controller&lt;/code&gt; is simple computation expression (CE) that enables you to easily implement application endpoint following REST-ish conventions. It can be used for implementing endpoints that renders views if you’re building application using server side rendering, or just return serialized data if you’re building API or your application is using client side rendering. Just like all other CEs used in Saturn, &lt;code&gt;controller&lt;/code&gt; provides set of custom operations that you can use. And, what’s important, all operations in &lt;code&gt;controller&lt;/code&gt; CE are optional, which means you can easily choose which subset of functionality you need. Example, basic implementation looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let resource = controller {
    index indexAction
    show showAction
    add addAction
    edit editAction
    create createAction
    update updateAction
    patch patchAction
    delete deleteAction
    deleteAll deleteAllAction
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s now go one by one, and describe each operation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;index&lt;/code&gt; - mapped into &lt;code&gt;GET&lt;/code&gt; request at &lt;code&gt;/&lt;/code&gt; endpoint. Usually used to render a view displaying list of items, or return whole list of items.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;show&lt;/code&gt; - mapped into &lt;code&gt;GET&lt;/code&gt; request at &lt;code&gt;/:id&lt;/code&gt; endpoint. Usually used to render a view displaying details of particular item, or return single item with given id.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;add&lt;/code&gt; - mapped into &lt;code&gt;GET&lt;/code&gt; request at &lt;code&gt;/add&lt;/code&gt; endpoint. Used to render a form for adding new item. Usually not used in API controllers.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;edit&lt;/code&gt; - mapped into &lt;code&gt;GET&lt;/code&gt; request at &lt;code&gt;/:id/edit&lt;/code&gt;. Used to render a form for editing existing item. Usually not used in API controllers.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;create&lt;/code&gt; - mapped into &lt;code&gt;POST&lt;/code&gt; request at &lt;code&gt;/&lt;/code&gt; endpoint. Used to create and save new item.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;update&lt;/code&gt; - mapped into &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;PUT&lt;/code&gt; requests at &lt;code&gt;/:id&lt;/code&gt; endpoint. Used to update existing item. Usually replaces original item (keeping id), and requires are fields to be filled in the incoming item.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;patch&lt;/code&gt; - mapped into &lt;code&gt;PATCH&lt;/code&gt; request at &lt;code&gt;/:id&lt;/code&gt; endpoint. Used to update existing item. Usually only changes some fields of original item, request body contains only changed fields or JSON Patch object.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;delete&lt;/code&gt; - mapped into &lt;code&gt;DELETE&lt;/code&gt; request at &lt;code&gt;/:id&lt;/code&gt; endpoint. Used to delete or deactivate existing item.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;deleteAll&lt;/code&gt; - mapped into &lt;code&gt;DELETE&lt;/code&gt; request at &lt;code&gt;/&lt;/code&gt; endpoint. Used to delete or deactivate all items.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Please remember that Saturn is not enforcing behaviour or inputs of actions any way, so above descriptions are suggestions and best practices, not something that’s encoded in framework. The only thing that controller provides is set in stone routing structure.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;Actions implementation&lt;/h1&gt;

&lt;p&gt;All actions &lt;code&gt;indexAction&lt;/code&gt;, &lt;code&gt;showAction&lt;/code&gt; … are simple F# functions. All of them as first parameter accepts &lt;code&gt;HttpContext&lt;/code&gt; object - it’s an ASP.NET class that contains all information about incoming request, response, server, environment and other data that was injected into it by framework. Actions that are using ID of the item, such as &lt;code&gt;showAction&lt;/code&gt; or &lt;code&gt;editAction&lt;/code&gt; are functions that get &lt;code&gt;id&lt;/code&gt; as a second parameter. The &lt;code&gt;id&lt;/code&gt; may be generic but we currently supports limited set of the possible types to which we can decode ID from URL.&lt;/p&gt;

&lt;p&gt;Supported types:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;char&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;int64&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;float&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;System.Guid&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;In case you’d need some custom ID type, I’d recommend using &lt;code&gt;string&lt;/code&gt; and deserializing it manually. Another important limitation of current controllers is fact that all actions needs to use same ID type in one controller instance. Again, if you’d need different ID types - use &lt;code&gt;string&lt;/code&gt; and deserialize it manually.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example action implementation may look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let myIndex (ctx: HttpContext) = Controller.text ctx &quot;Hello world&quot;

let myShow (ctx: HttpContext) (id: string) =
    id
    |&amp;gt; sprintf &quot;Hello world, %s&quot;
    |&amp;gt; Controller.text ctx

let myController = controller {
    index myIndex
    show myShow
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Action output type&lt;/h1&gt;

&lt;p&gt;If you’ll hover over &lt;code&gt;myIndex&lt;/code&gt; or &lt;code&gt;myShow&lt;/code&gt; you’ll notice that return type of those functions is &lt;code&gt;Task&amp;lt;HttpContext option&amp;gt;&lt;/code&gt;. First thing - all actions in Saturn’s controllers are asynchronous by design, and they are using standard .Net Task to model it. However, they’re generic over what type is actually returned by the task. If you return &lt;code&gt;HttpContext option&lt;/code&gt; you’re following standard path of integration with Giraffe (web library on top of which Saturn is built). This gives you not only full control over what’s going on and how your response is modified, but also provides ability to integrate with existing Giraffe ecosystem. Additionally Saturn itself provides rich set of helpers that return &lt;code&gt;Task&amp;lt;HttpContext option&amp;gt;&lt;/code&gt; in &lt;code&gt;Controller&lt;/code&gt; module (example of this is &lt;code&gt;Controller.text&lt;/code&gt; function used in example, that sets content of the response to given string, and also sets appropriate response header).&lt;/p&gt;

&lt;p&gt;But returning &lt;code&gt;Task&amp;lt;HttpContext option&amp;gt;&lt;/code&gt; is not only option. You can also return &lt;code&gt;Task&amp;lt;'a&amp;gt;&lt;/code&gt; (where &lt;code&gt;'a&lt;/code&gt; is any type) and Saturn will perform automatic output content negotiation. In such case Saturn will check output type of your action, check what’s the client preference based on the &lt;code&gt;Accept&lt;/code&gt; header (if &lt;code&gt;Accept&lt;/code&gt; header is not present, &lt;code&gt;Content-Type&lt;/code&gt; header will be used instead) and decide what’s the best way to handle response object:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If you return &lt;code&gt;string&lt;/code&gt; Saturn will return string with &lt;code&gt;text/plain&lt;/code&gt; or &lt;code&gt;text/html&lt;/code&gt;&lt;code&gt;Content-Type&lt;/code&gt; depending on &lt;code&gt;Accept&lt;/code&gt; header&lt;/li&gt;
  &lt;li&gt;If you return &lt;code&gt;GiraffeViewEngine.XmlNode&lt;/code&gt; (Giraffe’s view object) and client accepts &lt;code&gt;text/html&lt;/code&gt; responses Saturn will render the view and return to client&lt;/li&gt;
  &lt;li&gt;If you return any other type it will be deserialized to JSON (with &lt;code&gt;application/json&lt;/code&gt; &lt;code&gt;Content-Type&lt;/code&gt;) unless client doesn’t accept JSON response - in such case XML will be tried.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Same output content negotiation algorithm is provided by &lt;code&gt;Controller.response&lt;/code&gt; helper.&lt;/p&gt;

&lt;p&gt;Example action implementation using output content negotiation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let myIndex (ctx: HttpContext) =
   task { return &quot;Hello world&quot; }

let myShow (ctx: HttpContext) (id: string) =
    task {
        return sprintf &quot;Hello world, %s&quot; id
    }

let myAdd (ctx: HttpContext) =
    task { return DateTime.Now }

let myController = controller {
    index myIndex
    show myShow
    add myAdd
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;h1&gt;Versioning&lt;/h1&gt;

&lt;p&gt;Versioning of the endpoints is one of the most important cross cutting concernes in web applications… and most of the web frameworks don’t provide any built-in ways to handle it easily. Saturn provides opinionated way to easily version your controllers. Saturn is using &lt;a href=&quot;https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/&quot;&gt;1 of 3 wrong ways&lt;/a&gt; - custom header &lt;code&gt;x-controller-version&lt;/code&gt; to decide which version of the control should be called. Of course, if you don’t like this strategy, Saturn makes it easy to fallback to bit lower level of abstraction, so you can create differently wrong versioning strategy.&lt;/p&gt;

&lt;p&gt;The implementation of versioning in your controllers is trivial - it’s just adding one additional operation to your controllers - &lt;code&gt;version&lt;/code&gt;. Here’s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
let myController = controller {
    index myIndex
    show myShow
    add myAdd
}

let myControllerV1 = controller {
    version &quot;1&quot;

    index myIndex
    show myShow
    add myAdd
}

let appRouter = router {
    forward &quot;/endpoint&quot; myControllerV1
    forward &quot;/endpoint&quot; myController
}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Since controller without version is not performing any checks it’s important to plug controllers in correct order in your router - the controller without any version should go lowest.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;Plugs&lt;/h1&gt;

&lt;p&gt;Another important feature of any web framework is ability of (declaratively) plugging some additional actions/modifications for particular actions in controllers. For example, in ASP .NET MVC this is done with attributes and enables features like authorization and authentication for particular actions in controller (and many, many more other features and cross cutting concerns). Saturn provides flexible mechanism to provide such functionalities using controller plugs, using one simple CE operation - &lt;code&gt;plug&lt;/code&gt; - that accepts list of the actions to which it should apply and the plug function. Plug implementation is any &lt;code&gt;HttpHandler&lt;/code&gt; which means that it integrates well if existing ecosystem and helpers, and plug implementation is decoupled from the controller itself, which means you can easily create plugs for cross cutting concerns such as logging or authorization and reuse them across many controllers in your application.&lt;/p&gt;

&lt;p&gt;Example implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
let myControllerV1 = controller {
    plug [All] (setHttpHeader &quot;user-controller-all&quot; &quot;123&quot;)
    plug [Index; Show] (setHttpHeader &quot;user-controller-some&quot; &quot;456&quot;)
    plug (except Index) (setHttpHeader &quot;user-controller-except&quot; &quot;789&quot;)

    index myIndex
    show myShow
    add myAdd
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Subcontrollers&lt;/h1&gt;

&lt;p&gt;Last important feature of the &lt;code&gt;controller&lt;/code&gt; is ability to embed controllers. This, again, is fairly opinionated feature that follows REST-ish conventions. Subcontroller should be used in case when one particular item (represented in controller by &lt;code&gt;/:id&lt;/code&gt;) has some child items - for example &lt;code&gt;blog&lt;/code&gt; item contains list of &lt;code&gt;post&lt;/code&gt; items. Or &lt;code&gt;post&lt;/code&gt; item contains list of &lt;code&gt;comment&lt;/code&gt; items. Subcontroller is subrouted into &lt;code&gt;/:id/:subcontrollerPath&lt;/code&gt; route of original controller (so for example &lt;code&gt;/:id/:subcontrollerPath/:id2&lt;/code&gt; shows the particular comment, or &lt;code&gt;/:id/:subcontrollerPath/add&lt;/code&gt; will show form for adding new child item to the parent item with given ID). Adding subcontroller to your controller is done by using yet another custom operation in CE - &lt;code&gt;subController&lt;/code&gt; that takes path of the subcontroller and child controller as inputs (passing ID to this subcontroller).&lt;/p&gt;

&lt;p&gt;Example implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let commentController userId = controller {
    index (fun ctx -&amp;gt; (sprintf &quot;Comment Index handler for user %i&quot; userId ) |&amp;gt; Controller.text ctx)
    add (fun ctx -&amp;gt; (sprintf &quot;Comment Add handler for user %i&quot; userId ) |&amp;gt; Controller.text ctx)
    show (fun ctx id -&amp;gt; (sprintf &quot;Show comment %s handler for user %i&quot; id userId ) |&amp;gt; Controller.text ctx)
    edit (fun ctx id -&amp;gt; (sprintf &quot;Edit comment %s handler for user %i&quot; id userId )  |&amp;gt; Controller.text ctx)
}

let userControllerVersion1 = controller {
    subController &quot;/comments&quot; commentController

    index (fun ctx -&amp;gt; &quot;Index handler&quot; |&amp;gt; Controller.text ctx)
    add (fun ctx -&amp;gt; &quot;Add handler&quot; |&amp;gt; Controller.text ctx)
    show (fun ctx id -&amp;gt; (sprintf &quot;Show handler - %i&quot; id) |&amp;gt; Controller.text ctx)
    edit (fun ctx id -&amp;gt; (sprintf &quot;Edit handler - %i&quot; id) |&amp;gt; Controller.text ctx)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;subController&lt;/code&gt; operation actually accepts any &lt;code&gt;HttpHandler&lt;/code&gt; not only controllers, which means you anything in there. Also, you can add multiple subcontrollers to one controller which may be useful… for example in combination with controller versioning feature.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post I’ve tried to present all features and power of Saturn’s high level abstraction - &lt;code&gt;controller&lt;/code&gt;, and flexible design they allow.&lt;/p&gt;
</description>
                <pubDate>Fri, 20 Jul 2018 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Magic-of-Saturn-controllers</link>
                <guid isPermaLink="true">http://kcieslak.io/Magic-of-Saturn-controllers</guid>
                
                <category>F#</category>
                
                <category>Saturn</category>
                
                <category>Web</category>
                
                
            </item>
        
            <item>
                <title>OSS and Community. The Story</title>
                <description>&lt;h1&gt;Disclaimer&lt;/h1&gt;

&lt;p&gt;Before, we even start - this blog post will be different than others on the page. I usually write about some technical things, sometimes about open source and community based software, but I always try to be rather objective. And this post will be different. It’s totally subjective and personal… because it’s about me, and my story with F# Community.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Now&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://www.lambdadays.org/lambdadays2018&quot;&gt;Lambda Days&lt;/a&gt; has ended yet again. It was my 4th times here and as always it delivered - great content, fantastic speakers, interesting conversations, perfect organization. It’s definitely my favorite conference in Europe. And as always I could hang out with some great friends from Community - Evelina and Tomas, Felienne, John, Tomasz, Bartosz and others from polish F# community. The contrast between meeting real people, building cool stuff with F# and fighting random Twitter haters couldn’t be bigger.&lt;/p&gt;

&lt;p&gt;So, I guess you wonder now why I even mention that. “You speak at the many conferences, don’t you? Who cares about this particular one? And you wasn’t even a speaker on this.”. Fair enough. But Lambda Days is special for one small reason - it’s a place where this story has started.&lt;/p&gt;

&lt;h1&gt;Beginning&lt;/h1&gt;

&lt;p&gt;So yeah, it was 3 years ago. Second edition of Lambda Days, first one I’ve attended. I was super excited - it was first FP conference I’ve attended and what’s more there were lot of F# talks happening - Tomas and Evelina were there, as well as Andrea, Tomasz Jaskula and others. And back then I was pretty unknown - I’ve been doing F# for some time already but as a hobby - I’ve been working in some small C# shop, I haven’t been doing any open source stuff, and if anyone heard about me on Twitter… well, let’s just say that I was much harsher in my criticism of MSFT and C# than I’m now :)&lt;/p&gt;

&lt;p&gt;So I was at this conference, ready to watch some talks of people I only knew from online world that were way better developers than me, and were way smarter then me, expecting not to understand too much and maybe learn something interesting… And yeah, they were all that, done great talks, that I totally didn’t understand (I still doesn’t understand their talks, but at least I learnt how to pretend). But it turned out that those F# heroes are not only great developers and super intelligent people, but they are also normal, cool, sometimes wierd people that you can do silly jokes with and you can spend time with them having lot of fun and interesting conversations… not only about F#. So we had lot of fun (as proved by &lt;a href=&quot;fhash.org&quot;&gt;fhash.org&lt;/a&gt;), drunk a lot… and that’s when I’ve fallen in love with F# Community.&lt;/p&gt;

&lt;h1&gt;The Project&lt;/h1&gt;

&lt;p&gt;Soo… 1 month later I’ve started the project, which is now known as Ionide. Of course, Tomas helped me a lot - he suggested to use F# to JS compiler (FunScript) [my initial hack was written in CoffeScript - as it was language suggested for Atom plugins], he’s done some magic to make sure that JS produced by FunScript was working in Atom (FunScript, unlike Fable, was not really producing good JS code). So I started to write this plugin on rather bad platform (Atom extension system sounds cool in theory… but well, it’s just a theory) and at some point of time wierd thing, I still don’t really understand happened - people started to use the project. What’s more shocking - they seemed to like it. A lot. In September I’ve released version 1.0, with new, nice name, webpage and some reddit announcements. What’s even more interesting - people were rather vocal about the fact they’re using Ionide, it got quite a lot of traction in the general F# community. And it resulted in MSFT noticing it. In October 2015 I was invited by VSCode Team to private preview of extension API, and for next month I’ve been working (well… “working”) on the new plugin - Ionide-VSCode - that was publicly released on day 0, during Connect(); conference in November.&lt;/p&gt;

&lt;h1&gt;Side effects&lt;/h1&gt;

&lt;p&gt;Interestingly enough there has been some side effects of making Ionide and getting some users. Firstly, I’ve started my company - &lt;a href=&quot;http://lambdafactory.io&quot;&gt;Lambda Factory&lt;/a&gt; in January 2016 and I’ve started to use F# for commercial work. I’ve also been invited to multiple conferences in 2016 - NDC London, F# eXchange, .Net Fringe (&amp;lt;3), F# Creators Workshop. I’ve been 2 times in Vancouver in 2016 for one of my clients. All those things has been great fun, and are clear result of Ionide - I got my first client thanks to it, my first, really terrible conference talks were about Ionide. In general 2016 was great year - Ionide was getting lot of new features, Fable was released, I’ve ported Ionide to Fable while flying over the Atlantic. And Ionide got lot of users, it was “Featured extension” for a while in VSCode marketplace, it was highest rated extension in VSCode marketplace for a while, and the userbase slowly moved from Atom version to VSCode.&lt;/p&gt;

&lt;p&gt;But it was also a year of several failures in my OSS activity - I haven’t managed to create healthy community around the Ionide - it’s been basically one man show. Some my other OSS projects were not really successful. Forge, which was started in January 2016, has not become a go-to tool for the community. While in case of Forge I can still say about relative success of the project since it’s used to this day in Ionide, the other project I really cared about back then - FsToml - was total failure, and resulted in burnt out, crushed dreams, and broken heart. And well, I was called troll by some members of community for suggesting something like FsToml in one of the blog post.&lt;/p&gt;

&lt;h1&gt;Stabilization&lt;/h1&gt;

&lt;p&gt;My opinions about 2017 are really split - on the one hand it was clearly good year for Ionide - it has become one of the best way to develop F#, and best xplat way. It’s also probably one of the best editor tooling for FP languages in general, and one of the best VSCode extensions in the marketplace (which is decent achievement given that many important VSCode extensions are maintained by MSFT). It got more and more features, including innovating features like CodeLenses and LineLenses, the decently working project explorer, F# Code Outline and many more. And the user base has been constantly growing hitting couple of thousands users according to my estimate (which seems like really decent number given size of F# userbase). It’s also been used by nearly all F# speakers during their talks on various F# conferences and events. And what’s probably most important - thanks to amazing work by Enrico we’ve continuously had best support for .Net Core from any F# IDE - including support for .Net Core 2.0 on the release day.&lt;/p&gt;

&lt;p&gt;For me it was also decent year - I’ve spoken at some great conferences - F# eXchange (again), nCrafts, FableConf, Remmidemi, Get.Net Conf, CodeMotion Milan. I’ve worked on some cool stuff, doing Azure Functions with F# for essentially whole year. I’ve started to move slowly into training market, and I’ve done couple of internal trainings what I’ve really enjoyed and is something I want to focus on in the future.&lt;/p&gt;

&lt;p&gt;But I think it was also bad year in many areas. First of all - Fornax, the F# static site generator I’ve created, didn’t get any attention. Secondly, I didn’t manage to create any good way to sustain Ionide. General atmosphere in F# Twitter community was getting worse and worse due to some vocal minority that’s able only to complain about lack of MSFT investments and lack of quality in tools they get for free. There happened some dramas around F# web stack which was super sad to see. I was not invited to speak at .Net Fringe and Open F# which was really disappointing for me.&lt;/p&gt;

&lt;h1&gt;Current state&lt;/h1&gt;

&lt;p&gt;I really believe into what I’ve written couple of months ago on Twitter - F# ecosystem is in it’s best state in last couple of years (and probably ever). The usages numbers for all main editors are growing, we have some great xplat editor experience with Ionide, F# web stack (SAFE) is getting more and more mature, providing amazing development experience for end-to-end programming. MSFT actions clearly show that they are committed to F# - no one is rewriting language plugin to latest technologies that brings it up-to-date with C# integration, or includes support for Azure Functions, adds F# to &lt;code&gt;dotnet&lt;/code&gt; CLI out of the box, and hire new people to the Team just to stop supporting the language. And I think it’s not the statement I could do 2 years ago.&lt;/p&gt;

&lt;p&gt;At the same time we build castle on the sand - looking at such important parts of F# ecosystem as Ionide, Paket, FAKE, FSAC, Fable, F#.Formatting - I can’t understand why any of those projects don’t have commercial sponsoring. There are tens of thousands of F# users, hundreds of companies using F# for their commercial products. EVERYONE is using those libraries and tools provided by F# community. And no one wants to support those projects. Even if only 1% of companies using F# provided financial support it would make huge difference for those projects. Even if only 1% of F# developers started regularly contribute to OSS libs it would create thriving ecosystem. But I guess doing nothing, using the tools and libraries you get for free, and complaining on social media about quality of ecosystem is what Real Developers creating Real Software do… what do I know, I’m just simple hipster doing OSS :)&lt;/p&gt;

&lt;p&gt;Ionide is in the unsustainable state - over last 3 years I’ve spent thousands of hours working on it. Feel free to calculate how much it would costed if that was tool that your company developed internally. Feel free to calculate how much money you get if you think that Ionide gives you 5% productivity boost… and well, I guess that productivity boost was even higher when you wanted to do .Net Core 2.0 and no other editor supported it :)&lt;/p&gt;

&lt;p&gt;And Ionide is way smaller project than Paket, or FAKE, or Fable… How many hours your developer saved thanks to having actually working dependency management system, reasonable build processes or being able to write front end code in sane, type safe, modern language?&lt;/p&gt;

&lt;p&gt;I guess we all just need to hope that maintainers of those projects will never quit, get bored or decide that they have better things to do in their spare time…&lt;/p&gt;
</description>
                <pubDate>Fri, 23 Feb 2018 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/OSS-The-Story</link>
                <guid isPermaLink="true">http://kcieslak.io/OSS-The-Story</guid>
                
                <category>Open Source</category>
                
                <category>Community</category>
                
                <category>F#</category>
                
                
            </item>
        
            <item>
                <title>Reinventing MVC pattern for web programming with F#</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;A couple of weeks ago, I’ve posted &lt;a href=&quot;https://twitter.com/k_cieslak/status/944349420937793536&quot;&gt;yet-another-controversial-tweet&lt;/a&gt; - this time criticizing F# libraries for web programming and saying that “they focus on wrong problem”. In this post I’d like to expand this thought a bit, describe what is, in my opinion, problem with those libraries, and introduce a project that will try to fix those problems.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;DISCLAIMER: In the original tweet I’ve mentioned three libraries - &lt;a href=&quot;https://suave.io/&quot;&gt;Suave&lt;/a&gt;, &lt;a href=&quot;https://github.com/giraffe-fsharp/Giraffe&quot;&gt;Giraffe&lt;/a&gt;, and &lt;a href=&quot;https://freya.io/&quot;&gt;Freya&lt;/a&gt;. First of all, if we were to talk about all major F# web solutions we should also mention &lt;a href=&quot;https://websharper.com/&quot;&gt;WebSharper&lt;/a&gt;. Secondly, my experience with Freya and WebSharper is fairly limited - I’ve never used any of them in commercial application - so in this post I won’t talk about them but focus on Suave and Giraffe&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;DISCLAIMER 2: I really like both Suave and Giraffe - I’ve been using Suave for years in multiple commercial applications and I think it’s really good project. Also I’ve been investigating and testing Giraffe for last couple of months and I also believe it’s good project with a bright future.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;h1&gt;The model&lt;/h1&gt;

&lt;p&gt;So let’s start with describing a programming model that Suave and Giraffe use. Both libraries are using a really similar model of building applications from small functions that takes &lt;code&gt;HttpContext&lt;/code&gt; as an input and returns a modified &lt;code&gt;HttpContext&lt;/code&gt; and then they use combinators functions to combine those small functions and build application with them. This model is really powerful, it provides full control over the flow of the program, and follows some FP principles (building applications as a composition of functions).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There are some small differences between Suave and Giraffe implementation of this model, but going into such details is not in scope of this post.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;The problem&lt;/h1&gt;

&lt;p&gt;While I love the programming model I also believe that both Suave and Giraffe missed an opportunity to build on top of this model. Helper functions provided by both libraries that are the main building block of the applications are really “low level” - they mostly focus on the details of the HTTP protocol. And I think that while this is an useful level of abstraction for some use cases, my experience with building business applications with Suave / Giraffe suggests that this is not a level of abstraction that’s useful for typical, boring-line-of-business applications - and that’s most common use case for most software developers. If we compare Suave / Giraffe with other ecosystems it often feels like writing ASP.Net applications with just middleware - without using MVC / WebAPI abstractions, or writing Elixir web applications with just Plugs - without &lt;a href=&quot;http://phoenixframework.org/&quot;&gt;Phoenix Framework&lt;/a&gt;. Of course there are cases where this lower level of abstraction is a good choice, but success and popularity of such libraries like &lt;a href=&quot;http://rubyonrails.org/&quot;&gt;Rails&lt;/a&gt;, ASP.Net MVC, or Phoenix shows us that developers want to use some higher level of abstraction and focus on solving their business domain problems instead of worrying about the details of the HTTP protocol.&lt;/p&gt;

&lt;h1&gt;Developer experience&lt;/h1&gt;

&lt;p&gt;The previous paragraph was focused on technical issues but let’s now move to something a bit different. Working on OSS tooling for the last couple of years has thought me one important thing - good user experience is sometimes more valuable for project than technical superiority. I also strongly believe that tooling can be a great way to allow people ramp up faster and to teach users some new concepts. A great example of that is &lt;a href=&quot;https://www.jetbrains.com/resharper/&quot;&gt;ReSharper&lt;/a&gt; - while it’s not super popular in F# community ( ;-) ) and some of the features for C# are probably overkill, I strongly believe that ReSharper is one of the most impactful source of information about new language features for C# developers - not every developer is following all news, conferences and announcements but it’s hard to miss when tool starts to give warnings and shows automatic refactorings introducing new language features. In web space great example for such behavior is Phoenix - everything it does in regards of tooling, from new project template through opinionated structure of the project to generators that let users to scaffold some new controllers is designed to make the introduction of most important concepts used in Phoenix easier for new developer.&lt;/p&gt;

&lt;p&gt;I strongly believe that lack of opinionated tooling and opinionated, commonly used way to build web applications is another important issue of Suave and Giraffe. Developers don’t want to focus on making decisions about structuring the project, or wonder how they need to combine things together, or what are best practices - they want to focus on problems of their business. Again, frameworks like Phoenix and Rails are great example of how having such an opinionated way of building web applications works great in practice.&lt;/p&gt;

&lt;h1&gt;Introducing Saturn&lt;/h1&gt;

&lt;p&gt;For the last couple of weeks I’ve been working on &lt;a href=&quot;https://github.com/SaturnFramework/Saturn&quot;&gt;Saturn&lt;/a&gt; - a new F# OSS project that will attempt to solve the problems mentioned above. It’s strongly inspired by some concepts from Phoenix. Before going into details of Saturn an important thing about it is that it builds on top of the existing ecosystem - and to be precise on top of Giraffe - in similar fashion that Phoenix builds on top of Plugs abstraction.&lt;/p&gt;

&lt;h3&gt;Library&lt;/h3&gt;

&lt;p&gt;A core part of Saturn is a library that can be put on top of any existing Giraffe application. This library contains a set of helper functions, tries to hide some complexity of Giraffe (for example manual passing of &lt;code&gt;next&lt;/code&gt; in every function), and what’s most important it introduces several higher level building blocks that can be used to model a web application. Those building blocks are using a nice high level, declarative DSL using computation expressions with custom keywords. Currently in Saturn there exists 4 such higher level building blocks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pipelines&lt;/li&gt;
  &lt;li&gt;Scopes&lt;/li&gt;
  &lt;li&gt;Controllers&lt;/li&gt;
  &lt;li&gt;Applications&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;and now I shall explain each with a code sample.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;pipeline&lt;/code&gt; - the simplest building block provided by Saturn. It can be used to combine multiple &lt;code&gt;HttpHandlers&lt;/code&gt; in a more declarative way without using custom operators. It also provides custom operations that hide some of the Giraffe complexity.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let browser = pipeline {
    plug acceptHtml
    plug putSecureBrowserHeaders
    fetchSession
    set_header &quot;x-pipeline-type&quot; &quot;Browser&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;scope&lt;/code&gt; - it is a DSL that can be used to define routing and combining this routing together with the &lt;code&gt;pipelines&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let defaultView = scope {
    get &quot;/&quot; (renderHtml Index.layout)
    get &quot;/index.html&quot; (redirectTo false &quot;/&quot;)
    get &quot;/default.html&quot; (redirectTo false &quot;/&quot;)
}

let browserRouter = scope {
    error_handler (renderHtml NotFound.layout) //Use the default 404 webpage
    pipe_through browser //Use the default browser pipeline

    forward &quot;&quot; defaultView //Use the default view
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;controller&lt;/code&gt; - it is a DSL for building typical HTTP controllers. It’s using predefined routing inspired by Phoenix’s &lt;code&gt;resource&lt;/code&gt; macro.s&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let resource = controller {
    index indexAction
    show showAction
    add addAction
    edit editAction
    create createAction
    update updateAction
    delete deleteAction
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;application&lt;/code&gt; - it’s a DSL used for defining application settings and ASP.Net configuration. It aims to replace some cumbersome configuration of some ASP.Net features with declarative feature toggles.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;let app = application {
    pipe_through endpointPipe

    error_handler (fun ex _ -&amp;gt; HttpHandlers.renderHtml (InternalError.layout ex))
    router Router.router
    url &quot;http://0.0.0.0:8085/&quot;
    memory_cache
    use_static &quot;static&quot;
    use_gzip
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important thing about Saturn’s computation expression and those higher level building blocks - &lt;code&gt;pipeline&lt;/code&gt;, &lt;code&gt;scope&lt;/code&gt; and &lt;code&gt;controller&lt;/code&gt; is that they are not introducing any additional abstraction in terms of types - they are transformed to standard Giraffe &lt;code&gt;HttpHandler&lt;/code&gt; which means they are composable with each other and with other, existing &lt;code&gt;HttpHandlers&lt;/code&gt; that you may have.&lt;/p&gt;

&lt;h3&gt;Tooling&lt;/h3&gt;

&lt;p&gt;The other, as important as core library, part of Saturn is additional, opinionated tooling for scaffolding new projects, generating controllers, models, database layer and migration scripts, controlling database migrations etc.&lt;/p&gt;

&lt;p&gt;This tooling comes in 2 parts - first one is a project template that creates default the project structure, and a set of helper files. This is a normal &lt;code&gt;dotnet&lt;/code&gt; project template distributed through NuGet which means you will be able to use &lt;code&gt;dotnet new saturn&lt;/code&gt; to create Saturn applications. The second part of the tooling is a &lt;code&gt;dotnet&lt;/code&gt; extension tool, again, distributed by NuGet. It’s automatically referenced when creating a new Saturn project. So after creating new project you will be able to go to the project folder and run, for example, the &lt;code&gt;dotnet saturn gen&lt;/code&gt; command to generate new controller, views, model and a database layer.&lt;/p&gt;

&lt;h3&gt;Design choices&lt;/h3&gt;

&lt;p&gt;Some parts of the Saturn library and the whole tooling is really opinionated - for example there is no choice to change the way the routing for &lt;code&gt;controller&lt;/code&gt; is created, you can just decide not to implement some of the actions. This may seem restrictive at first, but I strongly believe that it is a good design for the most common use cases. And since everything is based on the composable &lt;code&gt;HttpHandler&lt;/code&gt; model if the default implementation of &lt;code&gt;controller&lt;/code&gt; is not working for you, you can easily recreate it with lower level abstractions such as the &lt;code&gt;scope&lt;/code&gt; DSL.&lt;/p&gt;

&lt;p&gt;Similarly the tooling is really opinionated - the default template out of the box uses &lt;a href=&quot;https://fsprojects.github.io/Paket/&quot;&gt;Paket&lt;/a&gt; for dependency management, &lt;a href=&quot;https://fake.build/&quot;&gt;FAKE&lt;/a&gt; for build script, &lt;a href=&quot;https://github.com/StackExchange/Dapper&quot;&gt;Dapper&lt;/a&gt; for data access, &lt;a href=&quot;https://github.com/canton7/Simple.Migrations&quot;&gt;Simple.Migrations&lt;/a&gt; to handle database migrations. The &lt;code&gt;dotnet saturn&lt;/code&gt; tool generates code assuming certain project structure was created as by the default template, and probably won’t work in other situation.&lt;/p&gt;

&lt;h3&gt;Resources&lt;/h3&gt;

&lt;p&gt;Both Saturn library and tooling are open-source projects that can be found on GitHub and NuGet:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Saturn library - &lt;a href=&quot;https://github.com/SaturnFramework/Saturn&quot;&gt;https://github.com/SaturnFramework/Saturn&lt;/a&gt; and &lt;a href=&quot;https://www.nuget.org/packages/Saturn/&quot;&gt;https://www.nuget.org/packages/Saturn/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Saturn template - &lt;a href=&quot;https://github.com/SaturnFramework/Saturn.Template&quot;&gt;https://github.com/SaturnFramework/Saturn.Template&lt;/a&gt; and &lt;a href=&quot;https://www.nuget.org/packages/Saturn.Template/&quot;&gt;https://www.nuget.org/packages/Saturn.Template/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Saturn &lt;code&gt;dotnet&lt;/code&gt; tool - &lt;a href=&quot;https://github.com/SaturnFramework/Saturn.Dotnet&quot;&gt;https://github.com/SaturnFramework/Saturn.Dotnet&lt;/a&gt; and &lt;a href=&quot;https://www.nuget.org/packages/Saturn.Dotnet/&quot;&gt;https://www.nuget.org/packages/Saturn.Dotnet/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Saturn sample project created using template and generator tool - &lt;a href=&quot;https://github.com/SaturnFramework/Saturn.Sample&quot;&gt;https://github.com/SaturnFramework/Saturn.Sample&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post I’ve tried to point out some problems of Suave and Giraffe and explain why I’ve decided to create new library for web programming with F#.&lt;/p&gt;
</description>
                <pubDate>Thu, 25 Jan 2018 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/Reinventing-MVC-for-web-programming-with-F</link>
                <guid isPermaLink="true">http://kcieslak.io/Reinventing-MVC-for-web-programming-with-F</guid>
                
                <category>F#</category>
                
                <category>Saturn</category>
                
                <category>Web</category>
                
                
            </item>
        
            <item>
                <title>Path to Community based Open Source Software</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Open Source movement has changed the software development world as much as only few things before. Nowadays, it’s almost impossible to develop any project without using OSS - we can be sure that some parts of our stack are developed in the open - from the libraries we download from the package managers, through runtime, to compilers that we are using. Even most conservative, and not-so-long-time-ago actively hostile to OSS companies are now trying to embrace Open Source development.&lt;/p&gt;

&lt;p&gt;But putting code in open by uploading to GitHub, using one of the licenses formally accepted by the &lt;a href=&quot;https://opensource.org/&quot;&gt;Open Source Initiative&lt;/a&gt; is just first step. In my opinion, the real value of the Open Source is not just license, and publicly available code (although, those things are also valuable on their own) but rather possible change in governance model, collaboration with Community and embracing “OSS Culture”.&lt;/p&gt;

&lt;p&gt;In this post I’ll describe different “stages of enlightenment” that company can go through in its path to the Open Source development model that will bring most value to both company and community.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Open Source License&lt;/h1&gt;

&lt;p&gt;Even though, as I’ve mentioned I believe that embracing OSS goes much beyond just having OSS license we can’t really forgot about importance and impact of it. Having OSS license is necessary condition for any project that wants to be called OSS projects. There exist formal definition created by Open Source Initiative called &lt;a href=&quot;https://opensource.org/docs/osd&quot;&gt;Open Source Definition&lt;/a&gt; that sets strict rules that license must follow to be called OSS license.&lt;/p&gt;

&lt;h1&gt;Stage 1 - Code dump&lt;/h1&gt;

&lt;p&gt;At this level, company publishes online projects that its no longer going to invest into or maintain. Probably project failed, was deprecated, or is not profitable. Usually it means that company is no longer interested in the code base - there will be no maintainers, no merged PRs, no responses to issues, and no updates. Rarely, it’s desperation step and company is trying to save project… more often company is trying to save itself from outrage of existing community and userbase after cancelling product. The only way it can end well is when there already exist active project community that will fork project, and continue to maintain project. And usually that’s not a case - since product was developed as a closed sourced project it usually don’t have huge community of developers that are engaged enough to pick up dropped ball.&lt;/p&gt;

&lt;h1&gt;Stage 2 - Open facade&lt;/h1&gt;

&lt;p&gt;In this model company still actively develops the application. Publicly available code is updated regularly, some people from the company are responding to the issues (it’s often used only as a public bug tracker). But all decisions, discussions about new features, bug fixes are done internally in company using private communications channels - community has no impact on the direction of the product, communication is often only one-way - community tries to give it feedback, and suggest way forward but usually there is no respond from the company (even if some of those suggestions are taken into account by some members of the development team), PRs are ignored or actively discouraged. In terms of building community this level is often even worse than previous stage - at least fact that no one cares about project forces the community to step up (if there is need for the project), in this stage community is discouraged to do anything - it has no impact, and someone else is developing the project. In longer term it’s really bad - it creates community that is 100% reliant on the company building the product, and that is unable to step up when needed (for example to extend ecosystem of the project).&lt;/p&gt;

&lt;h1&gt;Stage 3 - Development in the open&lt;/h1&gt;

&lt;p&gt;That’s the level when company can see first real advantages of the Open Source methodologies, it’s also level where most companies trying to embrace OSS are at. In this stage company develops product in the open - code development is done directly on GitHub (or other provider), discussions about product future (or at least some of them) are done using public channels such as issues. Bug reports are treated seriously, feature requests are discussed in with the community in the public, PRs are getting accepted as long as they follow the direction of the project set by company. This level creates decently engaged community - even though community and external developers can’t dictate future of the project, and direction it’s going to be developed in they still can at least quickly fix the bugs and problems they encounter. They also feels that company is taking their feedback seriously - as long as the communication works decently, most external developers can understand why some features are not going to be implemented, or they are not priority. Company can expect decent feedback focused on the technical level - the implementation details, as that’s something that’s focus point of the community. However, communication is still mostly “initialized” by the community - they report bugs, or suggest feature requests and then development team from the company responds to that. Also the company goals are still focal point of the development - they dictate development plans and what feature requests are accepted.&lt;/p&gt;

&lt;h1&gt;Stage 4 - Enlightened despot&lt;/h1&gt;

&lt;p&gt;At this level company starts to understand that short term business goals are less important for the success than long term growth of the community. In terms of development practices it’s really similar to previous level - development is done in the open, things are discussed in public channels, PRs are getting accepted. The difference is really subtle but important - the company is actively trying to look for the feedback about product future (and not only particular features), communication is often initialized by development team, the short term road maps (for example monthly iteration plans) are published so the community knows what the development team is going to focus on. The project is still in the formal control of the company (only members of the company have write access to the repository) but the product is developed with community being focal point of the process. This model creates really engaged community as it puts lot of weight on communication with community. It also makes community feel that it has real impact on the project and that company cares not only about business goals but also abut growth of ecosystem. In this model company can expect lot of really good feedback (both positive and negative), which increases chances of making right decisions about everything… from general decisions about project future to implementation details.&lt;/p&gt;

&lt;h1&gt;Stage 5 - Community based Open Source&lt;/h1&gt;

&lt;p&gt;At this stage company not only focuses on the community, it becomes part of the community equals to all other contributors. Decisions are made by consensus between all parts of the community. The write access to repository is given to the external developers that are not hired by the company, developers that are hired by the company are not getting automatically write access just because they are hired - they need to follow same path as any other member of the community, proof to be a good actor in the community. Community starts to self govern itself - there no longer exist one entity that’s formally more important than other parts of the community. There are no private communication channels as every member of the community has access to information. Really often general project roadmaps stops existing - there is no way of forcing everyone in the community to work on some particular set of features, people tend to work on features they want to have implemented (of course, as long as they are in the scope of the projects and community generally agrees that it’s needed feature). This model brings to the project not only great discussions, great developers (that you wouldn’t necessarily be able to hire) but also great leaders, maintainers and evangelists - people that really care about your project, that will be willing to spend lot of time and effort to develop product and its ecosystem.&lt;/p&gt;

&lt;h1&gt;Problems with embracing Community based OSS&lt;/h1&gt;

&lt;p&gt;Companies are often really afraid of the governance model in which they give up parts of their privileges connected with absolute power over the project. They often state that they need to maintain control to make sure that the product will be developed in right direction (even if they are OK with putting community in the center of this direction, or at least consult it with community). I believe that there are two points that are often missed when this argument is raised. First of all - development team hired by the company still can focus on those features, and those parts of the project that are most important for your business - company still can have its roadmaps and plans that are important for hired development team. Secondly, if we assume that whole community will agree on given direction, community itself will be the best entity that will ensure that product is developed in direction that was agreed on by all parts. As long as the company understands that growth of the community and ecosystem is good for the business in long term, everything should be fine.&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this blog post I’ve described several different models for embracing Open Source development methodologies. I belive that it’s clear that even though putting code in public with OSS license is good move, the real power of the OSS is collaboration with the community - and more effort is put into this collaboration, more control is given over to communing, the better results will be - from creating really engaged user base that cares enough to report bugs and suggest new features on its own, through getting some technical feedback and small bug fixes, to creating real self governing community that will create its own leaders, and evangelists, that will include some people that you couldn’t bring to project otherwise.&lt;/p&gt;

</description>
                <pubDate>Mon, 12 Jun 2017 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Path-to-community-based-OSS</link>
                <guid isPermaLink="true">http://kcieslak.io/Path-to-community-based-OSS</guid>
                
                <category>Open Source</category>
                
                <category>Community</category>
                
                
            </item>
        
            <item>
                <title>Using Paket with Azure Functions</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://azure.microsoft.com/en-us/services/functions/&quot;&gt;Azure Functions&lt;/a&gt; is Microsoft’s implementation of serverless architecture hosted on Azure. It is a solution for easily running small pieces of code, or “functions,” in the cloud. You can write just the code you need for the problem at hand, without worrying about a whole application or the infrastructure to run it. Functions can be written in many different languages, including F#.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Workflow problem&lt;/h1&gt;

&lt;p&gt;Azure Functions can be developed using online editor avaliable on Azure Portal - unfortunetlly it doesn’t provides any rich editing features (autocomplete, tooltips etc) we all like in our normal editors. Luckily, Azure Functions can be also created (and tested) locally, and configured to use GitHub repository (or couple other sources) as source of code, creating very nice Continues Deployment process (coding on local machine -&amp;gt; pushing code to GitHub -&amp;gt; deployment to Azure is automatically triggered). This way we should be able to use our rich editor tooling to develop Functions.&lt;/p&gt;

&lt;p&gt;However, there is small problem. For sake of simplicity, dependency menagment in Azure Functions is using quite a lot of &lt;em&gt;magic&lt;/em&gt;. Essensially, all you need to do is create &lt;code&gt;project.json&lt;/code&gt;, put there your dependency… and then you can just put &lt;code&gt;#r dependency_name&lt;/code&gt; in your deployed &lt;code&gt;.fsx&lt;/code&gt; file to reference it. But as we know, that’s not exactly how things work in normal F# scripting - usually we need to add relative path to &lt;code&gt;.dll&lt;/code&gt;, not just a name of reference. What’s more I haven’t found a way to restore dependencies using Azure Functions CLI tool (which follows Microsoft’s tradition of calling totally unusable software &lt;code&gt;beta&lt;/code&gt;).&lt;/p&gt;

&lt;h1&gt;Paket Strikes Back&lt;/h1&gt;

&lt;p&gt;Instead of fighting with bad workflow suggested by Microsoft, I’ve decided to do what F# developers usually do - use created by Community tool. And our solution to dependency management problem is &lt;a href=&quot;https://fsprojects.github.io/Paket/&quot;&gt;Paket&lt;/a&gt;
We normally initialize Paket, put &lt;code&gt;paket.bootstraper.exe&lt;/code&gt; in &lt;code&gt;.paket&lt;/code&gt; folder, create &lt;code&gt;paket.dependencies&lt;/code&gt; file, install dependency. Thanks to that we can use &lt;code&gt;#r&lt;/code&gt; reference with relative path to our dependency (which is downloaded to packages folder). For example: &lt;code&gt;#r &quot;../packages/Tesseract/lib/net45/Tesseract.dll&quot;&lt;/code&gt;. This let us to use full power of our editors to develop Azure Functions locally.&lt;/p&gt;

&lt;h1&gt;Deployment to Azure&lt;/h1&gt;

&lt;p&gt;Now we need to force Azure to run Paket after deploying code from our repository to cloud. Doing it is fairly simple, but not documented too well.&lt;/p&gt;

&lt;p&gt;First of all, in root of our repository we create &lt;code&gt;build.cmd&lt;/code&gt; file running Paket.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;@echo off
cls

.paket\paket.bootstrapper.exe
if errorlevel 1 (
  exit /b %errorlevel%
)

.paket\paket.exe restore --force
if errorlevel 1 (
  exit /b %errorlevel%
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second step is using deployment configuration file to run our &lt;code&gt;build.cmd&lt;/code&gt;. We create &lt;code&gt;.deployment&lt;/code&gt; file and add there following entry:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[config]
SCM_POST_DEPLOYMENT_ACTIONS_PATH = ../wwwroot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It configures where deployment utility will look for any post deployment scripts (and &lt;code&gt;.cmd&lt;/code&gt; file) after cloning and coping our repository. &lt;code&gt;wwwroot&lt;/code&gt; is root folder which will contain our Function after deployment.&lt;/p&gt;

&lt;p&gt;Having those 2 files, we can push code to GitHub, go to Azure Portal, check deployments of our Function App. If everything is OK we should see Paket output in post deployment actions log.&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post, I’ve presented how to use Paket together with Azure Functions to create nice workflow for developing applications using this modern platform. The sample code can be found on GitHub - https://github.com/Krzysztof-Cieslak/AzureFunctionsSamples&lt;/p&gt;
</description>
                <pubDate>Tue, 22 Nov 2016 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/Using-Paket-with-Azure-Functions</link>
                <guid isPermaLink="true">http://kcieslak.io/Using-Paket-with-Azure-Functions</guid>
                
                <category>F#</category>
                
                <category>Paket</category>
                
                <category>Azure Functions</category>
                
                
            </item>
        
    </channel>
</rss>