<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>F# Reflections</title>
        <description>Blog about F# and FP Programming</description>
        <link>http://kcieslak.io/</link>
        <atom:link href="http://kcieslak.io/feed.xml" rel="self" type="application/rss+xml"/>
        <pubDate>Sun, 16 Jun 2019 14:17:21 +0200</pubDate>
        <lastBuildDate>Sun, 16 Jun 2019 14:17:21 +0200</lastBuildDate>
        <generator>Jekyll v3.3.1</generator>
        
            <item>
                <title>Ionide — Introducing Info Panel</title>
                <description>&lt;h1&gt;Ionide — Introducing Info Panel&lt;/h1&gt;

&lt;p&gt;Today, I’d like to talk about a new feature called the Info Panel that has been
released in Ionide 3.36. For me personally, it’s one of the most exciting
features we’ve introduced in Ionide so far. Hopefully, it will help F#
developers as nicely as placing function signatures in CodeLenses or fast
cross-project navigation powered by background symbol caches.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h4&gt;The problem of API exploration&lt;/h4&gt;

&lt;p&gt;One of the biggest problems some software developers have is remembering all the
functions, classes, and namespaces that are available in a vast set of
dependencies they use, or even that are present in their code bases. Some IDEs
try to help with that problem via tooltips or IntelliSense.&lt;/p&gt;

&lt;p&gt;However, these solutions suffer from two problems. First, the visual help they
have is temporary. Second, tooltips can sometimes feel intrusive. It’s sometimes
quite common to have something pop up and hide code below it, and if you move
your cursor the information changes are disappears.. Also, tooltips or
additional IntelliSense popups are typically small — the IDE has to play a
tricky game of tightrope where it needs to display useful information, but do so
subtly enough not to feel intrusive.&lt;/p&gt;

&lt;p&gt;One alternative to an Info Panel exists in Visual Studio today, called the
Object Browser. It’s a separate window that presents a tree view of references
to a project where you can dive into constructs as-represented in their compiled
form. Although this is helpful for exploring references, it’s conceptually
detached from your codebase. Imagine a situation when you’re reading your code
and notice a function call that you don’t understand — it’s not as easy to use
Object Browser as just hover over the symbol — you need to click through library
content, to find appropriate class or function. And if you want to move to
another function next line, you need to do the same.&lt;/p&gt;

&lt;h4&gt;Rich API exploration&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;The Info Panel is inspired by &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/ToolsLanguages/Conceptual/Xcode_Overview/LookingupObjectDocumentation.html&quot;&gt;XCode’s Quick Info
Inspector&lt;/a&gt;.
Thanks a lot to Dave Thomas for familiarizing me with this feature. BTW, you can
support Dave — one of the best F# OSS hackers — on his &lt;a href=&quot;https://www.patreon.com/7sharp9&quot;&gt;new Patron
page&lt;/a&gt;!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1000/1*G5A8JkkI0bIa4iK4M49CEA.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Info Panel is an attempt to bridge those two ways of presenting information. It
combines the interactivity of tooltips with the less intrusive UI of a separate
display panel. The panel auto-updates as you navigate through your code, but you
can also navigate information via the panel, independently of the code you’re
looking at.&lt;/p&gt;

&lt;p&gt;By opening the Info Panel in VSCode, you can display rich information about the
current symbol under your caret, such as its signature, nicely formatted XML
documentation, its members, properties or functions, used attributes,
implemented interfaces. Because it’s a separate panel, the information is
persisted and doesn’t overlap with your code window. There is enough space to
provide quite a lot of nicely formatted information. It also supports link
navigation. For example, if somewhere in the documentation &lt;code&gt;DateTime &lt;/code&gt;is
present, you can click on it, and move to the documentation about the &lt;code&gt;DateTime
&lt;/code&gt;type. The Info Panel uses a combination of data from the compiler service and
XML documentation, so it works for both external dependencies and your own code.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1000/1*_R6bkfNHTGVXVqAK01lHbg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Info Panel may update its content on the cursor move or on the hover (it’s
configurable) but also supports locking — the state in which the content won’t
be updated by normal action but only by click link or forcing update with a
command. This means that you can keep information that is interesting for you
while moving through a code base.&lt;/p&gt;

&lt;p&gt;One of the additional options is complete replacing tooltips — when it’s
activated you won’t see normal tooltips when you put the mouse over the symbol,
only Info Panel will be updated (feature &lt;a href=&quot;https://twitter.com/strmpnk/status/1123042142694383617&quot;&gt;suggested by Brian
Mitchell&lt;/a&gt;).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Check all possible options for Info Panel in VSCode — they all start with
&lt;code&gt;FSharp.infoPanel&lt;/code&gt; prefix&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;What’s next?&lt;/h4&gt;

&lt;p&gt;Info Panel is in pretty good shape today however there are still a couple more
features that I want to add in a future:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Handling namespaces — currently we don’t display any information for namespaces.&lt;/li&gt;
  &lt;li&gt;Navigation history — I think it would be nice if go back/forward commands were
implemented&lt;/li&gt;
  &lt;li&gt;Navigation breadcrumb — breadcrumb UX in VSCode is pretty nice for navigating
through the code base, I can imagine having something like that for the
documentation exploration. (suggested by Nino Floris)&lt;/li&gt;
  &lt;li&gt;More information for the symbols — we could potentially add even more
information such as inheritance hierarchies, declaring entities etc.&lt;/li&gt;
  &lt;li&gt;Investigate how Info Panel can be used for replacing/enhancing IntelliSense&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you’d be interested in helping there are two places where you can start:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If you’d want to improve generated documentation take a look
&lt;a href=&quot;https://github.com/fsharp/FsAutoComplete/blob/master/src/FsAutoComplete.Core/DocumentationFormatter.fs&quot;&gt;here&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;If you’d want to improve UX around the feature take a look
&lt;a href=&quot;https://github.com/ionide/ionide-vscode-fsharp/blob/master/src/Components/InfoPanel.fs&quot;&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Summing up&lt;/h4&gt;

&lt;p&gt;I really hope you will like this feature — from my point of view, it fits into
Ionide design of finding good ways to provide as much useful information as
possible to the users — such as Code Lenses or rich tooltips we have right now.
Try it out, and let us know what you think!&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;You can support Ionide development on *&lt;a href=&quot;https://opencollective.com/ionide&quot;&gt;Open
Collective&lt;/a&gt;&lt;/em&gt;.*&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1000/1*Qp7ewxpBdpWJjHVtRHEEPw@2x.png&quot; alt=&quot;https://opencollective.com/ionide&quot; /&gt;&lt;/p&gt;
</description>
                <pubDate>Mon, 06 May 2019 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Ionide-Introducing-Info-Panel</link>
                <guid isPermaLink="true">http://kcieslak.io/Ionide-Introducing-Info-Panel</guid>
                
                <category>F#</category>
                
                <category>VS Code</category>
                
                <category>Tooling</category>
                
                
            </item>
        
            <item>
                <title>Ionide — A New Hope</title>
                <description>&lt;h1&gt;Ionide — A New Hope&lt;/h1&gt;

&lt;p&gt;You probably know that one of my &lt;a href=&quot;http://kcieslak.io/Future-of-F-Cross-platform-editor-tooling&quot;&gt;biggest
problems&lt;/a&gt;
with the F# ecosystem and OSS work I’ve been doing has been lack of any
sustainability strategy. I’ve attempted to change that by creating &lt;a href=&quot;https://opencollective.com/ionide&quot;&gt;Open
Collective page for the Ionide&lt;/a&gt;,
and at the same time, I’ve started talking with existing partners about possible
ways of making work on this crucial parts of the ecosystem more sustainable.&lt;/p&gt;

&lt;p&gt;Today, I’m really happy to announce that for the next few months I’ll be working
full time on the F# open source, cross-platform tooling focusing mainly on
&lt;a href=&quot;https://github.com/ionide&quot;&gt;Ionide&lt;/a&gt; and
&lt;a href=&quot;https://github.com/fsharp/FsAutoComplete&quot;&gt;FsAutoComplete&lt;/a&gt;. This is possible
thanks to the partnership between my company — &lt;a href=&quot;https://lambdafactory.io/&quot;&gt;Lambda
Factory&lt;/a&gt; — and Microsoft.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3&gt;Scope of the work&lt;/h3&gt;

&lt;p&gt;The contract with Microsoft will enable me to work on certain strategic goals of
the Ionide and FsAutoComplete that are important for both the F# community and
Microsoft. Our initial goals for the next few months are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Finishing &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;Language Server
Protocol&lt;/a&gt; (&lt;a href=&quot;https://medium.com/lambda-factory/future-of-f-cross-platform-editor-tooling-a8cf62a50053&quot;&gt;read more
about
LSP&lt;/a&gt;)
implementation in FSAC and plugging it into Ionide&lt;/li&gt;
  &lt;li&gt;Fix performance reliability issues after triage and full performance
rebaselining after LSP support is in&lt;/li&gt;
  &lt;li&gt;Work on porting all components to .Net Core/Standard and using .Net Core version
of FSAC by default in Ionide to improve the getting started experience&lt;/li&gt;
  &lt;li&gt;A potential stretch goal is working on improvements to the scripting experience
in Ionide&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These goals are trying to tackle some of the most important issues of the F#
cross-platform tooling ecosystem, and will benefit not only Ionide but will have
an impact on other tools that F# developers use every day.&lt;/p&gt;

&lt;h3&gt;Relationship with Open Collective&lt;/h3&gt;

&lt;p&gt;I’ve been asked by some people who heard the news a few days ago if this affects
the Ionide OpenCollective effort. In short, no, but I’ll clarify some specifics.&lt;/p&gt;

&lt;p&gt;From my point of view, this doesn’t change anything with respect to
OpenCollective. One of the reasons why we’ve decided to choose Open Collective
(over Patreon or PayPal donations) is the fact that it’s about supporting the
project, not any particular creator. Open Collective is a fund for the Ionide
project itself, with a transparent invoice system that ensures any withdrawals
are public. This allows any Ionide contributor, not just me, to spend dedicated
time on the project in the future. It is a long-term sustainability plan for
Ionide.&lt;/p&gt;

&lt;p&gt;Contract with Microsoft is task-based — hopefully, it will result in fixing some
of the biggest issues with the Ionide and FSAC that we have right now but is not
creating long term sustainable environment — something I want to create with
Ionide as an organization and with Open Collective.&lt;/p&gt;

&lt;p&gt;I hope that F# community will continue supporting Ionide on Open Collective as
generously as right now — and I hope that soon, I’ll be able to do some
announcements about how we will spend those funds on the project related goals
such as promotion, documentation and more. But that will come later, as I’ll be
quite busy in the coming months improving Ionide by working with Microsoft.&lt;/p&gt;

&lt;h3&gt;But Embrace, Extend, and Extinguish…&lt;/h3&gt;

&lt;p&gt;Ionide is still and always will be MIT licensed project owned by F# community,
and FsAutoComplete is and will always be Apache 2.0 licensed project owned by F#
Software Foundation.&lt;/p&gt;

&lt;p&gt;Microsoft is not acquiring Ionide, nor is there any additional stipulations or
attempts to re-prioritize the direction of the Ionide project. In fact, I was
asked to help define the scope of the work and I’ll be helping decide what the
most important issues are to fix. To be clear, Microsoft is not gaining control
on Ionide, and they don’t gain any decision making power different than regular
F# users. Ionide is still a community project and the maintainers continue to
decide what gets added or removed.&lt;/p&gt;

&lt;h3&gt;Next few months will be fun…&lt;/h3&gt;

&lt;p&gt;I need to say that I’m really really happy to have this opportunity — for last
few years I’ve been saying that it would be really good for an ecosystem if
someone was working full time on F# cross-platform tooling. &lt;br /&gt; My goal for the
last few years has been pointing out that there is huge potential in F#
cross-platform tooling, in VSCode as an IDE platform, in F# Compiler Services
that’s the common infrastructure used by all F# tooling, and that’s been fairly
unique project among Functional Programming languages. I really believe that we
can make F# tooling best-in-class (of FP languages), and I hope that the
partnership with Microsoft is a step in this direction. However, we still need
to remember that F# tooling is owned by the F# community and only together we
can make it better so… contributions are welcomed!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Additionally, I need to thank Phillip Carter (F# PM @ Microsoft), without his
help, and his advocating for F# inside Microsoft things like that would never be
possible. Thanks!&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                <pubDate>Sun, 24 Mar 2019 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/Ionide-New-Hope</link>
                <guid isPermaLink="true">http://kcieslak.io/Ionide-New-Hope</guid>
                
                <category>F#</category>
                
                <category>VS Code</category>
                
                <category>Tooling</category>
                
                
            </item>
        
            <item>
                <title>PureScript on Azure Functions</title>
                <description>&lt;h1&gt;PureScript on Azure Functions&lt;/h1&gt;

&lt;p&gt;Serverless architecture is one of the hottest topics in cloud computing,
allowing developers to build and run applications and services without thinking
about the servers actually running the code, providing a scalable model for
building distributed, event-driven systems, as well as significantly reducing
operational costs.&lt;/p&gt;

&lt;p&gt;Microsoft’s take on the serverless problem is service called &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/azure-functions/&quot;&gt;Azure
Functions&lt;/a&gt;. Out of the
box, it supports .Net languages (C# and &lt;a href=&quot;https://fsharp.org/&quot;&gt;F#&lt;/a&gt;), Python, Java
and JavaScript. The last one is very important, as nowadays there exist a wide
variety of languages that can compile down to JS. And today, I’ll talk about one
of such languages — PureScript.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.purescript.org/&quot;&gt;PureScript&lt;/a&gt; is a strongly-typed, purely functional
programming language heavily inspired by &lt;a href=&quot;https://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt;. It
supports a set of advanced language features such as higher kinded types, type
classes, row polymorphism and many other features I don’t understand.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h4&gt;Requirements&lt;/h4&gt;

&lt;p&gt;To get started with Azure Functions and PureScript you need to install several
dependencies. First of all, you need &lt;a href=&quot;http://nodejs.org/&quot;&gt;Node.JS and NPM&lt;/a&gt; as it
is the runtime for Azure Functions, and is used by the PureScript toolchain.
Secondly, you need PureScript itself — you can download and install it using npm
with &lt;code&gt;npm install -g purescript&lt;/code&gt;. Next thing is some additional PureScript
tooling, you can get it with &lt;code&gt;npm install -g bower pulp&lt;/code&gt;. In the end, you also
need to install Azure Functions tooling that will enable you to build and test
your serverless application locally. This tooling can be found on GitHub —
&lt;a href=&quot;https://github.com/Azure/azure-functions-core-tools&quot;&gt;https://github.com/Azure/azure-functions-core-tools&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;Getting Started with Azure Functions&lt;/h4&gt;

&lt;p&gt;We will start by creating a simple JS function. In the local folder run &lt;code&gt;func
init MyFunctionProj&lt;/code&gt;. When prompted, use the arrow keys to select a &lt;code&gt;node&lt;/code&gt;
worker runtime from the language choices. This will create a new folder and a
new NodeJS Function Application inside. Inside the new folder initialize new NPM
project in it with &lt;code&gt;npm init&lt;/code&gt;. After you’re done with answering all the prompts,
we will create our first endpoint — &lt;code&gt;func new — name MyHttpTrigger — template
“HttpTrigger”&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Without going into details, Azure Functions is an event-driven system that
supports multiple different types of triggers and bindings. The template we’ve
chosen will create simples possible function that is triggered by an HTTP
request and returns an HTTP response. If you want to learn more about possible
triggers and bindings visit Azure Function documentation —
&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings&quot;&gt;https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After all those operations are done you should have following folder structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyFunctionProj
 | — MyHttpTrigger
 | | — index.js
 | | — function.json
 | — node_modules
 | — host.json
 | — package.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can now test your first Azure Function! Run in terminal &lt;code&gt;func host start&lt;/code&gt;
and wait a moment. After everything is initialized you should see (among other
things something like: &lt;code&gt;MyHttpTrigger: [GET,POST]
http://localhost:7071/api/MyHttpTrigger&lt;/code&gt;. You can now visit this URL and see
some output in the browser.&lt;/p&gt;

&lt;h4&gt;Adding PureScript to the mix&lt;/h4&gt;

&lt;p&gt;Adding PureScript to your project is fairly simple, and just requires some small
changes to the project files. Firstly, still in the same directory, let’s create
new PureScript project — &lt;code&gt;pulp init — force&lt;/code&gt;. (You need to use &lt;code&gt;— force&lt;/code&gt; flag as
there already exists &lt;code&gt;.gitignore&lt;/code&gt; file in the folder). Your directory should now
contain several additional elements:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;bower.json&lt;/code&gt; — contains library dependency information&lt;br /&gt; *
&lt;code&gt;bower_components/&lt;/code&gt; — a directory for installed dependencies&lt;br /&gt; *
&lt;code&gt;src/Main.purs&lt;/code&gt; — Entry point module for your project&lt;br /&gt; * &lt;code&gt;test/Main.purs&lt;/code&gt; —
An empty test suite.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At this point, you should be able to build the project — &lt;code&gt;pulp build&lt;/code&gt;, by
default the compiled JS code is put into &lt;code&gt;output&lt;/code&gt; folder. But it’s not yet
plugged into our HTTP trigger. Before doing that, let’s make our PureScript code
bit more interesting.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This section is following &lt;a href=&quot;https://github.com/purescript/documentation/blob/master/guides/Getting-Started.md&quot;&gt;PureScript getting started
guide&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The first step will be installing external PureScript library — &lt;code&gt;bower install
purescript-lists — save&lt;/code&gt;. Now, open the folder in your favourite editor (VSCode)
and go the &lt;code&gt;src/Main.purs&lt;/code&gt; file. Let’s replace its content with solution to the
&lt;a href=&quot;https://projecteuler.net/problem=1&quot;&gt;Project Euler #1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We can now build the code with &lt;code&gt;pulp build — skip-entry-point&lt;/code&gt; command. Now it’s
high time to plug our PureScript code into Azure Functions. Open
&lt;code&gt;MyHttpTrigger/index.js&lt;/code&gt; file and put there following code.&lt;/p&gt;

&lt;p&gt;As you can see, it’s fairly straightforward. The most important thing is the
&lt;code&gt;require&lt;/code&gt; call that will load compiled-to-JS PureScript code. After that, we can
call any function defined in PureScript as normal JS function.&lt;/p&gt;

&lt;p&gt;At this point, you can start your function again (&lt;code&gt;func host start&lt;/code&gt;) go to the
given URL and check if the answer to the Project Euler problem is correct.&lt;/p&gt;

&lt;h4&gt;Deployment&lt;/h4&gt;

&lt;p&gt;There exist multiple different ways of deploying Azure Function applications —
from Continues Deployment on every push to the repository, through complex build
scripts to simple uploading &lt;code&gt;zip&lt;/code&gt; file. For starters, the last method is the
simplest one. You need to zip all the necessary files — &lt;code&gt;MyHttpTrigger&lt;/code&gt; folder,
&lt;code&gt;output&lt;/code&gt; folder, &lt;code&gt;host.json&lt;/code&gt; and &lt;code&gt;package.json&lt;/code&gt; files. After you have &lt;code&gt;zip&lt;/code&gt; file
you can use Azure Portal, Azure CLI or simple calls to the REST API to upload
the Function.&lt;/p&gt;

&lt;p&gt;To learn more about deploying Azure Functions Applications visit official
documentation —
&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/azure-functions/deployment-zip-push&quot;&gt;https://docs.microsoft.com/en-us/azure/azure-functions/deployment-zip-push&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;Summary&lt;/h4&gt;

&lt;p&gt;Finishing up, in this blog post I’ve shown how easy it is to use modern,
advanced, purely functional programming language — PureScript — on the
serverless platform — Azure Functions. The example repository containing all
sample code can be found on GitHub —
&lt;a href=&quot;https://github.com/Krzysztof-Cieslak/AzureFunctionsPureScript&quot;&gt;https://github.com/Krzysztof-Cieslak/AzureFunctionsPureScript&lt;/a&gt;&lt;/p&gt;
</description>
                <pubDate>Sat, 12 Jan 2019 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/PureScript-on-Azure-Functions</link>
                <guid isPermaLink="true">http://kcieslak.io/PureScript-on-Azure-Functions</guid>
                
                <category>PureScript</category>
                
                <category>Azure</category>
                
                <category>Serverless</category>
                
                <category>Azure Functions</category>
                
                
            </item>
        
            <item>
                <title>Future of F# cross-platform editor tooling</title>
                <description>&lt;h1&gt;Future of F# cross-platform editor tooling&lt;/h1&gt;

&lt;p&gt;Currently we have this beautiful moment in the year when everyone writes,
tweets, and instagrams about their achievements in past year, and plans for the
next one. I’ve also done &lt;a href=&quot;http://kcieslak.io/2016&quot;&gt;this&lt;/a&gt;
&lt;a href=&quot;http://kcieslak.io/OSS-The-Story&quot;&gt;before&lt;/a&gt; (often being week…or month late),
however this year I decided to write about something else. So let’s talk about
F# cross-platform, community driven editor tooling.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3&gt;Language Server Protocol&lt;/h3&gt;

&lt;p&gt;Before diving into F# specific things, I need to mention project that has
changed how editor tooling is built over the past two years - &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;Language Server
Protocol&lt;/a&gt; (LSP). LSP is
specification of the communication between a client (editor) and a server that
provides language tooling capabilities such as autocomplete, tooltips, etc. It
reduces the* m-times-n* problem to the &lt;em&gt;m-plus-n&lt;/em&gt; problem —similar to how
Virtual Machines solve the same problem for deploying code to many platforms
(great example here is&lt;a href=&quot;https://en.wikipedia.org/wiki/Z-machine&quot;&gt; Z-machine&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*jzJVMrcgfqUJ8YTGDpE0ZA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For example, instead of creating a Python VSCode plugin, a Python vim plugin, a
Python Atom plugin, and Python plugins for any other potential clients, it
allows developers to focus on single implementation of language server, this
will be automatically supported by all clients that implement LSP.&lt;/p&gt;

&lt;p&gt;Of course idea of language server is not new — it’s been fairly common way to
create language tooling. In fact, the F# language already has a language service
called the &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/&quot;&gt;F# Compiler
Service&lt;/a&gt;. It’s an F# API into
the internals of the F# compiler, which does all of the heavy lifting in
determining things that are useful for editor tooling. However, it is ultimately
just an F# (i.e., .NET) API and cannot be consumed in every environment without
an additional interface. An additional layer that can interface between the F#
Compiler Service and any editor (i.e., not just Visual Studio) is needed to
allow for F# tooling to be used everywhere.&lt;/p&gt;

&lt;h3&gt;FsAutoComplete&lt;/h3&gt;

&lt;p&gt;As I’ve mentioned — the idea of a language server is not new. And F# has been
having one for years. Initially created in 2011 (as far as I know, that was way
before I’ve joined F# community), &lt;a href=&quot;https://github.com/fsharp/FsAutoComplete&quot;&gt;FsAutoComplete (FSAC)
&lt;/a&gt;has been used by all editors that
aren’t Visual Studio, such as Atom, Emacs, Vim, and VSCode. The project provides
a high level API over the F# Compiler Services, and communication layer
(standard I/O, and HTTP web server) that enables using it from non -.Net
platforms. It’s been long standing project, with many past iterations — in fact,
prior to the F# Compiler Service API being made available, it used reflection
over the F# compiler to access internal APIs! It has had many great maintainers
and contributors over the years (I especially need to mention here &lt;a href=&quot;https://github.com/7sharp9&quot;&gt;Dave
Thomas&lt;/a&gt;, &lt;a href=&quot;https://github.com/rneatherway&quot;&gt;Robin
Neatherway,&lt;/a&gt; &lt;a href=&quot;https://github.com/tpetricek&quot;&gt;Tomas
Petricek,&lt;/a&gt; and &lt;a href=&quot;https://github.com/enricosada&quot;&gt;Enrico
Sada&lt;/a&gt;) and it has been the magic that powers
&lt;a href=&quot;http://ionide.io/&quot;&gt;Ionide &lt;/a&gt;since day-0.&lt;/p&gt;

&lt;h3&gt;Current status&lt;/h3&gt;

&lt;p&gt;When I started &lt;a href=&quot;http://ionide.io/&quot;&gt;Ionide &lt;/a&gt;4 years ago, FSAC was in pretty good
shape, providing many crucial APIs and one communication layer (stdio). Over the
years, I started to contribute more and more to the project, and with help of
all awesome people involved, new contributors and community support we’ve
managed to transform FSAC into one of the best language servers I know
(especially considering it is not a commercial language service, such as those
authored by Microsoft or JetBrains), and I feel that it has been one of the most
important tools created by the .NET OSS community.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*g7fQGoPulhg0zk1oZQxHOw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Also, what is important personally for me is the level of innovation that we’ve
managed to achieve in FSAC and Ionide. Additional diagnostics such as unused
opens or unused bindings, integration with a third party linter, features
powering Ionide’s CodeLenses, background caching that enables very fast use of
any feature that requires symbols (such as Find References, CodeLens showing
number of references, etc.), and even custom &lt;a href=&quot;https://medium.com/lambda-factory/introducing-f-analyzers-772487889429&quot;&gt;F#
Analyzers&lt;/a&gt;.
These are not the features that you typically see in the editor tooling created
by independent vendors, nor especially in editor tooling for FP languages (yes,
some of those features have been present in powerful IDEs for particular
languages — CodeLenses for C# in VS, or famous background caches in JetBrains
IDEs — but never for FP languages, and never provided by community driven tools)&lt;/p&gt;

&lt;h3&gt;Bright Future?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/0*8AbD6eEC3MzyHHVb&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So the title of the post promised talking about the future… but the future is
now. Today, I’d like to show you the thing I’ve been working on over the Xmas
break for last 2 weeks — &lt;a href=&quot;https://github.com/fsharp/FsAutoComplete/pull/320&quot;&gt;the LSP communication layer for the
FSAC&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Huge thanks goes to &lt;a href=&quot;https://github.com/vbfox&quot;&gt;Julien Roncaglia&lt;/a&gt; for his initial
work on LSP + FSAC proof of concept few months ago, and his F# LSP server
abstraction implementation that has been used as a base for my current work.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Being active maintainer for editor tooling for 2
&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=sbrink.elm&quot;&gt;different&lt;/a&gt;
&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=Ionide.Ionide-fsharp&quot;&gt;languages&lt;/a&gt;,
a developer that created plugins for multiple editors, and someone that is
generally interested in editor tooling, it has become obvious for me that LSP
has won (at least in the niche of cross platform tooling provided by
community/independent vendors). There are more and more client implementations
(including really interesting online IDEs like
&lt;a href=&quot;https://www.gitpod.io/&quot;&gt;GitPod&lt;/a&gt;), more and more server implementations (which
means there are more and more investments into clients) and the protocol itself
is becoming more powerful and feature-ful. I strongly believe that it is the
future of the F# cross platform tooling. From the F# point of view there is
couple of important advantages:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It moves lot of code from Ionide code base to the FSAC code base — it means that
other editors than VSCode can use some of the improvements that has been
“hacked” in Ionide itself&lt;/li&gt;
  &lt;li&gt;It makes the contribution process easier — Ionide is a VSCode plugin written in
F# compiled to JS with &lt;a href=&quot;https://fable.io/&quot;&gt;Fable&lt;/a&gt; using FSAC (totally separate
code base). This makes the process of contribution a bit awkward — if you want
to contribute you need to know which code base to work in, if it’s Ionide you
need to have the Fable toolchain set up. The idea behind using F# for Ionide was
lowering the bar for contributors (“people interested in making F# tooling
better are F# developers so the code should be F#”). As lot of Ionide code is
moved to the FSAC, it makes contributions even easier by moving a lot of code to
a normal F#/.NET Core project&lt;/li&gt;
  &lt;li&gt;It’s good news for anyone wanting to use Atom or Vim or Emacs (or maybe ST3?) —
some of those plugins have not been maintained very actively (or have been
deprecated like Ionide-Atom), but moving to LSP will mean that getting all new
fancy features should be way easier or “free”.&lt;/li&gt;
  &lt;li&gt;I’ll soon start to work on Ionide 4.0 release that will be based on LSP. Lot of
Ionide code will be removed, since Ionide provides more functionalities than
just language features — things like solution explorer, creating new projects,
right click -&amp;gt; debug, and many features focused on developer experience are
implementations specific to VSCode (and that will probably never change).As FSAC
will take over lot of responsibilities, I hope to focus more on the UX in Ionide
itself, which is also a very interesting problem on its own.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;As a side note — we are looking for new maintainers for FSAC. &lt;a href=&quot;https://github.com/fsharp/FsAutoComplete/issues/321&quot;&gt;We would love
your help&lt;/a&gt;!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Grim Future?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*JLKpCZqiDfA80q3O7eH38w.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Of course, every real life story have also bad parts. And there are couple of
the dark clouds on the horizon. First of all, &lt;a href=&quot;https://github.com/ionide/ionide-vscode-fsharp/issues/948&quot;&gt;some
&lt;/a&gt;&lt;a href=&quot;https://github.com/ionide/ionide-vscode-fsharp/issues/938&quot;&gt;of
&lt;/a&gt;&lt;a href=&quot;https://github.com/ionide/ionide-vscode-fsharp/issues/914&quot;&gt;the
&lt;/a&gt;&lt;a href=&quot;https://twitter.com/TeaDrivenDev/status/1077622983383007233&quot;&gt;problems
&lt;/a&gt;with Ionide/FSAC
won’t go away with moving to LSP— they are connected to the complexity of build
and require more knowledge and time than I have (if someone from MSFT is reading
it — I would love to get, for late Xmas gift, open source, cross platform
language server for the .Net project system). But that’s just a technical
problem. The bigger one is that nothing has changed for last year and I can
repeat my words from last years’ post. While I believe that F# ecosystem is in
its best shape ever, it’s still building a castle on the sand — not enough
contributors, depending on same handful of people that overproduce, no
commercial support for OSS projects, no companies interested in investing into
F# OSS ecosystem. Ionide and FSAC are both in unsustainable state — crucial
projects for F# community, with thousands of users, that are used by a huge part
of the community every day — they get no commercial support and there are not
enough contributors to make up for this.&lt;/p&gt;

&lt;h3&gt;So… 2019?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*8KAxxVKVlP_CDXvAXWkrRw.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So, how will 2019 will look like? Only time will tell. But in general I believe
that there are more bright sides to the story than dark clouds. F# ecosystem is
in fairly OK place — tooling is really OK, .NET Core adoption is rising which is
a good sign, there are more and more interesting projects, community is active,
and projects like the &lt;a href=&quot;https://safe-stack.github.io/&quot;&gt;SAFE&lt;/a&gt; stack are becoming
mature and are getting decent adoption.&lt;/p&gt;

&lt;p&gt;However, as a community we still haven’t solved the problem of OSS
maintainability. One one hand, it’s nothing unusual — most communities struggle
with those problems. On the other hand, it’s obvious that F# commercial adoption
is very often driven by the few people building awesome OSS things, and maybe we
should help them somehow?&lt;/p&gt;

&lt;p&gt;Anyway, I hope &lt;strong&gt;you&lt;/strong&gt; will build great things with F# in 2019!&lt;/p&gt;
</description>
                <pubDate>Mon, 31 Dec 2018 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/Future-of-F-Cross-platform-editor-tooling</link>
                <guid isPermaLink="true">http://kcieslak.io/Future-of-F-Cross-platform-editor-tooling</guid>
                
                <category>F#</category>
                
                <category>VS Code</category>
                
                <category>Tooling</category>
                
                
            </item>
        
            <item>
                <title>Introducing F# Analyzers</title>
                <description>&lt;h1&gt;Introducing F# Analyzers&lt;/h1&gt;

&lt;p&gt;One of the most exciting features of Roslyn (modern C# compiler) is ability to plug into it custom extensions called &lt;a href=&quot;https://docs.microsoft.com/en-us/visualstudio/extensibility/getting-started-with-roslyn-analyzers?view=vs-2017&quot;&gt;Roslyn Analyzers&lt;/a&gt;. They are live, real-time, project based plugins that enables to diagnose source code and surface custom errors, warnings and code fixes into Visual Studio. What’s really important is fact that there are project based, and distributed through NuGet which means they are easy to install, and ensure that all developers working on the project have exactly same analyzers installed. This is really useful if you want to ensure common best practices, style etc while working on the project.&lt;/p&gt;

&lt;p&gt;Today I’d like to introduce preview of the project called F# Analyzers which adds similar capabilities to &lt;a href=&quot;http://ionide.io&quot;&gt;Ionide&lt;/a&gt; (F# support in VS Code). Project is still in the early days, so design and technical details can change in time, but I’m really excited to share it with users even in its current state.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3&gt;Architecture overview&lt;/h3&gt;

&lt;p&gt;Before diving deeper into Analyzers themselves, it’s important to understand general architecture of Ionide, and where Analyzers fits into this architecture. This has really important impact on the Analyzers capabilities and limitations.&lt;/p&gt;

&lt;p&gt;On the one hand we have Ionide itself. It’s &lt;a href=&quot;https://code.visualstudio.com/docs/extensions/overview&quot;&gt;VS Code plugin&lt;/a&gt; which means it’s using NodeJS runtime, running as a child process of the editor, communicating with VS Code using set of APIs provided by VS Code. On the other hand we have F# compiler, or exactly speaking &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/index.html&quot;&gt;FSharp.Compiler.Service&lt;/a&gt; which is library version of F# compiler, exposing some additional APIs useful for creating tooling for F#. Of course, &lt;code&gt;FSharp.Compiler.Service&lt;/code&gt; is .Net library which means it can’t be used directly by NodeJS process.&lt;/p&gt;

&lt;p&gt;Last important part of the architecture is &lt;a href=&quot;https://github.com/fsharp/FsAutoComplete&quot;&gt;FsAutoComplete&lt;/a&gt;. It’s a project that provides communication layer and high level API between FCS and external world. It’s used by vim, emacs and Ionide as all those plugins are hosted in non .Net environments.&lt;/p&gt;

&lt;p&gt;The F# Analyzers are using extension point provided by the FsAutoComplete which means that in current shape they can be supported only by the editors using it (and they requires some work on the plugin side of things - currently only Ionide supports them). And it means that diagnostics provided by them are visible only in the editor, not during compilation.&lt;/p&gt;

&lt;h3&gt;Analyzers basics&lt;/h3&gt;

&lt;p&gt;Analyzer is normal F# function. As an input it takes Context object which contains current information about the file - Parse Tree, Type Abstract Syntax Tree, Symbols information, and returns list of the Diagnostics - records containing diagnostic message, type, description, and potentially list of fixes that can be used to fix the problem.&lt;/p&gt;

&lt;p&gt;F# Analyzer contains 3 parts - first one is an extension point in FSAC which is responsible for loading and running analyzers, second one is a editor handler (part of Ionide, in this case) that displays diagnostics and fixes. Last part is &lt;a href=&quot;https://github.com/Krzysztof-Cieslak/FSharp.Analyzers.SDK&quot;&gt;FSharp.Analayzers.SDK&lt;/a&gt; project that’s used to create analyzers.&lt;/p&gt;

&lt;h3&gt;Building your first analyzer&lt;/h3&gt;

&lt;p&gt;From infrastructure point of view, creating analyzer is simple - you need to create normal F# project, &lt;code&gt;netstandard2.0&lt;/code&gt; , add reference to &lt;code&gt;FSharp.Analyzers.SDK&lt;/code&gt; (avaliable on NuGet - &lt;a href=&quot;https://www.nuget.org/packages/FSharp.Analyzers.SDK/&quot;&gt;https://www.nuget.org/packages/FSharp.Analyzers.SDK&lt;/a&gt;) and create analyzer functions - normal F# functions taking Context returning list of diagnostics, and marked with Analyzer attribute.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Due to unresolved technical limitations your Analyzer must contain “Analyzer” in the name of output dll.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;However, from technical point of view creating analyzer is fairly difficult task - you need to be familiar with processing typed or untyped abstract syntax tree, or accessing FSharp Symbols information. Currently SDK doesn’t provide any helper functions, but we hope to add some higher level abstractions in the future. Currently, I recommend going through &lt;a href=&quot;http://fsharp.github.io/FSharp.Compiler.Service/&quot;&gt;FCS documentation&lt;/a&gt;, to get more familiar with the concepts&lt;/p&gt;

&lt;p&gt;Generally speaking processing Abstract Syntax Trees is usually done by recursive pattern matching on the DU representing syntax nodes. The following snippet shows how to travers Type Abstract Syntax Tree and call some function on every node that represents call of the member. While it looks bit scary, and complex if you take a look on it bit longer you will notice that it’s just big recursive pattern matching. Also, similar pattern matching will be base for most analyzers, which means you can reuse the code pretty easily.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/34c2a43c52119fde8d55315c7831244d.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Having this bit of infrastructure code, let’s now move to the analyzer itself. As I’ve mentioned before, analyzers are normal functions that have particular signature and are marked with attribute.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/42829ce7b5dcc937bece698a5af9ff2b.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;In the above snippet we create analyzer that will detect any call of &lt;code&gt;x.Value&lt;/code&gt; where x is an F# Option. As you probably know calling &lt;code&gt;.Value&lt;/code&gt; on an &lt;code&gt;option&lt;/code&gt; is not total function and can throw exception if an &lt;code&gt;option&lt;/code&gt; instance is &lt;code&gt;None&lt;/code&gt;, so checking for it may be good idea.&lt;/p&gt;

&lt;p&gt;The handler function in above example is executed for every member call. In it we check if the name of the function we call, and if it’s &lt;code&gt;Option.Value&lt;/code&gt; we add the range of the symbol into the state. After we’ve processed whole tree we map all ranges into the warnings that will be displayed in the editor. There also exist possibility of providing set of code fixes, but we don’t use it in this example.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Whole code of the sample analyzer is available on GitHub - &lt;a href=&quot;https://github.com/Krzysztof-Cieslak/FSharp.Analyzers.Sample&quot;&gt;https://github.com/Krzysztof-Cieslak/FSharp.Analyzers.Sample&lt;/a&gt;, and analyzer is published on NuGet - &lt;a href=&quot;https://www.nuget.org/packages/FSharp.Analyzers.Sample/&quot;&gt;https://www.nuget.org/packages/FSharp.Analyzers.Sample/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Using analyzer&lt;/h3&gt;

&lt;p&gt;Analyzers are enabled by &lt;code&gt;FSharp.enableAnalyzers&lt;/code&gt; setting inside VSCode. By default it’s disabled, so you need to edit settings to enable analyzers support. Using analyzers is as simple as adding Analyzer NuGet package with Paket - for out of the box support in Iondie you need to use Analyzer group for it.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/dc71359d81354129187584c502cc60e6.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;After the package is added to &lt;code&gt;paket.dependencies&lt;/code&gt; and restored, Ionide will automatically detect and load analyzers. It may require editor restart as analyzers are loaded on plugin startup.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ionide also contains setting &lt;code&gt;FSharp.analyzersPath&lt;/code&gt; that will enable you to configure paths from which Ionide loads analyzers, by default it’s using &lt;code&gt;packages/Analyzers&lt;/code&gt; and &lt;code&gt;analyzers&lt;/code&gt; folders.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example let’s test our new analyzer on the following snippet.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/c1962db70231ec9d2581955324f6ac82.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;This will result in underlying &lt;code&gt;x.Value&lt;/code&gt; with a warning saying that Option.Value shouldn’t be used&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*axoWiRB3EPANiOljA_PWzg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sample project using analyzer can be found on GitHub - &lt;a href=&quot;https://github.com/Krzysztof-Cieslak/FSharp.Analyzers.Sample.Usage&quot;&gt;https://github.com/Krzysztof-Cieslak/FSharp.Analyzers.Sample.Usage&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;So what’s next?&lt;/h3&gt;

&lt;p&gt;Currently there are several important limitation of the F# Analyzers. First of all they’re supported only by Ionide. Secondly to write analyzer you need to be familiar with F# (T)AST pretty well. And in the end writing fixes requires providing new version of code in textual form (unlike in case of Roslyn Analyzers where fixes can be provided as AST transformation), what may be difficult and error prone. Also, whole mechanism is currently in an experimental phase, relies on Reflection etc. so it can be bit unstable.&lt;/p&gt;

&lt;p&gt;However, I treat this as an experiment and proof of concept, that may be used as a base for discussing similar functionalities being added to F# compiler or other IDEs. Also I’m super excited to see what potentially great things can F# Community create having such extension point in the editor (Evil Hint: You can use this feature to run any code inside of the language server and return some information to editor… which sounds awesome and crazy at the same time)&lt;/p&gt;

&lt;h3&gt;Summary&lt;/h3&gt;

&lt;p&gt;In this post I’ve introduced preview of new tooling related project that enables users to add custom analyzers to your editor, bringing functionality similar to Roslyn Analyzers. While this is only experiment, and proof-of-concept I’m looking forward to seeing all innovative things it can enable. Analyzers support has been released in new Ionide version - &lt;code&gt;3.27.0&lt;/code&gt; - so it’s out there and ready for experimenting!&lt;/p&gt;
</description>
                <pubDate>Fri, 14 Sep 2018 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Introducing-F-Analyzers</link>
                <guid isPermaLink="true">http://kcieslak.io/Introducing-F-Analyzers</guid>
                
                <category>F#</category>
                
                <category>VS Code</category>
                
                <category>Tooling</category>
                
                
            </item>
        
            <item>
                <title>Building an MVP with F# and Saturn</title>
                <description>&lt;h1&gt;Building an MVP with F# and Saturn&lt;/h1&gt;

&lt;p&gt;Creating an MVP (minimum viable product) is one of the best way of bootstrapping your startup. As a new company getting a quick feedback from the application users, bringing an application to users as fast as possible, being able to adapt as quickly as possible to the market changes, and providing frequent application updates is crucial for the initial success of the product. But it’s also important to understand that an MVP software development is not synonymous with unfinished or a primitive product that was created in a hurry.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3&gt;What is an MVP?&lt;/h3&gt;

&lt;p&gt;Minimum Viable Product (MVP) is the smallest, most concise version of your product you can initially release for feedback. It enables a full turn of the feedback loop with the least amount of development time and effort. This allows the targeted users to try a product and evaluate it to make the complete version better. It is a frequently updated environment with the new features that could be seen and tested by clients. New registration page, an admin management panel, as well as email notifications, and any other new features you can imagine.&lt;/p&gt;

&lt;p&gt;MVP development allows early adopters to understand the vision or promise of the final product and provide valuable feedback to guide developers moving forward. The main advantages of the MVP software development are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;MVP has enough value that people can already use or buy it&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It demonstrates enough features to hook and retain early users&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It provides feedback loop to guide future development&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It shows enough future potential to start marketing around the project&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What’s important - MVP development is not only the strategy for startups. When you already have well-established company and customers, you also need to have some way to experiment with new potential products or features. In a lot of cases, the minimum viable product really is just a way to do that.&lt;/p&gt;

&lt;h3&gt;Few words about F&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://fsharp.org&quot;&gt;F# is a functional-first programming language&lt;/a&gt; running on the .Net platform. Paired with &lt;a href=&quot;https://www.microsoft.com/net&quot;&gt;.Net Core&lt;/a&gt; - modern, cross platform implementation of the .Net Framework - it is fantastic tool for writing modern applications. .Net Core provides industrial level of the performance, security, huge ecosystem of the libraries, and always growing open source community. F#, itself an open source language with fantastic community , thanks to expressiveness, functional-first approach, great developers tooling and advanced language features provides unmatched developer experience and fast development speed, so important for building MVPs. It can also be your secret weapon that makes you stand out from many different companies, and that let you hire more talented people that just want to work with more niche technology.&lt;/p&gt;

&lt;h3&gt;Introducing Saturn&lt;/h3&gt;

&lt;p&gt;F# due to its functional nature is perfect fit for the web applications. In the end HTTP web server may be treated as a function that takes Request and returns Response.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://saturnframework.org&quot;&gt;Saturn&lt;/a&gt; is a modern web framework for the F# focusing on high level abstractions and great developer experience, allowing developers focus on the things that matters for your business. Influenced by the popular frameworks such as Rails or Phoenix it comes with all the batteries included. Its ecosystem includes development tools that allows developers to quickly create new applications, add new features to existing applications, and test new features; it integrates with existing &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-2.1&quot;&gt;ASP.NET Core&lt;/a&gt; ecosystem that provides huge set of existing modules that you can use in your application; it provides pre-defined configurations that limits the number of decisions that developers need to make. And all this while using highly expressive and modern programming language.&lt;/p&gt;

&lt;h3&gt;Typical difficulties&lt;/h3&gt;

&lt;p&gt;While MVP development is really powerful technique, just like every other methodology it has its own drawbacks. First of all you need to understand it’s not about delivering product as fast as possible so customers can try it out. MVP development is about refined and validated learning. This simple fact must be understood by everyone - stakeholders, developers, customers. You have to understand that final product may drastically change due to user’s feedback. And this is something that must be embraced by the development team, and should impact the way in which they work. Developers needs to have regular feedback session, learn from them, prioritise features.&lt;/p&gt;

&lt;p&gt;As a result, this should have an impact on the technologies chosen for developing MVP:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;refactoring plays the key roles, when you see that some part of the product is not scalable or flexible enough, or that it just need changes based on the user’s feedback you need to be able to quickly change an existing code base&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;correctness is important, especially the one you can get for free. Using static type checking, code linting, and code quality tools is crucial to provide product that’s working well enough, without spending much development time on it&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;flexible but simple design - design of your product must be flexible enough to provide ability to change the product based on the feedback, but at the same time it must be relatively simple - for MVP development you want to get to the market as fast as possible, and you don’t want to spend time building sophisticated architecture that may not work after all changes that will happen in the future&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fortunately, F# and .Net Core are great solutions for all those problems - functional first approach naturally pushes you toward pit of success, and simple, flexible architecture, static typing with powerful type inference enables you to create correct software without much overhead, best in class editor tooling helps you to quickly refactor existing code.&lt;/p&gt;

&lt;h3&gt;Commercial support&lt;/h3&gt;

&lt;p&gt;The last important factor in choosing right technology is having an ability to hire someone to develop the product, or just get help. F# ecosystem is including wide range of the options for getting commercial support - starting from the established companies providing support for &lt;a href=&quot;https://safe-stack.github.io&quot;&gt;SAFE Stack&lt;/a&gt; through multiple independent consultants to &lt;a href=&quot;https://lambdafactory.io&quot;&gt;Lambda Factory&lt;/a&gt;. Lambda Factory specialises in creating web applications, F# training and consulting, MVP development, and developer relationships. We provide everything you need to transform your startup into prospecting business - help with creating MVP, iterating over the feedback loop, hiring talented developers, and DevRel marketing.&lt;/p&gt;
</description>
                <pubDate>Thu, 16 Aug 2018 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Building-an-MVP-with-F-and-Saturn</link>
                <guid isPermaLink="true">http://kcieslak.io/Building-an-MVP-with-F-and-Saturn</guid>
                
                <category>F#</category>
                
                <category>Saturn</category>
                
                <category>Web</category>
                
                <category>MVP</category>
                
                
            </item>
        
            <item>
                <title>Challenges of post-OSS world</title>
                <description>&lt;h1&gt;Challenges of post-OSS world&lt;/h1&gt;

&lt;p&gt;Open Source Software has won. After years of convincing people to use open source software, fighting with false dichotomy between OSS and industrial, commercial software, and defending against negative biases, position of OSS is no longer disputed - it’s been used by vast majority of companies around the world, it has become default choice when choosing technologies, it powers the internet, our PCs, mobile phones and most devices we use every day, it’s been accepted by huge, conservative companies that were against whole concept few years ago.&lt;/p&gt;

&lt;p&gt;But have we really been ready for that? For most of its history OSS community was busy fighting for survival. And we created strategy, methodologies, and public relations attitudes that were helping us fight for this survival. But the times have changed and now we face totally different set of problems that we need to solve.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3&gt;Outdated foundations&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;93% - percentage of npm packages with just one maintainer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;General understanding of the mechanism ruling the OSS ecosystem is relatively outdated. As mentioned above - our knowledge about foundation of community based software was shaped when OSS was treated as something bad and undesirable by mainstream programming industry. Organisations like Free Software Foundation, licenses like GPL have their roots in 80s and 90s. The amazing essay *“The Cathedral and the Bazaar” *that has shaped how we understand the community based software was published in 1999. Those were totally different times - when the software market was dominated by companies like IBM, Oracle and Microsoft that were clearly against any ideas of free software. And back then we need different ways of speaking about OSS - the Bazaar analogy was designed to win hearts of the developers, to show that they don’t need to be afraid of the open source software. And it has done that really, really well. However it shouldn’t be used in 2018 as a way of describing how OSS works - we now face different set of issues.&lt;/p&gt;

&lt;p&gt;While many of the ideas from *The Cathedral and the Bazaar” *have aged really well, and still apply to any kind of software development, OSS nowadays is not about creating huge communities, applying “given enough eyeballs, all bugs are shallow” law, or in principle following Bazaar model. On the contrary, given all the success that OSS has achieved the Bazaar model has been unsuccessful - only 3% of popular OSS projects are using such development model. Of course those 3% contains some hugely popular and impactful projects - such as Rails or Linux - but one could argue that they’re using this model as a result of their success and not other way round. In the end, no project starts as a community, there is always someone in charge, and communities around the projects are created only after they are successful.&lt;/p&gt;

&lt;h3&gt;Unlimited growth&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;28 millions of developers - number of registered users at GitHub.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;No-one in the 90s could predict the scale of the success that OSS will achieve. The number of developers doing OSS, number of projects, and number of users has raised by several orders of magnitude over last 20 years. The Bazaar model was created when huge percentage of the people using OSS were people developing OSS. But current state of the world is bit different. Let’s just compare some numbers.&lt;/p&gt;

&lt;p&gt;The number of downloads per 2 weeks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1998 - 180K downloads of Netscape (most popular OSS project at the time)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2017 - 21M downloads of Loadash (random JS library)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The number of registered users:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2001 - 208K on SourceForge&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2018 - 28M on GitHub&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The number of active projects:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2008 - 150K on SourceForge&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2017 - 29M on GitHub&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As we can see, OSS nowadays is massive, global and popular. But there are main 2 issues here. First one is yet increasing fragmentation of the ecosystem - unlike what was presented as big advantage of the Bazaar model, modern OSS is not about creating those singular points of focus for the communities. We don’t get “enough eyeballs”, instead we all rely on the projects that are very often driven forward by single maintainer and one or two other contributors. Second one is that growth of the user-base doesn’t resulted in proportional growth of contributors of the projects. And what’s even more important the growth of the contributors hasn’t resulted in the proportional growth of the maintainers - which results in more and more pressure put on the focal parts of our communities which itself is really huge issue.&lt;/p&gt;

&lt;h3&gt;Maintainers struggle&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;“The more successful you are, the more you get punished with GitHub notifications.” - &lt;a href=&quot;https://nolanlawson.com/2017/03/05/what-it-feels-like-to-be-an-open-source-maintainer/&quot;&gt;What it feels like to be an open-source maintainer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Maintainers are the focal points of the community of any OSS project. Not only they’re often main developers behind the project but also they have many other responsibilities - they need to keep users happy, they need to handle contributors to create good workflow that will enable new code contributions, they need to help first time contributors, they need to review PRs, handle releases, and keep general direction of the project.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Current status - anxious and depressed whenever I open my GitHub notifications. Programming is so much fun”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;However we don’t really get new maintainers too often. The number of users growth really fast, the number of developers grows - and while those 2 things are great, they create huge pressure on the maintainers. And the Bazaar analogy is part of the problem here - we expect someone to always step up, we expect contributors to become more and more involved. But the reality is bit different - 1/2 contributors contributes only once, and they account for around 2% of the commits. And every contribution is additional work for the maintainer, additional PR to review, and additional code to maintain later. Of course, every contribution is valuable, and welcomed but in general OSS community has huge “second time contribution” problem - we put lot of emphasis and work to optimise first contribution experience - but it unfortunately is not resulting in many long standing members of the community.&lt;/p&gt;

&lt;h3&gt;Sustainability&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;$143,000,000 - Estimated value of open source software in $1B Instagram acquisition&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;OSS movement was shaped in the times were most mainstream software was proprietary, it was not vastly used, and no business depended on it. But nowadays, OSS is everywhere - it powers internet, operating systems, software and products we use everyday. It’s hard to imagine building new software without using any OSS technologies and OSS is used by the biggest, most conservative (In terms of technological choices) companies of the world - 100% of Fortune 500 companies are using npm.&lt;/p&gt;

&lt;p&gt;And yet, even some most popular OSS projects ever struggle to get any founding, and build any notion of sustainability. But we continue to build businesses using those tools and libraries. One would hope that in the future we will start to think about open source software in terms of digital infrastructure - that, just like our normal infrastructure, requires constant funding to function properly.&lt;/p&gt;

&lt;h3&gt;How we talk about OSS&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Just like physical infrastructure, digital infrastructure needs regular upkeep and maintenance.” - &lt;a href=&quot;https://www.fordfoundation.org/about/library/reports-and-studies/roads-and-bridges-the-unseen-labor-behind-our-digital-infrastructure/&quot;&gt;Roads and Bridges: The Unseen Labor Behind Our Digital Infrastructure&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Probably to solve some of those problems we need to change a way we talk about OSS - instead of convincing our managers that we need to contribute because it is “good” behavior, or because it will improve “morale” of the team we should talk in business terms - risk and opportunity. Contributing to the projects decrease our risk as a business - it decrease risk that project maintainer will rage quit and we will be stuck with unmaintained project, it decrease risk of needing help of other people if we have some problems with the project. Contributing to the project is also opportunity - we can shape project, add new features that will enable us to make our business solutions better.&lt;/p&gt;

&lt;p&gt;And the other interesting value proposition for contributing to OSS is just plain marketing value - especially if your product targets technical communities. We know live in the times of Developers Relationships movement, were any company building software projects for developers spends lot of resources for promotion. Contributing to OSS is great way of such promotion. And even if your business is not building tools for developers - it will make hiring talented developers way easier.&lt;/p&gt;

&lt;h3&gt;Solutions? I have none&lt;/h3&gt;

&lt;p&gt;I don’t know how to solve the problems of the current OSS world. But it is pretty clear that OSS needs evolve - we need new definitions, new solutions and new leaders for the movement that already changed the world. OSS nowadays struggle with totally different set of the problems than it did 20 years ago, so using the analogies that were used 20 years ago, may not be the way forward. And I do believe that we need to find those solutions pretty fast… or it will turn out that we’ve built our great castle on the sand.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This blog post is adaptation of my “Challenges of post-OSS world” talk I’ve presented on couple of events. If you’d like to have me talk about OSS on your conference and your company feel free to reach me at krzysztof_cieslak@windowslive.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Both talk and this blog post has been deeply influenced by the work of &lt;a href=&quot;https://nadiaeghbal.com/&quot;&gt;Nadia Eghbal&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                <pubDate>Sat, 11 Aug 2018 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Challenges-of-post-OSS-world</link>
                <guid isPermaLink="true">http://kcieslak.io/Challenges-of-post-OSS-world</guid>
                
                <category>Open Source</category>
                
                <category>Community</category>
                
                
            </item>
        
            <item>
                <title>Using OAuth with Saturn</title>
                <description>&lt;h1&gt;Using OAuth with Saturn&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://saturnframework.org&quot;&gt;Saturn&lt;/a&gt; is new F# web framework that provides flexible, high level model of creating web applications using principles of functional programming and MVC architectural pattern. Main design goals of Saturn includes high level abstractions that lets developers focus on creating business code , and general developer experience. One of the features provided by Saturn is support for popular way of authentication - OAuth&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This blog post was created for Saturn version 0.7.5&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;h3&gt;OAuth intro&lt;/h3&gt;

&lt;p&gt;OAuth 2 is an authorization framework that enables applications to obtain limited access to user accounts on an HTTP service, such as Twitter, GitHub, or DigitalOcean. It works by delegating user authentication to the service that hosts the user account, and authorizing third-party applications to access the user account. OAuth 2 provides authorization flows for web and desktop applications, and mobile devices.&lt;/p&gt;

&lt;p&gt;While OAuth supports multiple different types of authorization, useful for different use cases, here we will talk about authorization code flow. The authorization code grant type is the most commonly used because it is optimized for server-side applications (such as web applications using Saturn), where source code is not publicly exposed, and Client Secret confidentiality can be maintained. This is a redirection-based flow, which means that the application must be capable of interacting with the user-agent (i.e. the user’s web browser) and receiving API authorization codes that are routed through the user-agent.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*qH2SyNHvrTa8UR4d8n08pA.png&quot; alt=&quot;Flow of Authorization Code OAuth grant&quot; /&gt;
&lt;em&gt;Flow of Authorization Code OAuth grant&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;First steps&lt;/h3&gt;

&lt;p&gt;The first step in creating application using OAuth is registering application in the OAuth provider. In this example I’ll use GitHub.&lt;/p&gt;

&lt;p&gt;To start off with, you will need to register an application by going to the &lt;a href=&quot;https://github.com/settings/developers&quot;&gt;GitHub Developer Settings&lt;/a&gt;. Click on the button to &lt;strong&gt;Register a new application&lt;/strong&gt;, and complete the information for your application. Specify http://localhost:5000/signin-github as the value for the &lt;strong&gt;Authorization callback URL&lt;/strong&gt; field:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*0Q88p6YUg0ijickJbqZD_g.png&quot; alt=&quot;Register a new OAuth application&quot; /&gt;
&lt;em&gt;Register a new OAuth application&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Take note of the values for &lt;strong&gt;Client ID&lt;/strong&gt; and &lt;strong&gt;Client Secret&lt;/strong&gt;, that will be shown on the next screen after pressing &lt;strong&gt;Register application&lt;/strong&gt; button, as you will need those shortly when registering the OAuth.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Path goes forward&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Next step is creating new Saturn application. This can be easily done using dotnet CLI tool.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir oauthBlogPost
cd oauthBlogPost
dotnet new saturn
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you don’t have Saturn template installed you can get it by running &lt;code&gt;dotnet new -i Saturn.Template&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Next step is installing Saturn.Extensions.Authorization - NuGet package that contains additional helpers for handling authorization, including GitHub provider.&lt;/p&gt;

&lt;p&gt;Open &lt;code&gt;paket.dependencies&lt;/code&gt; and &lt;code&gt;src\oauthBlogPost\paket.references&lt;/code&gt; file and add Saturn.Extensions.Authorization in there. After it’s done run &lt;code&gt;.paket\paket.exe&lt;/code&gt; install and &lt;code&gt;dotnet restore&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you’re on Linux / MacOS you will need &lt;code&gt;mono&lt;/code&gt; to run &lt;code&gt;paket.exe&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Diving deep&lt;/h3&gt;

&lt;p&gt;Now, at last, it’s time to look at some code. Open Program.fs file that contains basic configuration of your Saturn application. Firstly, edit URL to use port 5000. Secondly add new entry in the application block - &lt;code&gt;use_github_oauth&lt;/code&gt;. This custom operation takes couple of input parameters - Client ID, Client Secret, Callback URL, and the list of tuples used to mapping from GitHub’s JSON response to the claims that Saturn understands.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/d32be21f6f55e52ddd09569cd3d5a35e.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Second step is creating pipelines that will handle or require authentication. Create &lt;code&gt;User.fs&lt;/code&gt; file, and add it to &lt;code&gt;.fsproj&lt;/code&gt; file above the &lt;code&gt;Router.fs&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/5b53a1ff47edf5d323d788cce4913934.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;The &lt;code&gt;matchUpUsers&lt;/code&gt; function mock ups check of the data coming from GitHub with your real users database, &lt;code&gt;loggedIn&lt;/code&gt; pipeline forces authentication on the request, and &lt;code&gt;isAdmin&lt;/code&gt; pipeline checks if the request is done by someone with Admin role.&lt;/p&gt;

&lt;p&gt;Now, it’s time to plug it into our routing. Open &lt;code&gt;Router.fs&lt;/code&gt; file. We will create additional router that will display two views - one for logged in user, second one for the admin. Now you need to plug this new router into our top level router - &lt;code&gt;browserRouter&lt;/code&gt; . The last thing you need to do here is also handling the URL that will be called by GitHub after successful authentication. We will redirect it into logged user view.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/0018080f31ac43ed9e9050a72381973d.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Last step is creating some HTML views that we will return to user. Under Templates folder, create &lt;code&gt;UserView.fs&lt;/code&gt; file and add it to &lt;code&gt;.fsproj&lt;/code&gt; as last file in &lt;code&gt;Template/&lt;/code&gt; group.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/Krzysztof-Cieslak/71776217054f1f7c935debee60bcb8fe.js&quot;&gt;&lt;/script&gt;

&lt;h3&gt;Light at the end&lt;/h3&gt;

&lt;p&gt;It’s time to run our application. But there is one small step you still need to do. Go to &lt;code&gt;src\oauthBlogPost&lt;/code&gt; folder and run from terminal&lt;code&gt; dotnet saturn migration&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This step is necessary because &lt;code&gt;dotnet new saturn&lt;/code&gt; creates pretty complex application scaffold including connection to local database&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now, from root of your repository, you can run &lt;code&gt;.\build.sh&lt;/code&gt; Run which will start the application. You can go to &lt;a href=&quot;http://localhost:5000/&quot;&gt;http://localhost:5000/&lt;/a&gt; to see standard startup page of the scaffolded application&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/4170/1*IdS_PnUyC_1PRt4C9KpvDw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If you will try to go to &lt;a href=&quot;http://localhost:5000/&quot;&gt;http://localhost:5000/members-only&lt;/a&gt; URL, you will get redirected to GitHub authorization page.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*uJQi6z3zOloSuEpyW9Xl5A.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And after authorization, you’ll get redirected back to our application.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2636/1*u8QOBaA-MVyjrLUB6kSL5A.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can also try going to &lt;a href=&quot;http://localhost:5000/&quot;&gt;http://localhost:5000/members-only/admin&lt;/a&gt; . If you are me (or you’ve updated the code ;-) ) you should see the admin page.&lt;/p&gt;

&lt;h3&gt;End of the way&lt;/h3&gt;

&lt;p&gt;In this post I’ve shown how to introduce OAuth authorization to your Saturn application. As you could see Saturn is using high level, declarative syntax that enables you to plug features like that easily into your application. Currently Saturn.Extensions.Authorization provides predefined authorization providers for Google and GitHub, but more will come to it soon. Feel free to PR your favorite OAuth provider!&lt;/p&gt;
</description>
                <pubDate>Fri, 03 Aug 2018 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Using-OAuth-with-Saturn</link>
                <guid isPermaLink="true">http://kcieslak.io/Using-OAuth-with-Saturn</guid>
                
                <category>F#</category>
                
                <category>Saturn</category>
                
                <category>Web</category>
                
                <category>OAuth</category>
                
                
            </item>
        
            <item>
                <title>Introducing Saturn on Functions</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Azure Functions is a service that provides serverless execution model while running code in the cloud. Serverless model is getting more and more popular nowadays, being great solution for building distributed, scalable, event-driven applications. However, those are not the only use cases - compute-on-demand story, automatic, low friction scalability and great pricing model means that Azure Functions can be used to host normal (REST-ish) APIs.&lt;/p&gt;

&lt;p&gt;On the other hand, Saturn is new F# web framework that provides flexible, high level model of creating web applications using principles of functional programming and MVC architectural pattern. Main design goals of Saturn includes high level abstractions that lets developers focus on creating business code , and general developer experience.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Saturn on Functions&lt;/h1&gt;

&lt;p&gt;Today I want to introduce new extension to Saturn that adds ability to easily host Saturn controllers and routers inside Azure Functions HTTP triggers. Saturn is a library built on top of Giraffe and ASP.NET Core which means it can easily integrate with existing .Net ecosystem. HTTP triggers in Azure Functions as one of the input parameters are getting standard &lt;code&gt;HttpRequest&lt;/code&gt; object that can be passed into Saturn’s &lt;code&gt;controller&lt;/code&gt; or &lt;code&gt;router&lt;/code&gt; (and any other &lt;code&gt;HttpHandler&lt;/code&gt;).&lt;/p&gt;

&lt;h1&gt;Computation Expression&lt;/h1&gt;

&lt;p&gt;To reduce amount of boilerplate required to call any &lt;code&gt;HttpHandler&lt;/code&gt; and provide, in Saturn’s spirit, opinionated way of hosting your controllers in Azure Functions we’ve created &lt;code&gt;Saturn.AzureFunctions&lt;/code&gt; project that adds new computation expression  - &lt;code&gt; azureFunction&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let testCntl = controller {
    index (fun ctx -&amp;gt; Controller.text ctx &quot;Hello world&quot;)
    show (fun ctx id -&amp;gt; id |&amp;gt; sprintf &quot;Hello world, %s&quot; |&amp;gt; Controller.text ctx)
}
let func log = azureFunction {
    host_prefix &quot;/api&quot;
    use_router testCntl
    logger log
    error_handler customErrorHandler
    not_found_handler customNotFoundHandler
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;azureFunction&lt;/code&gt; CE provides set of custom operations that can be used to configure Azure Functions adapter:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;host_prefix&lt;/code&gt;  -  prefix of the routes used by Azure Functions. By default Functions are using &lt;code&gt;/api&lt;/code&gt; prefix.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;use_router&lt;/code&gt;  -  plugs &lt;code&gt;HttpHandler&lt;/code&gt; that will be used. Setting it is required.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;logger &lt;/code&gt; -  enables passing &lt;code&gt;TraceWriter&lt;/code&gt; into your &lt;code&gt;HttpHandler&lt;/code&gt; . It’s passed into your functions by &lt;code&gt;ctx.Items.[&quot;TraceWriter&quot;]&lt;/code&gt; property. It’s also used for logging error in default error handler.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;error_handler&lt;/code&gt;  -  enables plugging custom error handler for unhandled exceptions.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;not_found_handler&lt;/code&gt;  -  enables plugging custom handler for not matched requests.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Using it together&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;azureFunction&lt;/code&gt; CE is transformed into a function that accepts &lt;code&gt;HttpRequest&lt;/code&gt; as an input and returns &lt;code&gt;Task&amp;lt;HttpResponse&amp;gt; &lt;/code&gt; -  something that is understood by Functions runtime, and as such can be easily used in normal Azure Functions endpoint.&lt;/p&gt;

&lt;p&gt;For example using &lt;code&gt;azureFunction&lt;/code&gt; defined above would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;FunctionName(&quot;HelloWorld&quot;)&amp;gt;]
let helloWorld ([&amp;lt;HttpTrigger(Extensions.Http.AuthorizationLevel.Anonymous, Route = &quot;{route?}&quot;)&amp;gt;]req: HttpRequest, log: TraceWriter) =
    func log req
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post I’ve presented new way of hosting your Saturn applications - using Azure Functions. As you can see Saturn will provide easy to use, opinionated way to embed Saturn controllers or routers in Azure Functions providing great, alternative way of hosting your web applications. &lt;/p&gt;

&lt;p&gt;&lt;code&gt;Saturn.AzureFunctions&lt;/code&gt; is currently still developed - if you’d like to check out current implementation, test it, or provide some feedback feel free to check this PR -  https://github.com/SaturnFramework/Saturn/pull/121&lt;/p&gt;
</description>
                <pubDate>Sat, 21 Jul 2018 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Introducing-Saturn-on-Functions</link>
                <guid isPermaLink="true">http://kcieslak.io/Introducing-Saturn-on-Functions</guid>
                
                <category>F#</category>
                
                <category>Saturn</category>
                
                <category>Web</category>
                
                <category>Azure Functions</category>
                
                
            </item>
        
            <item>
                <title>Magic of Saturn controllers</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://saturnframework.org&quot;&gt;Saturn&lt;/a&gt; is new F# web framework that implements well know design pattern - MVC - in more functional way. Despite Saturn being fairly young project it’s getting more and more popular among F# community and industrial users. One of the main Saturn’s goals is to create high level abstractions that will enable developers to focus on writing domain, business code instead of focusing on creating correct routing for your application or setting right response headers. One of such abstractions, that I want to talk about today, is &lt;code&gt;controller&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This article was created for Saturn version 0.7.x&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;h1&gt;Basic usage&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;controller&lt;/code&gt; is simple computation expression (CE) that enables you to easily implement application endpoint following REST-ish conventions. It can be used for implementing endpoints that renders views if you’re building application using server side rendering, or just return serialized data if you’re building API or your application is using client side rendering. Just like all other CEs used in Saturn, &lt;code&gt;controller&lt;/code&gt; provides set of custom operations that you can use. And, what’s important, all operations in &lt;code&gt;controller&lt;/code&gt; CE are optional, which means you can easily choose which subset of functionality you need. Example, basic implementation looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let resource = controller {
    index indexAction
    show showAction
    add addAction
    edit editAction
    create createAction
    update updateAction
    patch patchAction
    delete deleteAction
    deleteAll deleteAllAction
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s now go one by one, and describe each operation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;index&lt;/code&gt; - mapped into &lt;code&gt;GET&lt;/code&gt; request at &lt;code&gt;/&lt;/code&gt; endpoint. Usually used to render a view displaying list of items, or return whole list of items.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;show&lt;/code&gt; - mapped into &lt;code&gt;GET&lt;/code&gt; request at &lt;code&gt;/:id&lt;/code&gt; endpoint. Usually used to render a view displaying details of particular item, or return single item with given id.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;add&lt;/code&gt; - mapped into &lt;code&gt;GET&lt;/code&gt; request at &lt;code&gt;/add&lt;/code&gt; endpoint. Used to render a form for adding new item. Usually not used in API controllers.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;edit&lt;/code&gt; - mapped into &lt;code&gt;GET&lt;/code&gt; request at &lt;code&gt;/:id/edit&lt;/code&gt;. Used to render a form for editing existing item. Usually not used in API controllers.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;create&lt;/code&gt; - mapped into &lt;code&gt;POST&lt;/code&gt; request at &lt;code&gt;/&lt;/code&gt; endpoint. Used to create and save new item.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;update&lt;/code&gt; - mapped into &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;PUT&lt;/code&gt; requests at &lt;code&gt;/:id&lt;/code&gt; endpoint. Used to update existing item. Usually replaces original item (keeping id), and requires are fields to be filled in the incoming item.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;patch&lt;/code&gt; - mapped into &lt;code&gt;PATCH&lt;/code&gt; request at &lt;code&gt;/:id&lt;/code&gt; endpoint. Used to update existing item. Usually only changes some fields of original item, request body contains only changed fields or JSON Patch object.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;delete&lt;/code&gt; - mapped into &lt;code&gt;DELETE&lt;/code&gt; request at &lt;code&gt;/:id&lt;/code&gt; endpoint. Used to delete or deactivate existing item.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;deleteAll&lt;/code&gt; - mapped into &lt;code&gt;DELETE&lt;/code&gt; request at &lt;code&gt;/&lt;/code&gt; endpoint. Used to delete or deactivate all items.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Please remember that Saturn is not enforcing behaviour or inputs of actions any way, so above descriptions are suggestions and best practices, not something that’s encoded in framework. The only thing that controller provides is set in stone routing structure.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;Actions implementation&lt;/h1&gt;

&lt;p&gt;All actions &lt;code&gt;indexAction&lt;/code&gt;, &lt;code&gt;showAction&lt;/code&gt; … are simple F# functions. All of them as first parameter accepts &lt;code&gt;HttpContext&lt;/code&gt; object - it’s an ASP.NET class that contains all information about incoming request, response, server, environment and other data that was injected into it by framework. Actions that are using ID of the item, such as &lt;code&gt;showAction&lt;/code&gt; or &lt;code&gt;editAction&lt;/code&gt; are functions that get &lt;code&gt;id&lt;/code&gt; as a second parameter. The &lt;code&gt;id&lt;/code&gt; may be generic but we currently supports limited set of the possible types to which we can decode ID from URL.&lt;/p&gt;

&lt;p&gt;Supported types:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;char&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;int64&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;float&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;System.Guid&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;In case you’d need some custom ID type, I’d recommend using &lt;code&gt;string&lt;/code&gt; and deserializing it manually. Another important limitation of current controllers is fact that all actions needs to use same ID type in one controller instance. Again, if you’d need different ID types - use &lt;code&gt;string&lt;/code&gt; and deserialize it manually.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example action implementation may look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let myIndex (ctx: HttpContext) = Controller.text ctx &quot;Hello world&quot;

let myShow (ctx: HttpContext) (id: string) =
    id
    |&amp;gt; sprintf &quot;Hello world, %s&quot;
    |&amp;gt; Controller.text ctx

let myController = controller {
    index myIndex
    show myShow
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Action output type&lt;/h1&gt;

&lt;p&gt;If you’ll hover over &lt;code&gt;myIndex&lt;/code&gt; or &lt;code&gt;myShow&lt;/code&gt; you’ll notice that return type of those functions is &lt;code&gt;Task&amp;lt;HttpContext option&amp;gt;&lt;/code&gt;. First thing - all actions in Saturn’s controllers are asynchronous by design, and they are using standard .Net Task to model it. However, they’re generic over what type is actually returned by the task. If you return &lt;code&gt;HttpContext option&lt;/code&gt; you’re following standard path of integration with Giraffe (web library on top of which Saturn is built). This gives you not only full control over what’s going on and how your response is modified, but also provides ability to integrate with existing Giraffe ecosystem. Additionally Saturn itself provides rich set of helpers that return &lt;code&gt;Task&amp;lt;HttpContext option&amp;gt;&lt;/code&gt; in &lt;code&gt;Controller&lt;/code&gt; module (example of this is &lt;code&gt;Controller.text&lt;/code&gt; function used in example, that sets content of the response to given string, and also sets appropriate response header).&lt;/p&gt;

&lt;p&gt;But returning &lt;code&gt;Task&amp;lt;HttpContext option&amp;gt;&lt;/code&gt; is not only option. You can also return &lt;code&gt;Task&amp;lt;'a&amp;gt;&lt;/code&gt; (where &lt;code&gt;'a&lt;/code&gt; is any type) and Saturn will perform automatic output content negotiation. In such case Saturn will check output type of your action, check what’s the client preference based on the &lt;code&gt;Accept&lt;/code&gt; header (if &lt;code&gt;Accept&lt;/code&gt; header is not present, &lt;code&gt;Content-Type&lt;/code&gt; header will be used instead) and decide what’s the best way to handle response object:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If you return &lt;code&gt;string&lt;/code&gt; Saturn will return string with &lt;code&gt;text/plain&lt;/code&gt; or &lt;code&gt;text/html&lt;/code&gt;&lt;code&gt;Content-Type&lt;/code&gt; depending on &lt;code&gt;Accept&lt;/code&gt; header&lt;/li&gt;
  &lt;li&gt;If you return &lt;code&gt;GiraffeViewEngine.XmlNode&lt;/code&gt; (Giraffe’s view object) and client accepts &lt;code&gt;text/html&lt;/code&gt; responses Saturn will render the view and return to client&lt;/li&gt;
  &lt;li&gt;If you return any other type it will be deserialized to JSON (with &lt;code&gt;application/json&lt;/code&gt; &lt;code&gt;Content-Type&lt;/code&gt;) unless client doesn’t accept JSON response - in such case XML will be tried.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Same output content negotiation algorithm is provided by &lt;code&gt;Controller.response&lt;/code&gt; helper.&lt;/p&gt;

&lt;p&gt;Example action implementation using output content negotiation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let myIndex (ctx: HttpContext) =
   task { return &quot;Hello world&quot; }

let myShow (ctx: HttpContext) (id: string) =
    task {
        return sprintf &quot;Hello world, %s&quot; id
    }

let myAdd (ctx: HttpContext) =
    task { return DateTime.Now }

let myController = controller {
    index myIndex
    show myShow
    add myAdd
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;h1&gt;Versioning&lt;/h1&gt;

&lt;p&gt;Versioning of the endpoints is one of the most important cross cutting concernes in web applications… and most of the web frameworks don’t provide any built-in ways to handle it easily. Saturn provides opinionated way to easily version your controllers. Saturn is using &lt;a href=&quot;https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/&quot;&gt;1 of 3 wrong ways&lt;/a&gt; - custom header &lt;code&gt;x-controller-version&lt;/code&gt; to decide which version of the control should be called. Of course, if you don’t like this strategy, Saturn makes it easy to fallback to bit lower level of abstraction, so you can create differently wrong versioning strategy.&lt;/p&gt;

&lt;p&gt;The implementation of versioning in your controllers is trivial - it’s just adding one additional operation to your controllers - &lt;code&gt;version&lt;/code&gt;. Here’s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
let myController = controller {
    index myIndex
    show myShow
    add myAdd
}

let myControllerV1 = controller {
    version &quot;1&quot;

    index myIndex
    show myShow
    add myAdd
}

let appRouter = router {
    forward &quot;/endpoint&quot; myControllerV1
    forward &quot;/endpoint&quot; myController
}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Since controller without version is not performing any checks it’s important to plug controllers in correct order in your router - the controller without any version should go lowest.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;Plugs&lt;/h1&gt;

&lt;p&gt;Another important feature of any web framework is ability of (declaratively) plugging some additional actions/modifications for particular actions in controllers. For example, in ASP .NET MVC this is done with attributes and enables features like authorization and authentication for particular actions in controller (and many, many more other features and cross cutting concerns). Saturn provides flexible mechanism to provide such functionalities using controller plugs, using one simple CE operation - &lt;code&gt;plug&lt;/code&gt; - that accepts list of the actions to which it should apply and the plug function. Plug implementation is any &lt;code&gt;HttpHandler&lt;/code&gt; which means that it integrates well if existing ecosystem and helpers, and plug implementation is decoupled from the controller itself, which means you can easily create plugs for cross cutting concerns such as logging or authorization and reuse them across many controllers in your application.&lt;/p&gt;

&lt;p&gt;Example implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
let myControllerV1 = controller {
    plug [All] (setHttpHeader &quot;user-controller-all&quot; &quot;123&quot;)
    plug [Index; Show] (setHttpHeader &quot;user-controller-some&quot; &quot;456&quot;)
    plug (except Index) (setHttpHeader &quot;user-controller-except&quot; &quot;789&quot;)

    index myIndex
    show myShow
    add myAdd
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Subcontrollers&lt;/h1&gt;

&lt;p&gt;Last important feature of the &lt;code&gt;controller&lt;/code&gt; is ability to embed controllers. This, again, is fairly opinionated feature that follows REST-ish conventions. Subcontroller should be used in case when one particular item (represented in controller by &lt;code&gt;/:id&lt;/code&gt;) has some child items - for example &lt;code&gt;blog&lt;/code&gt; item contains list of &lt;code&gt;post&lt;/code&gt; items. Or &lt;code&gt;post&lt;/code&gt; item contains list of &lt;code&gt;comment&lt;/code&gt; items. Subcontroller is subrouted into &lt;code&gt;/:id/:subcontrollerPath&lt;/code&gt; route of original controller (so for example &lt;code&gt;/:id/:subcontrollerPath/:id2&lt;/code&gt; shows the particular comment, or &lt;code&gt;/:id/:subcontrollerPath/add&lt;/code&gt; will show form for adding new child item to the parent item with given ID). Adding subcontroller to your controller is done by using yet another custom operation in CE - &lt;code&gt;subController&lt;/code&gt; that takes path of the subcontroller and child controller as inputs (passing ID to this subcontroller).&lt;/p&gt;

&lt;p&gt;Example implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let commentController userId = controller {
    index (fun ctx -&amp;gt; (sprintf &quot;Comment Index handler for user %i&quot; userId ) |&amp;gt; Controller.text ctx)
    add (fun ctx -&amp;gt; (sprintf &quot;Comment Add handler for user %i&quot; userId ) |&amp;gt; Controller.text ctx)
    show (fun ctx id -&amp;gt; (sprintf &quot;Show comment %s handler for user %i&quot; id userId ) |&amp;gt; Controller.text ctx)
    edit (fun ctx id -&amp;gt; (sprintf &quot;Edit comment %s handler for user %i&quot; id userId )  |&amp;gt; Controller.text ctx)
}

let userControllerVersion1 = controller {
    subController &quot;/comments&quot; commentController

    index (fun ctx -&amp;gt; &quot;Index handler&quot; |&amp;gt; Controller.text ctx)
    add (fun ctx -&amp;gt; &quot;Add handler&quot; |&amp;gt; Controller.text ctx)
    show (fun ctx id -&amp;gt; (sprintf &quot;Show handler - %i&quot; id) |&amp;gt; Controller.text ctx)
    edit (fun ctx id -&amp;gt; (sprintf &quot;Edit handler - %i&quot; id) |&amp;gt; Controller.text ctx)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;subController&lt;/code&gt; operation actually accepts any &lt;code&gt;HttpHandler&lt;/code&gt; not only controllers, which means you anything in there. Also, you can add multiple subcontrollers to one controller which may be useful… for example in combination with controller versioning feature.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post I’ve tried to present all features and power of Saturn’s high level abstraction - &lt;code&gt;controller&lt;/code&gt;, and flexible design they allow.&lt;/p&gt;
</description>
                <pubDate>Fri, 20 Jul 2018 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Magic-of-Saturn-controllers</link>
                <guid isPermaLink="true">http://kcieslak.io/Magic-of-Saturn-controllers</guid>
                
                <category>F#</category>
                
                <category>Saturn</category>
                
                <category>Web</category>
                
                
            </item>
        
    </channel>
</rss>