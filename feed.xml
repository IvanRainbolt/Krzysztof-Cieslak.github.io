<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>F# Reflections</title>
        <description>Blog about F# and FP Programming</description>
        <link>http://kcieslak.io/</link>
        <atom:link href="http://kcieslak.io/feed.xml" rel="self" type="application/rss+xml"/>
        <pubDate>Fri, 20 Jul 2018 22:19:07 +0200</pubDate>
        <lastBuildDate>Fri, 20 Jul 2018 22:19:07 +0200</lastBuildDate>
        <generator>Jekyll v3.3.1</generator>
        
            <item>
                <title>Magic of Saturn controllers</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://saturnframework.org&quot;&gt;Saturn&lt;/a&gt; is new F# web framework that implements well know design pattern - MVC - in more functional way. Despite Saturn being fairly young project it’s getting more and more popular among F# community and industrial users. One of the main Saturn’s goals is to create high level abstractions that will enable developers to focus on writing domain, business code instead of focusing on creating correct routing for your application or setting right response headers. One of such abstractions, that I want to talk about today, is &lt;code&gt;controller&lt;/code&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;blockquote&gt;
  &lt;p&gt;This article was created for Saturn version 0.7.x&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;Basic usage&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;controller&lt;/code&gt; is simple computation expression (CE) that enables you to easily implement application endpoint following REST-ish conventions. It can be used for implementing endpoints that renders views if you’re building application using server side rendering, or just return serialized data if you’re building API or your application is using client side rendering. Just like all other CEs used in Saturn, &lt;code&gt;controller&lt;/code&gt; provides set of custom operations that you can use. And, what’s important, all operations in &lt;code&gt;controller&lt;/code&gt; CE are optional, which means you can easily choose which subset of functionality you need. Example, basic implementation looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let resource = controller {
    index indexAction
    show showAction
    add addAction
    edit editAction
    create createAction
    update updateAction
    patch patchAction
    delete deleteAction
    deleteAll deleteAllAction
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s now go one by one, and describe each operation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;index&lt;/code&gt; - mapped into &lt;code&gt;GET&lt;/code&gt; request at &lt;code&gt;/&lt;/code&gt; endpoint. Usually used to render a view displaying list of items, or return whole list of items.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;show&lt;/code&gt; - mapped into &lt;code&gt;GET&lt;/code&gt; request at &lt;code&gt;/:id&lt;/code&gt; endpoint. Usually used to render a view displaying details of particular item, or return single item with given id.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;add&lt;/code&gt; - mapped into &lt;code&gt;GET&lt;/code&gt; request at &lt;code&gt;/add&lt;/code&gt; endpoint. Used to render a form for adding new item. Usually not used in API controllers.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;edit&lt;/code&gt; - mapped into &lt;code&gt;GET&lt;/code&gt; request at &lt;code&gt;/:id/edit&lt;/code&gt;. Used to render a form for editing existing item. Usually not used in API controllers.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;create&lt;/code&gt; - mapped into &lt;code&gt;POST&lt;/code&gt; request at &lt;code&gt;/&lt;/code&gt; endpoint. Used to create and save new item.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;update&lt;/code&gt; - mapped into &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;PUT&lt;/code&gt; requests at &lt;code&gt;/:id&lt;/code&gt; endpoint. Used to update existing item. Usually replaces original item (keeping id), and requires are fields to be filled in the incoming item.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;patch&lt;/code&gt; - mapped into &lt;code&gt;PATCH&lt;/code&gt; request at &lt;code&gt;/:id&lt;/code&gt; endpoint. Used to update existing item. Usually only changes some fields of original item, request body contains only changed fields or JSON Patch object.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;delete&lt;/code&gt; - mapped into &lt;code&gt;DELETE&lt;/code&gt; request at &lt;code&gt;/:id&lt;/code&gt; endpoint. Used to delete or deactivate existing item.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;deleteAll&lt;/code&gt; - mapped into &lt;code&gt;DELETE&lt;/code&gt; request at &lt;code&gt;/&lt;/code&gt; endpoint. Used to delete or deactivate all items.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Please remember that Saturn is not enforcing behaviour or inputs of actions any way, so above descriptions are suggestions and best practices, not something that’s encoded in framework. The only thing that controller provides is set in stone routing structure.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;Actions implementation&lt;/h1&gt;

&lt;p&gt;All actions &lt;code&gt;indexAction&lt;/code&gt;, &lt;code&gt;showAction&lt;/code&gt; … are simple F# functions. All of them as first parameter accepts &lt;code&gt;HttpContext&lt;/code&gt; object - it’s an ASP.NET class that contains all information about incoming request, response, server, environment and other data that was injected into it by framework. Actions that are using ID of the item, such as &lt;code&gt;showAction&lt;/code&gt; or &lt;code&gt;editAction&lt;/code&gt; are functions that get &lt;code&gt;id&lt;/code&gt; as a second parameter. The &lt;code&gt;id&lt;/code&gt; may be generic but we currently supports limited set of the possible types to which we can decode ID from URL.&lt;/p&gt;

&lt;p&gt;Supported types:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;char&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;int64&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;float&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;System.Guid&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;In case you’d need some custom ID type, I’d recommend using &lt;code&gt;string&lt;/code&gt; and deserializing it manually. Another important limitation of current controllers is fact that all actions needs to use same ID type in one controller instance. Again, if you’d need different ID types - use &lt;code&gt;string&lt;/code&gt; and deserialize it manually.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example action implementation may look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let myIndex (ctx: HttpContext) = Controller.text ctx &quot;Hello world&quot;

let myShow (ctx: HttpContext) (id: string) =
    id
    |&amp;gt; sprintf &quot;Hello world, %s&quot;
    |&amp;gt; Controller.text ctx

let myController = controller {
    index myIndex
    show myShow
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Action output type&lt;/h1&gt;

&lt;p&gt;If you’ll hover over &lt;code&gt;myIndex&lt;/code&gt; or &lt;code&gt;myShow&lt;/code&gt; you’ll notice that return type of those functions is &lt;code&gt;Task&amp;lt;HttpContext option&amp;gt;&lt;/code&gt;. First thing - all actions in Saturn’s controllers are asynchronous by design, and they are using standard .Net Task to model it. However, they’re generic over what type is actually returned by the task. If you return &lt;code&gt;HttpContext option&lt;/code&gt; you’re following standard path of integration with Giraffe (web library on top of which Saturn is built). This gives you not only full control over what’s going on and how your response is modified, but also provides ability to integrate with existing Giraffe ecosystem. Additionally Saturn itself provides rich set of helpers that return &lt;code&gt;Task&amp;lt;HttpContext option&amp;gt;&lt;/code&gt; in &lt;code&gt;Controller&lt;/code&gt; module (example of this is &lt;code&gt;Controller.text&lt;/code&gt; function used in example, that sets content of the response to given string, and also sets appropriate response header).&lt;/p&gt;

&lt;p&gt;But returning &lt;code&gt;Task&amp;lt;HttpContext option&amp;gt;&lt;/code&gt; is not only option. You can also return &lt;code&gt;Task&amp;lt;'a&amp;gt;&lt;/code&gt; (where &lt;code&gt;'a&lt;/code&gt; is any type) and Saturn will perform automatic output content negotiation. In such case Saturn will check output type of your action, check what’s the client preference based on the &lt;code&gt;Accept&lt;/code&gt; header (if &lt;code&gt;Accept&lt;/code&gt; header is not present, &lt;code&gt;Content-Type&lt;/code&gt; header will be used instead) and decide what’s the best way to handle response object:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If you return &lt;code&gt;string&lt;/code&gt; Saturn will return string with &lt;code&gt;text/plain&lt;/code&gt; or &lt;code&gt;text/html&lt;/code&gt;&lt;code&gt;Content-Type&lt;/code&gt; depending on &lt;code&gt;Accept&lt;/code&gt; header&lt;/li&gt;
  &lt;li&gt;If you return &lt;code&gt;GiraffeViewEngine.XmlNode&lt;/code&gt; (Giraffe’s view object) and client accepts &lt;code&gt;text/html&lt;/code&gt; responses Saturn will render the view and return to client&lt;/li&gt;
  &lt;li&gt;If you return any other type it will be deserialized to JSON (with &lt;code&gt;application/json&lt;/code&gt; &lt;code&gt;Content-Type&lt;/code&gt;) unless client doesn’t accept JSON response - in such case XML will be tried.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Same output content negotiation algorithm is provided by &lt;code&gt;Controller.response&lt;/code&gt; helper.&lt;/p&gt;

&lt;p&gt;Example action implementation using output content negotiation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let myIndex (ctx: HttpContext) =
   task { return &quot;Hello world&quot; }

let myShow (ctx: HttpContext) (id: string) =
    task {
        return sprintf &quot;Hello world, %s&quot; id
    }

let myAdd (ctx: HttpContext) =
    task { return DateTime.Now }

let myController = controller {
    index myIndex
    show myShow
    add myAdd
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;h1&gt;Versioning&lt;/h1&gt;

&lt;p&gt;Versioning of the endpoints is one of the most important cross cutting concernes in web applications… and most of the web frameworks don’t provide any built-in ways to handle it easily. Saturn provides opinionated way to easily version your controllers. Saturn is using &lt;a href=&quot;https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/&quot;&gt;1 of 3 wrong ways&lt;/a&gt; - custom header &lt;code&gt;x-controller-version&lt;/code&gt; to decide which version of the control should be called. Of course, if you don’t like this strategy, Saturn makes it easy to fallback to bit lower level of abstraction, so you can create differently wrong versioning strategy.&lt;/p&gt;

&lt;p&gt;The implementation of versioning in your controllers is trivial - it’s just adding one additional operation to your controllers - &lt;code&gt;version&lt;/code&gt;. Here’s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
let myController = controller {
    index myIndex
    show myShow
    add myAdd
}

let myControllerV1 = controller {
    version &quot;1&quot;

    index myIndex
    show myShow
    add myAdd
}

let appRouter = router {
    forward &quot;/endpoint&quot; myControllerV1
    forward &quot;/endpoint&quot; myController
}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Since controller without version is not performing any checks it’s important to plug controllers in correct order in your router - the controller without any version should go lowest.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;Plugs&lt;/h1&gt;

&lt;p&gt;Another important feature of any web framework is ability of (declaratively) plugging some additional actions/modifications for particular actions in controllers. For example, in ASP .NET MVC this is done with attributes and enables features like authorization and authentication for particular actions in controller (and many, many more other features and cross cutting concerns). Saturn provides flexible mechanism to provide such functionalities using controller plugs, using one simple CE operation - &lt;code&gt;plug&lt;/code&gt; - that accepts list of the actions to which it should apply and the plug function. Plug implementation is any &lt;code&gt;HttpHandler&lt;/code&gt; which means that it integrates well if existing ecosystem and helpers, and plug implementation is decoupled from the controller itself, which means you can easily create plugs for cross cutting concerns such as logging or authorization and reuse them across many controllers in your application.&lt;/p&gt;

&lt;p&gt;Example implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
let myControllerV1 = controller {
    plug [All] (setHttpHeader &quot;user-controller-all&quot; &quot;123&quot;)
    plug [Index; Show] (setHttpHeader &quot;user-controller-some&quot; &quot;456&quot;)
    plug (except Index) (setHttpHeader &quot;user-controller-except&quot; &quot;789&quot;)

    index myIndex
    show myShow
    add myAdd
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Subcontrollers&lt;/h1&gt;

&lt;p&gt;Last important feature of the &lt;code&gt;controller&lt;/code&gt; is ability to embed controllers. This, again, is fairly opinionated feature that follows REST-ish conventions. Subcontroller should be used in case when one particular item (represented in controller by &lt;code&gt;/:id&lt;/code&gt;) has some child items - for example &lt;code&gt;blog&lt;/code&gt; item contains list of &lt;code&gt;post&lt;/code&gt; items. Or &lt;code&gt;post&lt;/code&gt; item contains list of &lt;code&gt;comment&lt;/code&gt; items. Subcontroller is subrouted into &lt;code&gt;/:id/:subcontrollerPath&lt;/code&gt; route of original controller (so for example &lt;code&gt;/:id/:subcontrollerPath/:id2&lt;/code&gt; shows the particular comment, or &lt;code&gt;/:id/:subcontrollerPath/add&lt;/code&gt; will show form for adding new child item to the parent item with given ID). Adding subcontroller to your controller is done by using yet another custom operation in CE - &lt;code&gt;subController&lt;/code&gt; that takes path of the subcontroller and child controller as inputs (passing ID to this subcontroller).&lt;/p&gt;

&lt;p&gt;Example implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let commentController userId = controller {
    index (fun ctx -&amp;gt; (sprintf &quot;Comment Index handler for user %i&quot; userId ) |&amp;gt; Controller.text ctx)
    add (fun ctx -&amp;gt; (sprintf &quot;Comment Add handler for user %i&quot; userId ) |&amp;gt; Controller.text ctx)
    show (fun ctx id -&amp;gt; (sprintf &quot;Show comment %s handler for user %i&quot; id userId ) |&amp;gt; Controller.text ctx)
    edit (fun ctx id -&amp;gt; (sprintf &quot;Edit comment %s handler for user %i&quot; id userId )  |&amp;gt; Controller.text ctx)
}

let userControllerVersion1 = controller {
    subController &quot;/comments&quot; commentController

    index (fun ctx -&amp;gt; &quot;Index handler&quot; |&amp;gt; Controller.text ctx)
    add (fun ctx -&amp;gt; &quot;Add handler&quot; |&amp;gt; Controller.text ctx)
    show (fun ctx id -&amp;gt; (sprintf &quot;Show handler - %i&quot; id) |&amp;gt; Controller.text ctx)
    edit (fun ctx id -&amp;gt; (sprintf &quot;Edit handler - %i&quot; id) |&amp;gt; Controller.text ctx)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;subController&lt;/code&gt; operation actually accepts any &lt;code&gt;HttpHandler&lt;/code&gt; not only controllers, which means you anything in there. Also, you can add multiple subcontrollers to one controller which may be useful… for example in combination with controller versioning feature.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post I’ve tried to present all features and power of Saturn’s high level abstraction - &lt;code&gt;controller&lt;/code&gt;, and flexible design they allow.&lt;/p&gt;
</description>
                <pubDate>Fri, 20 Jul 2018 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Magic-of-Saturn-controllers</link>
                <guid isPermaLink="true">http://kcieslak.io/Magic-of-Saturn-controllers</guid>
                
                <category>F#</category>
                
                <category>Saturn</category>
                
                <category>Web</category>
                
                
            </item>
        
            <item>
                <title>OSS and Community. The Story</title>
                <description>&lt;h1&gt;Disclaimer&lt;/h1&gt;

&lt;p&gt;Before, we even start - this blog post will be different than others on the page. I usually write about some technical things, sometimes about open source and community based software, but I always try to be rather objective. And this post will be different. It’s totally subjective and personal… because it’s about me, and my story with F# Community.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Now&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://www.lambdadays.org/lambdadays2018&quot;&gt;Lambda Days&lt;/a&gt; has ended yet again. It was my 4th times here and as always it delivered - great content, fantastic speakers, interesting conversations, perfect organization. It’s definitely my favorite conference in Europe. And as always I could hang out with some great friends from Community - Evelina and Tomas, Felienne, John, Tomasz, Bartosz and others from polish F# community. The contrast between meeting real people, building cool stuff with F# and fighting random Twitter haters couldn’t be bigger.&lt;/p&gt;

&lt;p&gt;So, I guess you wonder now why I even mention that. “You speak at the many conferences, don’t you? Who cares about this particular one? And you wasn’t even a speaker on this.”. Fair enough. But Lambda Days is special for one small reason - it’s a place where this story has started.&lt;/p&gt;

&lt;h1&gt;Beginning&lt;/h1&gt;

&lt;p&gt;So yeah, it was 3 years ago. Second edition of Lambda Days, first one I’ve attended. I was super excited - it was first FP conference I’ve attended and what’s more there were lot of F# talks happening - Tomas and Evelina were there, as well as Andrea, Tomasz Jaskula and others. And back then I was pretty unknown - I’ve been doing F# for some time already but as a hobby - I’ve been working in some small C# shop, I haven’t been doing any open source stuff, and if anyone heard about me on Twitter… well, let’s just say that I was much harsher in my criticism of MSFT and C# than I’m now :)&lt;/p&gt;

&lt;p&gt;So I was at this conference, ready to watch some talks of people I only knew from online world that were way better developers than me, and were way smarter then me, expecting not to understand too much and maybe learn something interesting… And yeah, they were all that, done great talks, that I totally didn’t understand (I still doesn’t understand their talks, but at least I learnt how to pretend). But it turned out that those F# heroes are not only great developers and super intelligent people, but they are also normal, cool, sometimes wierd people that you can do silly jokes with and you can spend time with them having lot of fun and interesting conversations… not only about F#. So we had lot of fun (as proved by &lt;a href=&quot;fhash.org&quot;&gt;fhash.org&lt;/a&gt;), drunk a lot… and that’s when I’ve fallen in love with F# Community.&lt;/p&gt;

&lt;h1&gt;The Project&lt;/h1&gt;

&lt;p&gt;Soo… 1 month later I’ve started the project, which is now known as Ionide. Of course, Tomas helped me a lot - he suggested to use F# to JS compiler (FunScript) [my initial hack was written in CoffeScript - as it was language suggested for Atom plugins], he’s done some magic to make sure that JS produced by FunScript was working in Atom (FunScript, unlike Fable, was not really producing good JS code). So I started to write this plugin on rather bad platform (Atom extension system sounds cool in theory… but well, it’s just a theory) and at some point of time wierd thing, I still don’t really understand happened - people started to use the project. What’s more shocking - they seemed to like it. A lot. In September I’ve released version 1.0, with new, nice name, webpage and some reddit announcements. What’s even more interesting - people were rather vocal about the fact they’re using Ionide, it got quite a lot of traction in the general F# community. And it resulted in MSFT noticing it. In October 2015 I was invited by VSCode Team to private preview of extension API, and for next month I’ve been working (well… “working”) on the new plugin - Ionide-VSCode - that was publicly released on day 0, during Connect(); conference in November.&lt;/p&gt;

&lt;h1&gt;Side effects&lt;/h1&gt;

&lt;p&gt;Interestingly enough there has been some side effects of making Ionide and getting some users. Firstly, I’ve started my company - &lt;a href=&quot;http://lambdafactory.io&quot;&gt;Lambda Factory&lt;/a&gt; in January 2016 and I’ve started to use F# for commercial work. I’ve also been invited to multiple conferences in 2016 - NDC London, F# eXchange, .Net Fringe (&amp;lt;3), F# Creators Workshop. I’ve been 2 times in Vancouver in 2016 for one of my clients. All those things has been great fun, and are clear result of Ionide - I got my first client thanks to it, my first, really terrible conference talks were about Ionide. In general 2016 was great year - Ionide was getting lot of new features, Fable was released, I’ve ported Ionide to Fable while flying over the Atlantic. And Ionide got lot of users, it was “Featured extension” for a while in VSCode marketplace, it was highest rated extension in VSCode marketplace for a while, and the userbase slowly moved from Atom version to VSCode.&lt;/p&gt;

&lt;p&gt;But it was also a year of several failures in my OSS activity - I haven’t managed to create healthy community around the Ionide - it’s been basically one man show. Some my other OSS projects were not really successful. Forge, which was started in January 2016, has not become a go-to tool for the community. While in case of Forge I can still say about relative success of the project since it’s used to this day in Ionide, the other project I really cared about back then - FsToml - was total failure, and resulted in burnt out, crushed dreams, and broken heart. And well, I was called troll by some members of community for suggesting something like FsToml in one of the blog post.&lt;/p&gt;

&lt;h1&gt;Stabilization&lt;/h1&gt;

&lt;p&gt;My opinions about 2017 are really split - on the one hand it was clearly good year for Ionide - it has become one of the best way to develop F#, and best xplat way. It’s also probably one of the best editor tooling for FP languages in general, and one of the best VSCode extensions in the marketplace (which is decent achievement given that many important VSCode extensions are maintained by MSFT). It got more and more features, including innovating features like CodeLenses and LineLenses, the decently working project explorer, F# Code Outline and many more. And the user base has been constantly growing hitting couple of thousands users according to my estimate (which seems like really decent number given size of F# userbase). It’s also been used by nearly all F# speakers during their talks on various F# conferences and events. And what’s probably most important - thanks to amazing work by Enrico we’ve continuously had best support for .Net Core from any F# IDE - including support for .Net Core 2.0 on the release day.&lt;/p&gt;

&lt;p&gt;For me it was also decent year - I’ve spoken at some great conferences - F# eXchange (again), nCrafts, FableConf, Remmidemi, Get.Net Conf, CodeMotion Milan. I’ve worked on some cool stuff, doing Azure Functions with F# for essentially whole year. I’ve started to move slowly into training market, and I’ve done couple of internal trainings what I’ve really enjoyed and is something I want to focus on in the future.&lt;/p&gt;

&lt;p&gt;But I think it was also bad year in many areas. First of all - Fornax, the F# static site generator I’ve created, didn’t get any attention. Secondly, I didn’t manage to create any good way to sustain Ionide. General atmosphere in F# Twitter community was getting worse and worse due to some vocal minority that’s able only to complain about lack of MSFT investments and lack of quality in tools they get for free. There happened some dramas around F# web stack which was super sad to see. I was not invited to speak at .Net Fringe and Open F# which was really disappointing for me.&lt;/p&gt;

&lt;h1&gt;Current state&lt;/h1&gt;

&lt;p&gt;I really believe into what I’ve written couple of months ago on Twitter - F# ecosystem is in it’s best state in last couple of years (and probably ever). The usages numbers for all main editors are growing, we have some great xplat editor experience with Ionide, F# web stack (SAFE) is getting more and more mature, providing amazing development experience for end-to-end programming. MSFT actions clearly show that they are committed to F# - no one is rewriting language plugin to latest technologies that brings it up-to-date with C# integration, or includes support for Azure Functions, adds F# to &lt;code&gt;dotnet&lt;/code&gt; CLI out of the box, and hire new people to the Team just to stop supporting the language. And I think it’s not the statement I could do 2 years ago.&lt;/p&gt;

&lt;p&gt;At the same time we build castle on the sand - looking at such important parts of F# ecosystem as Ionide, Paket, FAKE, FSAC, Fable, F#.Formatting - I can’t understand why any of those projects don’t have commercial sponsoring. There are tens of thousands of F# users, hundreds of companies using F# for their commercial products. EVERYONE is using those libraries and tools provided by F# community. And no one wants to support those projects. Even if only 1% of companies using F# provided financial support it would make huge difference for those projects. Even if only 1% of F# developers started regularly contribute to OSS libs it would create thriving ecosystem. But I guess doing nothing, using the tools and libraries you get for free, and complaining on social media about quality of ecosystem is what Real Developers creating Real Software do… what do I know, I’m just simple hipster doing OSS :)&lt;/p&gt;

&lt;p&gt;Ionide is in the unsustainable state - over last 3 years I’ve spent thousands of hours working on it. Feel free to calculate how much it would costed if that was tool that your company developed internally. Feel free to calculate how much money you get if you think that Ionide gives you 5% productivity boost… and well, I guess that productivity boost was even higher when you wanted to do .Net Core 2.0 and no other editor supported it :)&lt;/p&gt;

&lt;p&gt;And Ionide is way smaller project than Paket, or FAKE, or Fable… How many hours your developer saved thanks to having actually working dependency management system, reasonable build processes or being able to write front end code in sane, type safe, modern language?&lt;/p&gt;

&lt;p&gt;I guess we all just need to hope that maintainers of those projects will never quit, get bored or decide that they have better things to do in their spare time…&lt;/p&gt;
</description>
                <pubDate>Fri, 23 Feb 2018 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/OSS-The-Story</link>
                <guid isPermaLink="true">http://kcieslak.io/OSS-The-Story</guid>
                
                <category>Open Source</category>
                
                <category>Community</category>
                
                <category>F#</category>
                
                
            </item>
        
            <item>
                <title>Reinventing MVC pattern for web programming with F#</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;A couple of weeks ago, I’ve posted &lt;a href=&quot;https://twitter.com/k_cieslak/status/944349420937793536&quot;&gt;yet-another-controversial-tweet&lt;/a&gt; - this time criticizing F# libraries for web programming and saying that “they focus on wrong problem”. In this post I’d like to expand this thought a bit, describe what is, in my opinion, problem with those libraries, and introduce a project that will try to fix those problems.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;DISCLAIMER: In the original tweet I’ve mentioned three libraries - &lt;a href=&quot;https://suave.io/&quot;&gt;Suave&lt;/a&gt;, &lt;a href=&quot;https://github.com/giraffe-fsharp/Giraffe&quot;&gt;Giraffe&lt;/a&gt;, and &lt;a href=&quot;https://freya.io/&quot;&gt;Freya&lt;/a&gt;. First of all, if we were to talk about all major F# web solutions we should also mention &lt;a href=&quot;https://websharper.com/&quot;&gt;WebSharper&lt;/a&gt;. Secondly, my experience with Freya and WebSharper is fairly limited - I’ve never used any of them in commercial application - so in this post I won’t talk about them but focus on Suave and Giraffe&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;DISCLAIMER 2: I really like both Suave and Giraffe - I’ve been using Suave for years in multiple commercial applications and I think it’s really good project. Also I’ve been investigating and testing Giraffe for last couple of months and I also believe it’s good project with a bright future.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;h1&gt;The model&lt;/h1&gt;

&lt;p&gt;So let’s start with describing a programming model that Suave and Giraffe use. Both libraries are using a really similar model of building applications from small functions that takes &lt;code&gt;HttpContext&lt;/code&gt; as an input and returns a modified &lt;code&gt;HttpContext&lt;/code&gt; and then they use combinators functions to combine those small functions and build application with them. This model is really powerful, it provides full control over the flow of the program, and follows some FP principles (building applications as a composition of functions).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There are some small differences between Suave and Giraffe implementation of this model, but going into such details is not in scope of this post.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;The problem&lt;/h1&gt;

&lt;p&gt;While I love the programming model I also believe that both Suave and Giraffe missed an opportunity to build on top of this model. Helper functions provided by both libraries that are the main building block of the applications are really “low level” - they mostly focus on the details of the HTTP protocol. And I think that while this is an useful level of abstraction for some use cases, my experience with building business applications with Suave / Giraffe suggests that this is not a level of abstraction that’s useful for typical, boring-line-of-business applications - and that’s most common use case for most software developers. If we compare Suave / Giraffe with other ecosystems it often feels like writing ASP.Net applications with just middleware - without using MVC / WebAPI abstractions, or writing Elixir web applications with just Plugs - without &lt;a href=&quot;http://phoenixframework.org/&quot;&gt;Phoenix Framework&lt;/a&gt;. Of course there are cases where this lower level of abstraction is a good choice, but success and popularity of such libraries like &lt;a href=&quot;http://rubyonrails.org/&quot;&gt;Rails&lt;/a&gt;, ASP.Net MVC, or Phoenix shows us that developers want to use some higher level of abstraction and focus on solving their business domain problems instead of worrying about the details of the HTTP protocol.&lt;/p&gt;

&lt;h1&gt;Developer experience&lt;/h1&gt;

&lt;p&gt;The previous paragraph was focused on technical issues but let’s now move to something a bit different. Working on OSS tooling for the last couple of years has thought me one important thing - good user experience is sometimes more valuable for project than technical superiority. I also strongly believe that tooling can be a great way to allow people ramp up faster and to teach users some new concepts. A great example of that is &lt;a href=&quot;https://www.jetbrains.com/resharper/&quot;&gt;ReSharper&lt;/a&gt; - while it’s not super popular in F# community ( ;-) ) and some of the features for C# are probably overkill, I strongly believe that ReSharper is one of the most impactful source of information about new language features for C# developers - not every developer is following all news, conferences and announcements but it’s hard to miss when tool starts to give warnings and shows automatic refactorings introducing new language features. In web space great example for such behavior is Phoenix - everything it does in regards of tooling, from new project template through opinionated structure of the project to generators that let users to scaffold some new controllers is designed to make the introduction of most important concepts used in Phoenix easier for new developer.&lt;/p&gt;

&lt;p&gt;I strongly believe that lack of opinionated tooling and opinionated, commonly used way to build web applications is another important issue of Suave and Giraffe. Developers don’t want to focus on making decisions about structuring the project, or wonder how they need to combine things together, or what are best practices - they want to focus on problems of their business. Again, frameworks like Phoenix and Rails are great example of how having such an opinionated way of building web applications works great in practice.&lt;/p&gt;

&lt;h1&gt;Introducing Saturn&lt;/h1&gt;

&lt;p&gt;For the last couple of weeks I’ve been working on &lt;a href=&quot;https://github.com/SaturnFramework/Saturn&quot;&gt;Saturn&lt;/a&gt; - a new F# OSS project that will attempt to solve the problems mentioned above. It’s strongly inspired by some concepts from Phoenix. Before going into details of Saturn an important thing about it is that it builds on top of the existing ecosystem - and to be precise on top of Giraffe - in similar fashion that Phoenix builds on top of Plugs abstraction.&lt;/p&gt;

&lt;h3&gt;Library&lt;/h3&gt;

&lt;p&gt;A core part of Saturn is a library that can be put on top of any existing Giraffe application. This library contains a set of helper functions, tries to hide some complexity of Giraffe (for example manual passing of &lt;code&gt;next&lt;/code&gt; in every function), and what’s most important it introduces several higher level building blocks that can be used to model a web application. Those building blocks are using a nice high level, declarative DSL using computation expressions with custom keywords. Currently in Saturn there exists 4 such higher level building blocks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pipelines&lt;/li&gt;
  &lt;li&gt;Scopes&lt;/li&gt;
  &lt;li&gt;Controllers&lt;/li&gt;
  &lt;li&gt;Applications&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;and now I shall explain each with a code sample.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;pipeline&lt;/code&gt; - the simplest building block provided by Saturn. It can be used to combine multiple &lt;code&gt;HttpHandlers&lt;/code&gt; in a more declarative way without using custom operators. It also provides custom operations that hide some of the Giraffe complexity.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let browser = pipeline {
    plug acceptHtml
    plug putSecureBrowserHeaders
    fetchSession
    set_header &quot;x-pipeline-type&quot; &quot;Browser&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;scope&lt;/code&gt; - it is a DSL that can be used to define routing and combining this routing together with the &lt;code&gt;pipelines&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let defaultView = scope {
    get &quot;/&quot; (renderHtml Index.layout)
    get &quot;/index.html&quot; (redirectTo false &quot;/&quot;)
    get &quot;/default.html&quot; (redirectTo false &quot;/&quot;)
}

let browserRouter = scope {
    error_handler (renderHtml NotFound.layout) //Use the default 404 webpage
    pipe_through browser //Use the default browser pipeline

    forward &quot;&quot; defaultView //Use the default view
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;controller&lt;/code&gt; - it is a DSL for building typical HTTP controllers. It’s using predefined routing inspired by Phoenix’s &lt;code&gt;resource&lt;/code&gt; macro.s&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let resource = controller {
    index indexAction
    show showAction
    add addAction
    edit editAction
    create createAction
    update updateAction
    delete deleteAction
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;application&lt;/code&gt; - it’s a DSL used for defining application settings and ASP.Net configuration. It aims to replace some cumbersome configuration of some ASP.Net features with declarative feature toggles.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;let app = application {
    pipe_through endpointPipe

    error_handler (fun ex _ -&amp;gt; HttpHandlers.renderHtml (InternalError.layout ex))
    router Router.router
    url &quot;http://0.0.0.0:8085/&quot;
    memory_cache
    use_static &quot;static&quot;
    use_gzip
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important thing about Saturn’s computation expression and those higher level building blocks - &lt;code&gt;pipeline&lt;/code&gt;, &lt;code&gt;scope&lt;/code&gt; and &lt;code&gt;controller&lt;/code&gt; is that they are not introducing any additional abstraction in terms of types - they are transformed to standard Giraffe &lt;code&gt;HttpHandler&lt;/code&gt; which means they are composable with each other and with other, existing &lt;code&gt;HttpHandlers&lt;/code&gt; that you may have.&lt;/p&gt;

&lt;h3&gt;Tooling&lt;/h3&gt;

&lt;p&gt;The other, as important as core library, part of Saturn is additional, opinionated tooling for scaffolding new projects, generating controllers, models, database layer and migration scripts, controlling database migrations etc.&lt;/p&gt;

&lt;p&gt;This tooling comes in 2 parts - first one is a project template that creates default the project structure, and a set of helper files. This is a normal &lt;code&gt;dotnet&lt;/code&gt; project template distributed through NuGet which means you will be able to use &lt;code&gt;dotnet new saturn&lt;/code&gt; to create Saturn applications. The second part of the tooling is a &lt;code&gt;dotnet&lt;/code&gt; extension tool, again, distributed by NuGet. It’s automatically referenced when creating a new Saturn project. So after creating new project you will be able to go to the project folder and run, for example, the &lt;code&gt;dotnet saturn gen&lt;/code&gt; command to generate new controller, views, model and a database layer.&lt;/p&gt;

&lt;h3&gt;Design choices&lt;/h3&gt;

&lt;p&gt;Some parts of the Saturn library and the whole tooling is really opinionated - for example there is no choice to change the way the routing for &lt;code&gt;controller&lt;/code&gt; is created, you can just decide not to implement some of the actions. This may seem restrictive at first, but I strongly believe that it is a good design for the most common use cases. And since everything is based on the composable &lt;code&gt;HttpHandler&lt;/code&gt; model if the default implementation of &lt;code&gt;controller&lt;/code&gt; is not working for you, you can easily recreate it with lower level abstractions such as the &lt;code&gt;scope&lt;/code&gt; DSL.&lt;/p&gt;

&lt;p&gt;Similarly the tooling is really opinionated - the default template out of the box uses &lt;a href=&quot;https://fsprojects.github.io/Paket/&quot;&gt;Paket&lt;/a&gt; for dependency management, &lt;a href=&quot;https://fake.build/&quot;&gt;FAKE&lt;/a&gt; for build script, &lt;a href=&quot;https://github.com/StackExchange/Dapper&quot;&gt;Dapper&lt;/a&gt; for data access, &lt;a href=&quot;https://github.com/canton7/Simple.Migrations&quot;&gt;Simple.Migrations&lt;/a&gt; to handle database migrations. The &lt;code&gt;dotnet saturn&lt;/code&gt; tool generates code assuming certain project structure was created as by the default template, and probably won’t work in other situation.&lt;/p&gt;

&lt;h3&gt;Resources&lt;/h3&gt;

&lt;p&gt;Both Saturn library and tooling are open-source projects that can be found on GitHub and NuGet:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Saturn library - &lt;a href=&quot;https://github.com/SaturnFramework/Saturn&quot;&gt;https://github.com/SaturnFramework/Saturn&lt;/a&gt; and &lt;a href=&quot;https://www.nuget.org/packages/Saturn/&quot;&gt;https://www.nuget.org/packages/Saturn/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Saturn template - &lt;a href=&quot;https://github.com/SaturnFramework/Saturn.Template&quot;&gt;https://github.com/SaturnFramework/Saturn.Template&lt;/a&gt; and &lt;a href=&quot;https://www.nuget.org/packages/Saturn.Template/&quot;&gt;https://www.nuget.org/packages/Saturn.Template/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Saturn &lt;code&gt;dotnet&lt;/code&gt; tool - &lt;a href=&quot;https://github.com/SaturnFramework/Saturn.Dotnet&quot;&gt;https://github.com/SaturnFramework/Saturn.Dotnet&lt;/a&gt; and &lt;a href=&quot;https://www.nuget.org/packages/Saturn.Dotnet/&quot;&gt;https://www.nuget.org/packages/Saturn.Dotnet/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Saturn sample project created using template and generator tool - &lt;a href=&quot;https://github.com/SaturnFramework/Saturn.Sample&quot;&gt;https://github.com/SaturnFramework/Saturn.Sample&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post I’ve tried to point out some problems of Suave and Giraffe and explain why I’ve decided to create new library for web programming with F#.&lt;/p&gt;
</description>
                <pubDate>Thu, 25 Jan 2018 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/Reinventing-MVC-for-web-programming-with-F</link>
                <guid isPermaLink="true">http://kcieslak.io/Reinventing-MVC-for-web-programming-with-F</guid>
                
                <category>F#</category>
                
                <category>Saturn</category>
                
                <category>Web</category>
                
                
            </item>
        
            <item>
                <title>Path to Community based Open Source Software</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Open Source movement has changed the software development world as much as only few things before. Nowadays, it’s almost impossible to develop any project without using OSS - we can be sure that some parts of our stack are developed in the open - from the libraries we download from the package managers, through runtime, to compilers that we are using. Even most conservative, and not-so-long-time-ago actively hostile to OSS companies are now trying to embrace Open Source development.&lt;/p&gt;

&lt;p&gt;But putting code in open by uploading to GitHub, using one of the licenses formally accepted by the &lt;a href=&quot;https://opensource.org/&quot;&gt;Open Source Initiative&lt;/a&gt; is just first step. In my opinion, the real value of the Open Source is not just license, and publicly available code (although, those things are also valuable on their own) but rather possible change in governance model, collaboration with Community and embracing “OSS Culture”.&lt;/p&gt;

&lt;p&gt;In this post I’ll describe different “stages of enlightenment” that company can go through in its path to the Open Source development model that will bring most value to both company and community.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Open Source License&lt;/h1&gt;

&lt;p&gt;Even though, as I’ve mentioned I believe that embracing OSS goes much beyond just having OSS license we can’t really forgot about importance and impact of it. Having OSS license is necessary condition for any project that wants to be called OSS projects. There exist formal definition created by Open Source Initiative called &lt;a href=&quot;https://opensource.org/docs/osd&quot;&gt;Open Source Definition&lt;/a&gt; that sets strict rules that license must follow to be called OSS license.&lt;/p&gt;

&lt;h1&gt;Stage 1 - Code dump&lt;/h1&gt;

&lt;p&gt;At this level, company publishes online projects that its no longer going to invest into or maintain. Probably project failed, was deprecated, or is not profitable. Usually it means that company is no longer interested in the code base - there will be no maintainers, no merged PRs, no responses to issues, and no updates. Rarely, it’s desperation step and company is trying to save project… more often company is trying to save itself from outrage of existing community and userbase after cancelling product. The only way it can end well is when there already exist active project community that will fork project, and continue to maintain project. And usually that’s not a case - since product was developed as a closed sourced project it usually don’t have huge community of developers that are engaged enough to pick up dropped ball.&lt;/p&gt;

&lt;h1&gt;Stage 2 - Open facade&lt;/h1&gt;

&lt;p&gt;In this model company still actively develops the application. Publicly available code is updated regularly, some people from the company are responding to the issues (it’s often used only as a public bug tracker). But all decisions, discussions about new features, bug fixes are done internally in company using private communications channels - community has no impact on the direction of the product, communication is often only one-way - community tries to give it feedback, and suggest way forward but usually there is no respond from the company (even if some of those suggestions are taken into account by some members of the development team), PRs are ignored or actively discouraged. In terms of building community this level is often even worse than previous stage - at least fact that no one cares about project forces the community to step up (if there is need for the project), in this stage community is discouraged to do anything - it has no impact, and someone else is developing the project. In longer term it’s really bad - it creates community that is 100% reliant on the company building the product, and that is unable to step up when needed (for example to extend ecosystem of the project).&lt;/p&gt;

&lt;h1&gt;Stage 3 - Development in the open&lt;/h1&gt;

&lt;p&gt;That’s the level when company can see first real advantages of the Open Source methodologies, it’s also level where most companies trying to embrace OSS are at. In this stage company develops product in the open - code development is done directly on GitHub (or other provider), discussions about product future (or at least some of them) are done using public channels such as issues. Bug reports are treated seriously, feature requests are discussed in with the community in the public, PRs are getting accepted as long as they follow the direction of the project set by company. This level creates decently engaged community - even though community and external developers can’t dictate future of the project, and direction it’s going to be developed in they still can at least quickly fix the bugs and problems they encounter. They also feels that company is taking their feedback seriously - as long as the communication works decently, most external developers can understand why some features are not going to be implemented, or they are not priority. Company can expect decent feedback focused on the technical level - the implementation details, as that’s something that’s focus point of the community. However, communication is still mostly “initialized” by the community - they report bugs, or suggest feature requests and then development team from the company responds to that. Also the company goals are still focal point of the development - they dictate development plans and what feature requests are accepted.&lt;/p&gt;

&lt;h1&gt;Stage 4 - Enlightened despot&lt;/h1&gt;

&lt;p&gt;At this level company starts to understand that short term business goals are less important for the success than long term growth of the community. In terms of development practices it’s really similar to previous level - development is done in the open, things are discussed in public channels, PRs are getting accepted. The difference is really subtle but important - the company is actively trying to look for the feedback about product future (and not only particular features), communication is often initialized by development team, the short term road maps (for example monthly iteration plans) are published so the community knows what the development team is going to focus on. The project is still in the formal control of the company (only members of the company have write access to the repository) but the product is developed with community being focal point of the process. This model creates really engaged community as it puts lot of weight on communication with community. It also makes community feel that it has real impact on the project and that company cares not only about business goals but also abut growth of ecosystem. In this model company can expect lot of really good feedback (both positive and negative), which increases chances of making right decisions about everything… from general decisions about project future to implementation details.&lt;/p&gt;

&lt;h1&gt;Stage 5 - Community based Open Source&lt;/h1&gt;

&lt;p&gt;At this stage company not only focuses on the community, it becomes part of the community equals to all other contributors. Decisions are made by consensus between all parts of the community. The write access to repository is given to the external developers that are not hired by the company, developers that are hired by the company are not getting automatically write access just because they are hired - they need to follow same path as any other member of the community, proof to be a good actor in the community. Community starts to self govern itself - there no longer exist one entity that’s formally more important than other parts of the community. There are no private communication channels as every member of the community has access to information. Really often general project roadmaps stops existing - there is no way of forcing everyone in the community to work on some particular set of features, people tend to work on features they want to have implemented (of course, as long as they are in the scope of the projects and community generally agrees that it’s needed feature). This model brings to the project not only great discussions, great developers (that you wouldn’t necessarily be able to hire) but also great leaders, maintainers and evangelists - people that really care about your project, that will be willing to spend lot of time and effort to develop product and its ecosystem.&lt;/p&gt;

&lt;h1&gt;Problems with embracing Community based OSS&lt;/h1&gt;

&lt;p&gt;Companies are often really afraid of the governance model in which they give up parts of their privileges connected with absolute power over the project. They often state that they need to maintain control to make sure that the product will be developed in right direction (even if they are OK with putting community in the center of this direction, or at least consult it with community). I believe that there are two points that are often missed when this argument is raised. First of all - development team hired by the company still can focus on those features, and those parts of the project that are most important for your business - company still can have its roadmaps and plans that are important for hired development team. Secondly, if we assume that whole community will agree on given direction, community itself will be the best entity that will ensure that product is developed in direction that was agreed on by all parts. As long as the company understands that growth of the community and ecosystem is good for the business in long term, everything should be fine.&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this blog post I’ve described several different models for embracing Open Source development methodologies. I belive that it’s clear that even though putting code in public with OSS license is good move, the real power of the OSS is collaboration with the community - and more effort is put into this collaboration, more control is given over to communing, the better results will be - from creating really engaged user base that cares enough to report bugs and suggest new features on its own, through getting some technical feedback and small bug fixes, to creating real self governing community that will create its own leaders, and evangelists, that will include some people that you couldn’t bring to project otherwise.&lt;/p&gt;

</description>
                <pubDate>Mon, 12 Jun 2017 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Path-to-community-based-OSS</link>
                <guid isPermaLink="true">http://kcieslak.io/Path-to-community-based-OSS</guid>
                
                <category>Open Source</category>
                
                <category>Community</category>
                
                
            </item>
        
            <item>
                <title>Using Paket with Azure Functions</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://azure.microsoft.com/en-us/services/functions/&quot;&gt;Azure Functions&lt;/a&gt; is Microsoft’s implementation of serverless architecture hosted on Azure. It is a solution for easily running small pieces of code, or “functions,” in the cloud. You can write just the code you need for the problem at hand, without worrying about a whole application or the infrastructure to run it. Functions can be written in many different languages, including F#.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Workflow problem&lt;/h1&gt;

&lt;p&gt;Azure Functions can be developed using online editor avaliable on Azure Portal - unfortunetlly it doesn’t provides any rich editing features (autocomplete, tooltips etc) we all like in our normal editors. Luckily, Azure Functions can be also created (and tested) locally, and configured to use GitHub repository (or couple other sources) as source of code, creating very nice Continues Deployment process (coding on local machine -&amp;gt; pushing code to GitHub -&amp;gt; deployment to Azure is automatically triggered). This way we should be able to use our rich editor tooling to develop Functions.&lt;/p&gt;

&lt;p&gt;However, there is small problem. For sake of simplicity, dependency menagment in Azure Functions is using quite a lot of &lt;em&gt;magic&lt;/em&gt;. Essensially, all you need to do is create &lt;code&gt;project.json&lt;/code&gt;, put there your dependency… and then you can just put &lt;code&gt;#r dependency_name&lt;/code&gt; in your deployed &lt;code&gt;.fsx&lt;/code&gt; file to reference it. But as we know, that’s not exactly how things work in normal F# scripting - usually we need to add relative path to &lt;code&gt;.dll&lt;/code&gt;, not just a name of reference. What’s more I haven’t found a way to restore dependencies using Azure Functions CLI tool (which follows Microsoft’s tradition of calling totally unusable software &lt;code&gt;beta&lt;/code&gt;).&lt;/p&gt;

&lt;h1&gt;Paket Strikes Back&lt;/h1&gt;

&lt;p&gt;Instead of fighting with bad workflow suggested by Microsoft, I’ve decided to do what F# developers usually do - use created by Community tool. And our solution to dependency management problem is &lt;a href=&quot;https://fsprojects.github.io/Paket/&quot;&gt;Paket&lt;/a&gt;
We normally initialize Paket, put &lt;code&gt;paket.bootstraper.exe&lt;/code&gt; in &lt;code&gt;.paket&lt;/code&gt; folder, create &lt;code&gt;paket.dependencies&lt;/code&gt; file, install dependency. Thanks to that we can use &lt;code&gt;#r&lt;/code&gt; reference with relative path to our dependency (which is downloaded to packages folder). For example: &lt;code&gt;#r &quot;../packages/Tesseract/lib/net45/Tesseract.dll&quot;&lt;/code&gt;. This let us to use full power of our editors to develop Azure Functions locally.&lt;/p&gt;

&lt;h1&gt;Deployment to Azure&lt;/h1&gt;

&lt;p&gt;Now we need to force Azure to run Paket after deploying code from our repository to cloud. Doing it is fairly simple, but not documented too well.&lt;/p&gt;

&lt;p&gt;First of all, in root of our repository we create &lt;code&gt;build.cmd&lt;/code&gt; file running Paket.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;@echo off
cls

.paket\paket.bootstrapper.exe
if errorlevel 1 (
  exit /b %errorlevel%
)

.paket\paket.exe restore --force
if errorlevel 1 (
  exit /b %errorlevel%
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second step is using deployment configuration file to run our &lt;code&gt;build.cmd&lt;/code&gt;. We create &lt;code&gt;.deployment&lt;/code&gt; file and add there following entry:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[config]
SCM_POST_DEPLOYMENT_ACTIONS_PATH = ../wwwroot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It configures where deployment utility will look for any post deployment scripts (and &lt;code&gt;.cmd&lt;/code&gt; file) after cloning and coping our repository. &lt;code&gt;wwwroot&lt;/code&gt; is root folder which will contain our Function after deployment.&lt;/p&gt;

&lt;p&gt;Having those 2 files, we can push code to GitHub, go to Azure Portal, check deployments of our Function App. If everything is OK we should see Paket output in post deployment actions log.&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post, I’ve presented how to use Paket together with Azure Functions to create nice workflow for developing applications using this modern platform. The sample code can be found on GitHub - https://github.com/Krzysztof-Cieslak/AzureFunctionsSamples&lt;/p&gt;
</description>
                <pubDate>Tue, 22 Nov 2016 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/Using-Paket-with-Azure-Functions</link>
                <guid isPermaLink="true">http://kcieslak.io/Using-Paket-with-Azure-Functions</guid>
                
                <category>F#</category>
                
                <category>Paket</category>
                
                <category>Azure Functions</category>
                
                
            </item>
        
            <item>
                <title>Dynamically extending F# applications</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Changing requirements, introducing different data format, extending applications with new features. All those things requires us (developers) to go to code, do changes, add API versioning system (to be backward compatible), add configuration for turning on/off new features, compile application, and at the end release new application (what itself may be complex process). It’s often lot of work required for every, even very small, change.&lt;/p&gt;

&lt;p&gt;In this post I’ll present way to add new features to our F# application - dynamically, on runtime, without any recompiling and redeployment of application. What’s more extensions will be also defined using F#… in fact they will be simple F# script files.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Sample application&lt;/h1&gt;

&lt;p&gt;Our sample application for this blog post will be rather simple - it will be F# console application, taking user input as string, performing set of transformations on this input and just printing out result. Transformation for our input will be dynamically loaded on runtime - initially, before user add any plugins, application just returns same value as user typed in.&lt;/p&gt;

&lt;p&gt;We can simply define our transformation as &lt;code&gt;type Transformation = string -&amp;gt; string&lt;/code&gt; and operation we perform on input as &lt;code&gt;let output = lstOfTransformations |&amp;gt; List.fold (fun state transform -&amp;gt; transform state ) input&lt;/code&gt;.&lt;/p&gt;

&lt;h1&gt;Evaluating plugins files&lt;/h1&gt;

&lt;p&gt;As I’ve mentioned our aim is to define extensions as simple F# script files. But while we can easily read text put in &lt;code&gt;.fsx&lt;/code&gt; file, F# doesn’t have anything like JavaScript’s &lt;code&gt;eval()&lt;/code&gt; function built-in, no way to take text containing code and evaluating its value. But this is a moment where &lt;code&gt;FSharp.Compiler.Services&lt;/code&gt; enters the scene. FCS (not to confuse with FSC which is F# compiler) is fork of F# compiler that exposes additional functionality for implementing F# editor features, and additional tools based on the compiler. It also includes F# interactive service that can be used for embedding F# scripting into your applications.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you want learn more about &lt;code&gt;FSharp.Compiler.Services&lt;/code&gt; visit &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/&quot;&gt;FCS webpage&lt;/a&gt; to see documentation of available features, APIs, and list of projects using FCS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For our purpose we need two things - first we’ll create embedded in our application F# Interactive session, and then we will use it to load file with plugin and evaluate it.&lt;/p&gt;

&lt;p&gt;Creating FSI session is pretty straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;open Microsoft.FSharp.Compiler.Interactive.Shell

let sbOut = StringBuilder()
let sbErr = StringBuilder()

let fsi =
    let inStream = new StringReader(&quot;&quot;)
    let outStream = new StringWriter(sbOut)
    let errStream = new StringWriter(sbErr)
    let fsiConfig = FsiEvaluationSession.GetDefaultConfiguration()
    let argv = [| &quot;/temo/fsi.exe&quot;; |]
    FsiEvaluationSession.Create(fsiConfig, argv, inStream, outStream, errStream)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we can use FSI session to load file with extension and evaluate it’s content.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt; let evaluate path =
    let mdl = getOpen path
    let load = getLoad path

    fsi.EvalInteractionNonThrowing(sprintf &quot;#load \&quot;%s\&quot;;;&quot; load)
    fsi.EvalInteractionNonThrowing(sprintf &quot;open %s;;&quot; mdl)
    fsi.EvalExpressionNonThrowing &quot;map&quot;

    match res with
    | Choice1Of2 (Some f) -&amp;gt;
        f.ReflectionValue :?&amp;gt; Transformation |&amp;gt; Some
    | _ -&amp;gt; None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we find full path to file we want to load, and name of default module for this file (it’s name of the file with first character uppercase).&lt;/p&gt;

&lt;p&gt;We execute in FSI &lt;code&gt;#load&lt;/code&gt; statement to load content of extension file, and then we open default module. Last operation is executing &lt;code&gt;map&lt;/code&gt; in FSI which will return value of this expression (so function).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For sake of simplicity in sample, we make several assumptions about extensions files - we don’t define modules inside of &lt;code&gt;.fsx&lt;/code&gt; files and they contain only single function  &lt;code&gt;map : string -&amp;gt; string&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If everything is working we can now load F# script file and get from it normal F# function which we can execute somewhere else in our code!&lt;/p&gt;

&lt;h1&gt;Loading plugins on runtime&lt;/h1&gt;

&lt;p&gt;Next important feature of our application is dynamically loading (and unloading) scripts when users creates (or removes) them. For this we will use built-in .Net FileSystemWatcher class which let developer to perform operations whenever new file is created, file is removed etc. in given directory.&lt;/p&gt;

&lt;p&gt;We just create really simple functions which takes 2 functions (one executed when file is added, second one when file is removed) and directory to watch for changes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;let create addCb rmCb dir =
    if Directory.Exists dir |&amp;gt; not then Directory.CreateDirectory dir |&amp;gt; ignore

    let watcher = new FileSystemWatcher()
    watcher.Filter &amp;lt;- &quot;*.fsx&quot;
    watcher.Path &amp;lt;- dir
    watcher.Created.Add (fun n -&amp;gt; n.FullPath |&amp;gt; addCb)
    watcher.Deleted.Add (fun n -&amp;gt; n.FullPath |&amp;gt; rmCb)
    watcher.Renamed.Add (fun n -&amp;gt; n.OldFullPath |&amp;gt; rmCb; n.FullPath |&amp;gt; addCb)
    watcher.Changed.Add (fun n -&amp;gt; n.FullPath |&amp;gt; rmCb; n.FullPath |&amp;gt; addCb)
    watcher.SynchronizingObject &amp;lt;- null
    watcher.EnableRaisingEvents &amp;lt;- true

    watcher
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Plugins register&lt;/h1&gt;

&lt;p&gt;The last important part is storing list of the transformations in memory when application is running. Since FileWatcher is running asynchronously in background of our applications we are afraid of any potential race conditions so we won’t use any global mutable state to do so. Instead we will encapsulate state of our application in agent.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;To learn more about F# Agents visit Scott Wlaschin’s &lt;a href=&quot;https://fsharpforfunandprofit.com/posts/concurrency-actor-model/&quot;&gt;post about them&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;type private Msg =
    | Add of string * Transformation
    | Remove of string
    | Get of AsyncReplyChannel&amp;lt;Transformation list&amp;gt;

let private register =
    MailboxProcessor.Start (fun inbox -&amp;gt;
        let rec loop lst = async {
            let! msg = inbox.Receive()
            match msg with
            | Add (n,f) -&amp;gt;
                return! loop ((n,f)::lst)
            | Remove n -&amp;gt;
                return! loop (lst |&amp;gt; List.filter(fun (f,_) -&amp;gt; f &amp;lt;&amp;gt; n))
            | Get rc -&amp;gt;
                let l = lst |&amp;gt; List.map snd
                rc.Reply l
                return! loop lst
        }
        loop [] )

let add name fnc =
    (name, fnc) |&amp;gt; Add |&amp;gt; register.Post

let remove name =
    name |&amp;gt; Remove |&amp;gt; register.Post

let get () =
    register.PostAndReply Get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our agent can perform 3 operations - add transformation, remove it, or return list of all transformations.&lt;/p&gt;

&lt;h1&gt;Putting things together&lt;/h1&gt;

&lt;p&gt;The last step is putting whole application together:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;EntryPoint&amp;gt;]
let main argv =
    let remove path =
        let fn = Path.GetFileNameWithoutExtension path
        Register.remove fn

    let add path =
        let fn = Path.GetFileNameWithoutExtension path
        match Evaluator.evaluate path |&amp;gt; Option.map (fun ev -&amp;gt; Register.add fn ev ) with
        | Some _ -&amp;gt; ()
        | None -&amp;gt; printfn &quot;File `%s` couldn't be parsed&quot; path

    let watcher = Watcher.create add remove &quot;scripts&quot;

    while true do
        let input = System.Console.ReadLine ()
        let lst = Register.get ()
        let res = lst |&amp;gt; List.fold (fun s e -&amp;gt; e s ) input
        printfn &quot;Result: %s&quot; res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we define callbacks for file watcher - on file remove we just send message to extensions register to remove it, when file is added we try to evaluate it and if it was successful we send message to agent to add it to list.&lt;/p&gt;

&lt;p&gt;Then we create watcher using those 2 functions watching &lt;code&gt;scripts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;Last step is loop which waits for user input, gets all transformations, apply them to input, and print out result at the end. Here is small demo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/gifs/FunctionLoader.gif&quot; alt=&quot;Function Loader demo&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post I’ve shown how to use &lt;code&gt;FSharp.Compiler.Services&lt;/code&gt; to add dynamic extensibility mechanism to F# applications. Sample presented in this blog post was really simple, but I believe that this technique can be also used for more complex, real world applications (hopefully, I’ll be able to create some more complex project using this method soon ;) ). Full code for sample application can be found on &lt;a href=&quot;https://gitlab.com/Krzysztof-Cieslak/FunctionLoader&quot;&gt;GitLab (!)&lt;/a&gt;&lt;/p&gt;
</description>
                <pubDate>Mon, 03 Oct 2016 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Dynamically-extending-F-applications</link>
                <guid isPermaLink="true">http://kcieslak.io/Dynamically-extending-F-applications</guid>
                
                <category>F#</category>
                
                <category>FSharp.Compiler.Services</category>
                
                
            </item>
        
            <item>
                <title>Working with F# projects in VSCode</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, OS X and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages (C++, C#, Python, PHP) and runtimes. The F# support for VSCode is provided by &lt;a href=&quot;http://ionide.io&quot;&gt;Ionide&lt;/a&gt; - set of extensions adding F# support, as well as Paket and FAKE.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you’re new VSCode user installing extensions is pretty easy - press extensions button on left panel, search for Ionide, press install for all Ionide extensions, wait untill all are installed and restart VSCode.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ionide-FSharp provides wide set of features useful for F# developer - from simple autocomplete and tooltips, through F# Interactive integration, to navigating to symbols or finding all usages of symbol.&lt;/p&gt;

&lt;p&gt;It also comes with decent support for F# projects (defined using &lt;code&gt;.fsproj&lt;/code&gt; file).&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Working with existing projects&lt;/h1&gt;

&lt;p&gt;Working with existing projects (created using Visual Studio or other IDE) should be pretty straightforward - opening root of your repository / solution will start Ionide. Plugin should find all project files in repository and parse them.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Warning - this process can take some time, especially on huge solutions. You can still edit files without any problem, but it make take a while before are features are started - the priority is put on providing features like tooltips, autocomplete or error highlighting for currently opened files. Solution level features (finding all errors in solution, navigating to any symbol in solution, rename, etc ) take bit longer to start.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;Creating new projects&lt;/h1&gt;

&lt;p&gt;Ionide thanks to &lt;a href=&quot;https://github.com/fsprojects/Forge&quot;&gt;Forge&lt;/a&gt; integration provides ability to create new F# projects without using full IDE. Creating new project is as simple as running &lt;code&gt;F#: New Project&lt;/code&gt; command.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;All VSCode commands can be run using command palette, it can be started using &lt;code&gt;Ctrl(Cmd)+Shift+P&lt;/code&gt; keybord shortcut.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ionide will ask about project name, directory where place new project, and project template. Currently there are about 15 different project templates, hopefully more will come in the future thanks to Community contributions to Forge.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Warning - even if you just create new project, you should have VS Code open in empty directory. It does not create “solution” directory, and assumes that is run from repository root.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Creating new project will also initialize Paket and FAKE, and create sample build script in repository root. This won’t happen if you’re just adding new project to existing solution with Paket and FAKE.&lt;/p&gt;

&lt;h1&gt;Handling files in project&lt;/h1&gt;

&lt;p&gt;As you probably know, &lt;code&gt;fsproj&lt;/code&gt; files contain list of F# (&lt;code&gt;.fs&lt;/code&gt;) files which will be compiled during build process. What’s important is that ordering of those files matters… and it’s huge F# feature. But this topic was already covered in amazing &lt;a href=&quot;https://fsharpforfunandprofit.com/series/dependency-cycles.html&quot;&gt;Scott Wlaschin’s blog&lt;/a&gt;. So, back to the topic.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Warning - Forge tends to do some additional changes to project file, so for first few times (unless you’re already comfortable with usual Forge changes) I recommend doing git commit before running Forge commands - it will make easier for you to check what changes Forge makes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are few commands which makes handling files easier. First of all, you can add or remove currently open file from project using &lt;code&gt;F#: Add Current File To Project&lt;/code&gt; and &lt;code&gt;F#: Remove Current File To Project&lt;/code&gt;. Forge will try to find appropriate project file and add or remove file there.&lt;/p&gt;

&lt;p&gt;Another important operation is file ordering - to control it &lt;code&gt;F#: Move File Up&lt;/code&gt; and &lt;code&gt;F#: Move File Down&lt;/code&gt; commands exist.&lt;/p&gt;

&lt;h1&gt;Handling references&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;fsproj&lt;/code&gt; files contain also list of used references. Generally there are 3 types of those - external references from NuGet (this type is handled by Paket), project references and GAC references. To handle 2 later cases Ionide provides two commands.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;F#: Add Project Reference&lt;/code&gt; command will ask you which project you want to edit (there will be list of all projects found in current workspace), and after which project you want to reference. For GAC references Ionide provides &lt;code&gt;F#: Add Reference&lt;/code&gt; command which works in very similar way.&lt;/p&gt;

&lt;h1&gt;Solution-wide editor features&lt;/h1&gt;

&lt;p&gt;Ionide’s editor features are probably good topic for another post, but let’s quickly go through some features which works on solution level:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;On file save, Ionide parse all projects and find all error in solution. They can be viewed in error panel (&lt;code&gt;Ctrl(Cmd) + Shift + M&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Go-to-Definition (&lt;code&gt;F12&lt;/code&gt;), Find all references (&lt;code&gt;Shift+F12&lt;/code&gt;), Peek definition (&lt;code&gt;Alt + F12&lt;/code&gt;) works across all projects in solution&lt;/li&gt;
  &lt;li&gt;Rename (&lt;code&gt;F2&lt;/code&gt;) works across all projects in solution&lt;/li&gt;
  &lt;li&gt;Same for navigating to symbol (&lt;code&gt;Ctrl(Cmd)+T&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post, I’ve presented some Ionide’s features which makes supporting and handling F# projects in Visual Studio Code. There are still not as many project editing features as in Visual Studio or Xamarin Studio, but I belive that it’s good start point, and nice set of features for lightweight editor.&lt;/p&gt;
</description>
                <pubDate>Wed, 27 Jul 2016 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Working-with-F-Projects-In-VSCode</link>
                <guid isPermaLink="true">http://kcieslak.io/Working-with-F-Projects-In-VSCode</guid>
                
                <category>F#</category>
                
                <category>VS Code</category>
                
                <category>Tooling</category>
                
                
            </item>
        
            <item>
                <title>Creating custom project file for F#</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Let’s imagine a world where F# is independent language, with cross-platform tooling making life of every F# developer easier. In this world, after we’ve fixed dependency management problem with Paket, we could go one step further… and fix project file format and building. We would use same principles as Paket - very simple, human readable, file format which can be edited without any other tooling, and command line tool responsible for building such project.&lt;/p&gt;

&lt;p&gt;In such world I’ve decided to create new open-source project called &lt;code&gt;Chris&lt;/code&gt;&lt;/p&gt;

&lt;h1&gt;File format&lt;/h1&gt;

&lt;p&gt;For our hypothetical project file (called &lt;code&gt;project.chris&lt;/code&gt;) I’ve decided to use &lt;code&gt;toml&lt;/code&gt;. In this very simple file we would just specify few properties, files of our project, GAC references and external NuGet packages. It would look like as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[Info]
Name = &quot;Fancy_Test_Project&quot;
Author = &quot;Lambda Factory&quot;
Git = &quot;&quot;

[Stuff]
References = [&quot;mscorlib&quot;, &quot;System&quot;, &quot;System.Core&quot;, &quot;System.Numerics&quot;]
Files = [&quot;Message.fs&quot;, &quot;Test.fs&quot;]
Packages = []
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;

&lt;h1&gt;Build&lt;/h1&gt;

&lt;p&gt;Most important feature of every project system is ability to build project to executable version. As I’ve mentioned earlier one of the important points I’d like to address is ability to build project with command line with very simple commands. To build any F# project, in the end - no matter which project system we use, we have to execute F# Compiler with &lt;a href=&quot;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/compiler-options-%5bfsharp%5d&quot;&gt;appropriate arguments&lt;/a&gt; (defining references, different build options, and source files).&lt;/p&gt;

&lt;p&gt;In this case I’ve created really simple console application which user runs in project directory and it builds project, and produce &lt;code&gt;.exe&lt;/code&gt; file. To parse &lt;code&gt;toml&lt;/code&gt; I’ve decided to use &lt;a href=&quot;https://github.com/paiden/Nett&quot;&gt;Nett library&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First step is defining model representing our project, what is rather straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;type Info = {
    Name : string
    Author : string
    Git : string
}

type Stuff = {
    Files : string []
    References : string []
    Packages : string []
}

type Project = {
    Info : Info
    Stuff : Stuff
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next step is creating 2 helper functions - one loading &lt;code&gt;project.chris&lt;/code&gt; and parsing it to our model, second one transforming this model to right F# Compiler arguments. Again, nothing complex.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;let load (path : string) =
    let tmp = Toml.ReadFile path
    let info = tmp.Get&amp;lt;TomlTable&amp;gt; &quot;Info&quot;
    let stuff = tmp.Get&amp;lt;TomlTable&amp;gt; &quot;Stuff&quot;
    {
        Info = {
                Name = info.Get&amp;lt;string&amp;gt;(&quot;Name&quot;)
                Author = info.Get&amp;lt;string&amp;gt;(&quot;Author&quot;)
                Git = info.Get&amp;lt;string&amp;gt;(&quot;Git&quot;) }
        Stuff = {
                Files = stuff.Get&amp;lt;string []&amp;gt;(&quot;Files&quot;)
                References = stuff.Get&amp;lt;string []&amp;gt;(&quot;References&quot;)
                Packages = stuff.Get&amp;lt;string []&amp;gt;(&quot;Packages&quot;) }
    }, path

let toFSCParams (project, path) =
    let folder = Path.GetDirectoryName path
    let output = sprintf &quot;%s.exe&quot; project.Info.Name
    [|
        yield &quot;-out:&quot; + output
        yield @&quot;-r:C:\Program Files (x86)\Reference Assemblies\Microsoft\FSharp\.NETFramework\v4.0\4.3.1.0\FSharp.Core.dll&quot;
        for r in project.Stuff.References do
            yield sprintf @&quot;-r:C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5\%s.dll&quot; r

        yield &quot;--noframework&quot;
        for f in project.Stuff.Files do
            yield  Path.Combine (folder, f)
    |]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last step is creating function which runs F# Compiler. To do so we will use &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/&quot;&gt;FSharp.Compiler.Service&lt;/a&gt; - .Net library that exposes functionality for implementing F# language bindings, additional tools based on the compiler or refactoring tools. What’s most important in this case it also let’s &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/compiler.html&quot;&gt;host F# compiler inside other application&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;open Microsoft.FSharp.Compiler
open Microsoft.FSharp.Compiler.SourceCodeServices
open Microsoft.FSharp.Compiler.SimpleSourceCodeServices

let build (project,path) =
    let scs = SimpleSourceCodeServices()
    let parm =  (project, path) |&amp;gt; toFSCParams
    parm |&amp;gt; scs.Compile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And at the end we pipe it together:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;[&amp;lt;EntryPoint&amp;gt;]
let main argv =
    let errors, exit =
        &quot;project.chris&quot;
        |&amp;gt; Path.GetFullPath
        |&amp;gt; load
        |&amp;gt; build
    exit // return an integer exit code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can build our project!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;images/gifs/chris_build.gif&quot; alt=&quot;Build with Chris&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Editor support&lt;/h1&gt;

&lt;p&gt;Another important part of project system is providing information for F# Language Services which lets us to create rich editing environment across many different editors. Fortunatly FSharp.Compiler.Service is designed to be totally decoupled from project file format and requires its &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/reference/microsoft-fsharp-compiler-sourcecodeservices-fsharpprojectoptions.html&quot;&gt;custom type&lt;/a&gt; to provide all nice &lt;a href=&quot;https://fsharp.github.io/FSharp.Compiler.Service/editor.html&quot;&gt;Language Services features&lt;/a&gt;. Since we already have function loading &lt;code&gt;project.chris&lt;/code&gt; to memory all we need to do is creating function which maps our type to type required by FCS.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;let toFSharpProjectOptions (project, path) =
    let rsp = (project, path) |&amp;gt; toFSCParams
    {
      ProjectFileName = path
      ProjectFileNames = [||]
      OtherOptions = rsp
      ReferencedProjects = [||]
      IsIncompleteTypeCheckEnvironment = false
      UseScriptResolutionRules = false
      LoadTime = System.DateTime.Now
      UnresolvedReferences = None;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next step is actually adding support for &lt;code&gt;project.chris&lt;/code&gt; to our editor of choice. It’s pretty easy for all editors and tools using FSharp.Compiler.Service in the background, but for sake of simplicity I’ve chosen &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VS Code&lt;/a&gt; with &lt;a href=&quot;https://ionide.io&quot;&gt;Ionide&lt;/a&gt;. As you may know, VS Code is editor created using &lt;a href=&quot;http://electron.atom.io/&quot;&gt;Electron&lt;/a&gt; which is framework for building cross-platform, desktop applications using HTML, JS, and CSS. Such choice has many advantages, but one bug important drawback from F# editor tooling point of view - we can’t directly use .Net libraries in VS Code. To communicate with .Net libraries (and especially with FSharp.Compiler.Service) we are using &lt;a href=&quot;https://github.com/fsharp/FsAutoComplete&quot;&gt;FsAutoComplete&lt;/a&gt; - F# compiler service API exposed via a console application and HTTP server.&lt;/p&gt;

&lt;p&gt;Adding &lt;code&gt;project.chris&lt;/code&gt; support to FsAutoComplete is, again, fairly easy. First step is adding Chris project as reference to FsAutoComplete. Next we create helper function which will be executed if we try to load &lt;code&gt;project.chris&lt;/code&gt; file - it’s basically copy-paste of &lt;a href=&quot;https://github.com/fsharp/FsAutoComplete/blob/master/src/FsAutoComplete.Core/CompilerServiceInterface.fs#L189-L222&quot;&gt;same functions&lt;/a&gt; for &lt;code&gt;.fsproj&lt;/code&gt; and &lt;code&gt;project.json&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;  member x.TryGetChrisProjectOption (file : string) : Result&amp;lt;_&amp;gt; =
    if not (File.Exists file) then
      Failure (sprintf &quot;File '%s' does not exist&quot; file)
    else
      try
        let po = file |&amp;gt; Chris.load |&amp;gt; Chris.toFSharpProjectOptions
        let compileFiles = Seq.filter (fun (s:string) -&amp;gt; s.EndsWith(&quot;.fs&quot;)) po.OtherOptions
        let outputFile = Seq.tryPick (chooseByPrefix &quot;--out:&quot;) po.OtherOptions
        let references = Seq.choose (chooseByPrefix &quot;-r:&quot;) po.OtherOptions
        Success (po, Seq.toList compileFiles, outputFile, Seq.toList references, Map&amp;lt;string,string&amp;gt;([||]))
      with e -&amp;gt;
        Failure e.Message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last step is modifying &lt;a href=&quot;https://github.com/fsharp/FsAutoComplete/blob/master/src/FsAutoComplete.Core/FsAutoComplete.Core.fs#L51-L55&quot;&gt;handler for project request&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;let options =
    if file.EndsWith &quot;fsproj&quot; then
        checker.TryGetProjectOptions(file, verbose)
    elif file.EndsWith &quot;chris&quot; then
        checker.TryGetChrisProjectOption file
    else
        checker.TryGetCoreProjectOptions file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compile FSAC, copy modified version to Iondie plugin folder… and that’s all. Everything is working as always, just with &lt;code&gt;project.chris&lt;/code&gt;.
&lt;img src=&quot;images/gifs/chris_editor.gif&quot; alt=&quot;Editor with Chris&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Frequently Asked Question&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Q: You haven’t mentioned VS at all, it surely means you hate it and ignore, right?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: No, VS (with VFPT installed) is best F# IDE, but I don’t use it too much. Adding custom project file support to VS is definitely possible, it just requires knowledge I don’t have. Thus, I haven’t mentioned it in post.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: What about C# / F# interoperability, compatibility with existing F# projects?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: In worst case scenario - we have compatibility on compiled code / package level ( I can imagine some workflow using Paket which would make it not too problematic). In “best” case - custom MsBuild task, but again, I don’t have enough knowledge to judge how possible it is.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: You’re just one of those elitist, arrogant guys thinking they are better because they use this new-overhyped thing - functional programming. You just hate MsBuild because it’s C#!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: Yes, indeed. Move along. Nothing to see here.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: What about support for any other F# tooling such as FSharpLint?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: Any tool using FSharp.Compiler.Service should be very easy to port, as presented above on FsAutoComplete example.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: Where is code, I want to use it now!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: Code of this experiment is not published anywhere on purpose - I don’t want anyone to use it by any chance. It was just very simple proof of concept. Hopefully, one day F# Community will be ready for new project system.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q: I &lt;strong&gt;really&lt;/strong&gt; want to use something like that&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A: Ask &lt;a href=&quot;https://twitter.com/7sharp9_exhumed&quot;&gt;Dave Thomas&lt;/a&gt; about his Xebec project, and support &lt;a href=&quot;https://twitter.com/7sharp9_exhumed/status/745995222178480128&quot;&gt;fsprojexit&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post I’ve presented possible ways of expanding F# development environment with new project system. I haven’t shown here any ready solutions for the problem but I hope that this post shows that having new, better project system is possible. We just need as Community to start reasonable discussion about such possibility.&lt;/p&gt;
</description>
                <pubDate>Thu, 23 Jun 2016 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Creating-custom-project-file-for-F</link>
                <guid isPermaLink="true">http://kcieslak.io/Creating-custom-project-file-for-F</guid>
                
                <category>F#</category>
                
                <category>VS Code</category>
                
                <category>Tooling</category>
                
                
            </item>
        
            <item>
                <title>Getting started with Fable and Webpack</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/fsprojects/Fable&quot;&gt;Fable&lt;/a&gt; is new F# to JavaScript compiler created by &lt;a href=&quot;https://twitter.com/alfonsogcnunez&quot;&gt;Alfonso Garcia-Caro&lt;/a&gt;. In this post I’ll go, step by step, through process of creating client-side (browser) applications using it.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This post is targeted at F# developers without lot of knowladge about Node.js and JS ecosystem and it should let any F# developer to get started with Fable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Requirements&lt;/h3&gt;

&lt;p&gt;Fable requires having both &lt;a href=&quot;http://fsharp.org&quot;&gt;F# 4&lt;/a&gt; and &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;node 4.4&lt;/a&gt; or bigger installed in your computer.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Setting up project&lt;/h1&gt;

&lt;p&gt;The first thing we need to do is creating new directory and initializing node project:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir fable-test
cd fable-test
npm init
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;Npm&lt;/a&gt; is is the package manager for JavaScript. It lets users to find, share, and reuse packages of code or install additional tools&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;npm init&lt;/code&gt; will create &lt;code&gt;package.json&lt;/code&gt; file. This file is project file for any Node.js based project (both client and server side). At start it will contain only basic information about a project, something like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;name&quot;: &quot;fable-test&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;...&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Installing development tools.&lt;/h3&gt;

&lt;p&gt;Next step is installing all development dependencies (tools) which we’ll be using for our project. To do so we are using &lt;code&gt;npm install&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install --save-dev fable-compiler
npm install --save-dev webpack
npm install --save-dev source-map-loader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First line installs Fable compiler for our project. Second command installs &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt;. Webpack is a module bundler - it takes modules with dependencies and generates static assets representing those modules. In our case it would take generated by Fable files together with other JS libraries we will depend upon and create single file output which can be easily added to page. Last dependency is plugin to Webpack which will enable nice debugging story for our application (debugging F# files in the browser)&lt;/p&gt;

&lt;p&gt;It’s also worth noticing that those commands modified &lt;code&gt;package.json&lt;/code&gt; file, now it contains also following block:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;devDependencies&quot;: {
  &quot;fable-compiler&quot;: &quot;^0.2.12&quot;,
  &quot;source-map-loader&quot;: &quot;^0.1.5&quot;,
  &quot;webpack&quot;: &quot;^1.13.0&quot;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Installing dependencies&lt;/h3&gt;

&lt;p&gt;Now we will install our code dependencies using also &lt;code&gt;npm install&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install --save core-js
npm install --save fable-core
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;core-js&lt;/code&gt; is polyfill ensuring that code generated by Fable will run in any browser. &lt;code&gt;fable-core&lt;/code&gt; is standard Fable library.&lt;/p&gt;

&lt;p&gt;Those commands again modified &lt;code&gt;package.json&lt;/code&gt; file, this time adding following information:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;dependencies&quot;: {
    &quot;core-js&quot;: &quot;^2.4.0&quot;,
    &quot;fable-core&quot;: &quot;0.0.21&quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Creating F# script and HTML file&lt;/h3&gt;

&lt;p&gt;Fable supports both &lt;code&gt;fsproj&lt;/code&gt; and plain &lt;code&gt;fsx&lt;/code&gt; files. For simplicity in this example let’s use &lt;code&gt;fsx&lt;/code&gt; file. Create &lt;code&gt;source\code.fsx&lt;/code&gt; with follwing content:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;#r &quot;../node_modules/fable-core/Fable.Core.dll&quot;

open Fable.Core 
open Fable.Import
 
Node.require.Invoke(&quot;core-js&quot;) |&amp;gt; ignore

let element = Browser.document.getElementById &quot;sample&quot;
element.innerText &amp;lt;- &quot;Hello, world !!&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code should be pretty straightforward, only tricky part is &lt;code&gt;Node.require.Invoke(&quot;core-js&quot;)&lt;/code&gt; which is importing Node.js module (installed by &lt;code&gt;npm&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Let’s also create very simple HTML file &lt;code&gt;public\index.html&lt;/code&gt; ( &lt;code&gt;public&lt;/code&gt; will be our output folder):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta http-equiv='Content-Type' content='text/html; charset=utf-8'&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div id='sample'&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;script src=&quot;bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Configuration&lt;/h1&gt;

&lt;p&gt;First step is creating configuration for Fable compiler. It’s done by creating &lt;code&gt;fableconfig.json&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;module&quot;: &quot;commonjs&quot;,
  &quot;sourceMaps&quot;: true,
  &quot;projFile&quot;: &quot;./src/code.fsx&quot;,
  &quot;outDir&quot;: &quot;temp&quot;,
  &quot;scripts&quot;: {
    &quot;prebuild&quot;: &quot;npm install&quot;,
    &quot;postbuild&quot;: &quot;webpack&quot;
  },
  &quot;targets&quot;: {
    &quot;watch&quot;: {
      &quot;scripts&quot;: {
        &quot;postbuild&quot;: &quot;webpack --watch&quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we define module type - in our case it’s &lt;code&gt;commonjs&lt;/code&gt; (as it’s working well with &lt;code&gt;Webpack&lt;/code&gt;). Next we define that we want to use soruce maps (it allows F# file debugging), entry point of application, and output directory for compiled JS files.
Next step is defining some small scripts which will be run before and after every build - before we want to run &lt;code&gt;npm install&lt;/code&gt; to restore all dependencies, after build we run &lt;code&gt;webpack&lt;/code&gt; to create bundled output file. Last part defines additional target which will be executed in &lt;code&gt;watch&lt;/code&gt; mode. In such case we want to run &lt;code&gt;webpack&lt;/code&gt; also in &lt;code&gt;watch&lt;/code&gt; mode.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;watch&lt;/code&gt; mode will make Fable and Webpack to recompile project after every file save without need to execute any additional commands.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Webpack configuration&lt;/h3&gt;

&lt;p&gt;Second step is to create &lt;code&gt;webpack&lt;/code&gt; configuration. Let’s create &lt;code&gt;webpack.config.js&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var path = require(&quot;path&quot;);
var webpack = require(&quot;webpack&quot;);

var cfg = {
  devtool: &quot;source-map&quot;,
  entry: &quot;./temp/code.js&quot;,
  output: {
    path: path.join(__dirname, &quot;public&quot;),
    filename: &quot;bundle.js&quot;
  },
  module: {
    preLoaders: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: &quot;source-map-loader&quot;
      }
    ]
  }
};

module.exports = cfg;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this file we define that we want to use source maps, entry point for webpack ( so file generated by Fable), output path, and usage of any additional plugins (in our case it will be &lt;code&gt;source-map-loader&lt;/code&gt; installed before)&lt;/p&gt;

&lt;h3&gt;Npm scripts&lt;/h3&gt;

&lt;p&gt;Easiest way to run tools installed by &lt;code&gt;npm&lt;/code&gt; is by using scripts section in &lt;code&gt;packages.json&lt;/code&gt; file. Let’s put there following scripts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;scripts&quot;: {
  &quot;build&quot;: &quot;fable&quot;,
  &quot;watch&quot;: &quot;fable -w --target watch&quot;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;build&lt;/code&gt; just starts Fable. &lt;code&gt;watch&lt;/code&gt;, as name suggests, starts Fable in &lt;code&gt;watch&lt;/code&gt; mode, so code is regenerated every time we save F# file. We can run those scripts using &lt;code&gt;npm run &amp;lt;script_name&amp;gt;&lt;/code&gt; command.&lt;/p&gt;

&lt;h3&gt;VSCode configuration&lt;/h3&gt;

&lt;p&gt;Last, optional step is creating &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VSCode&lt;/a&gt; configuration. It’s fairly easy since editor has decent integration with &lt;code&gt;npm&lt;/code&gt;. All we need to do is create &lt;code&gt;.vscode\tasks.json&lt;/code&gt; file and put there following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;command&quot;: &quot;npm&quot;,
  &quot;isShellCommand&quot;: true,
  &quot;showOutput&quot;: &quot;always&quot;,
  &quot;suppressTaskName&quot;: true,
  &quot;tasks&quot;: [
    {
      &quot;taskName&quot;: &quot;install&quot;,
      &quot;args&quot;: [&quot;install&quot;]
    },
    {
      &quot;taskName&quot;: &quot;build&quot;,
      &quot;args&quot;: [&quot;run&quot;, &quot;build&quot;],
      &quot;isBuildCommand&quot;: true
    },
    {
      &quot;taskName&quot;: &quot;watch&quot;,
      &quot;args&quot;: [&quot;run&quot;, &quot;watch&quot;],
      &quot;isWatching&quot;: true
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we define that our tasks are using &lt;code&gt;npm&lt;/code&gt; and we define arguments send to &lt;code&gt;npm&lt;/code&gt; with every task. 
We can run those task usign &lt;code&gt;Tasks: Run Task&lt;/code&gt; command (&lt;code&gt;build&lt;/code&gt; task can be also run using &lt;code&gt;Tasks: Run Build Command&lt;/code&gt; command or &lt;code&gt;Ctrl + Shift + B&lt;/code&gt;)&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post we have shortly moved all steps necessary to create browser, client-side applications using F#, Fable and Webpack. Whole source code of this sample application is on GitHub - https://github.com/Krzysztof-Cieslak/fable-webpack-demo&lt;/p&gt;
</description>
                <pubDate>Mon, 16 May 2016 00:00:00 +0200</pubDate>
                <link>http://kcieslak.io/Getting-Started-with-Fable-and-Webpack</link>
                <guid isPermaLink="true">http://kcieslak.io/Getting-Started-with-Fable-and-Webpack</guid>
                
                <category>F#</category>
                
                <category>Fable</category>
                
                <category>VS Code</category>
                
                <category>Webpack</category>
                
                <category>JS</category>
                
                
            </item>
        
            <item>
                <title>Creating VS Code plugins with F# and Fable</title>
                <description>&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;EDIT 22.03.2016&lt;/em&gt; Thanks to Alfonso’s help I was able to remove postbuild step fixing JS.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VS Code&lt;/a&gt; is new text editor (or rather lightweight IDE) created by Microsoft. Because it is product based on &lt;a href=&quot;http://electron.atom.io/&quot;&gt;Electron&lt;/a&gt; - cross platform engine allowing developers to write desktop applications using web technologies - its plugin system supports JavaScript (and TypeScript). Unfortunately both those languages are not nice choice for someone using statically typed functional programming languages like F#. Up to this moment in my VS Code extensions I was using F# library called &lt;a href=&quot;http://funscript.info/&quot;&gt;FunScript&lt;/a&gt; which compiles F# code to JavaScript. Whereas it sounds nice, library has some problems which makes writing code using it not nice experience. Fortunately recently, &lt;a href=&quot;https://twitter.com/alfonsogcnunez&quot;&gt;Alfonso Garcia-Caro&lt;/a&gt;, one of contributors to FunScript, has decided to create new project compiling F# to JS (with &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; as middle step) called &lt;a href=&quot;http://fable.io&quot;&gt;Fable&lt;/a&gt; which hopefully will solve some of the FunScript’s problems. I have decided to investigate how this new library can be used to create VS Code plugins… using VS Code to code and compile those plugins.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Requirements&lt;/h1&gt;

&lt;p&gt;You need to have &lt;a href=&quot;http://fsharp.org/&quot;&gt;F# 4&lt;/a&gt; and &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;node.js&lt;/a&gt; installed. Node has to be included in your &lt;code&gt;$PATH&lt;/code&gt;.&lt;/p&gt;

&lt;h1&gt;Initial steps&lt;/h1&gt;

&lt;p&gt;The simplest way to start building own VS Code plugin is using &lt;a href=&quot;http://yeoman.io/&quot;&gt;Yeoman&lt;/a&gt; to scaffold plugin project. Install Yeoman and &lt;a href=&quot;https://code.visualstudio.com/docs/tools/yocode&quot;&gt;VS Code Plugin Generator&lt;/a&gt; using following commands:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install -g yo
npm install -g generator-code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Yeoman generator will walk you through the steps required to create your customization or extension prompting for the required information. To launch the generator type the following in a command prompt:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;yo code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We pick &lt;code&gt;New Extension (JavaScript)&lt;/code&gt; option, go through all questions, and let Yeoman do its magic. After process is finished we enter newly created folder.Here we have to remove some unnecessary things generated by Yeoman - &lt;code&gt;extension.js&lt;/code&gt; file, and &lt;code&gt;typing&lt;/code&gt; and &lt;code&gt;tests&lt;/code&gt; folders (who need tests anyway ;) ). We add &lt;code&gt;out/&lt;/code&gt; entry to &lt;code&gt;.gitignore&lt;/code&gt; files - all output files will be generated as part of our build process and shouldn’t be commited to GitHub. Final step is creating empty &lt;code&gt;src&lt;/code&gt; folder - it will contain our F# source files.&lt;/p&gt;

&lt;h1&gt;Installing Fable and setting project.&lt;/h1&gt;

&lt;p&gt;Installing Fable and VS Code bindings for it is easy - all things are published as npm modules. So we can just run following commands to add those tools to our project&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install --save-dev fable-compiler fable-import-vscode
npm install --save fable-core
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next step is updating our &lt;code&gt;package.json&lt;/code&gt; file to include changes we have done and to create build targets which will compile F# code to JS.First of all we update &lt;code&gt;main&lt;/code&gt; entry - it defines where is our entry file of plugin.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
...  
&quot;main&quot;: &quot;./out/extension&quot;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second, we update &lt;code&gt;scripts&lt;/code&gt; part - here we define possible build targets which can be used for our project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
...
&quot;scripts&quot;: {
    &quot;build&quot;: &quot;fable src/extension.fsx --outDir ../out -s -m commonjs&quot;
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;For more details about Fable and compiler options please check &lt;a href=&quot;http://fable.io/docs/compiling.html&quot;&gt;Fable documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;build&lt;/code&gt; target runs fable compiler to generate JS from our F# file.&lt;/p&gt;

&lt;h1&gt;Writing F# Code&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;For more details about VS Code extension API please visit &lt;a href=&quot;https://code.visualstudio.com/docs/extensions/overview&quot;&gt;extension documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At last we can write some F# code. Our sample extension will be simple - it will be just Hello World.To start in &lt;code&gt;src&lt;/code&gt; folder we create F# script file called &lt;code&gt;extension.fs&lt;/code&gt;. First step is referencing Fable core library and VS Code bindings&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;#r &quot;../node_modules/fable-core/Fable.Core.dll&quot;
 
open Fable.Core
open Fable.Core.JsInterop
open Fable.Import
open Fable.Import.vscode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Entry point of any VS Code plugin is activate function placed in file defined as entry point in &lt;code&gt;package.json&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-fsharp&quot;&gt;open Fable.Import.vscode.commands.Globals

let activate (context : vscode.ExtensionContext) = 
  registerCommand(&quot;extension.sayHello&quot;, fun _ -&amp;gt;
    showInformationMessage &quot;Hello world!&quot; |&amp;gt; unbox )
  |&amp;gt; context.subscriptions.Add    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see we can use both standard F# construct like &lt;code&gt;printfn&lt;/code&gt; function (which is mapped to JS &lt;code&gt;console.log&lt;/code&gt;) and functions defined in VS Code bindings. Here we print “Hello world” to console and register command which will display Hello World information in the popup. Now from console, we can run &lt;code&gt;npm build&lt;/code&gt; and compile our F# script to JavaScript. We shall see result in &lt;code&gt;out&lt;/code&gt; directory.&lt;/p&gt;

&lt;h1&gt;Integration with VS Code&lt;/h1&gt;

&lt;p&gt;Now, when we have set up project and can compile it, we need to integrate our solution with VS Code - first we define Task to run our build script from inside editor.
In &lt;code&gt;.vscode&lt;/code&gt; folder we create &lt;code&gt;tasks.json&lt;/code&gt; file and put there:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;command&quot;: &quot;npm&quot;,
  &quot;isShellCommand&quot;: true,
  &quot;tasks&quot;: [
    {
     &quot;taskName&quot;: &quot;run&quot;,
      &quot;isBuildCommand&quot;: true,
      &quot;args&quot;: [ &quot;build&quot; ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It’s just simple task running &lt;code&gt;npm run build&lt;/code&gt; - it is defined as build command which means it can be run using &lt;code&gt;Ctrl+Shift+B&lt;/code&gt; command. Next step is setting this target as task we want to invoke before we start debugging. To do this, we open &lt;code&gt;launch.json&lt;/code&gt; file and append &lt;code&gt;&quot;preLaunchTask&quot;: &quot;run&quot;&lt;/code&gt; to &lt;code&gt;Lanunch Extension&lt;/code&gt; configuration (we can remove &lt;code&gt;Launch test&lt;/code&gt; entry, we do not need tests anyway ;) ). Pressing F5 will run our extension - we can try it out by running &lt;code&gt;Hello World&lt;/code&gt; command in Command Palette.&lt;/p&gt;

&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post we have shortly moved all steps necessary to create VS Code extension using F# and Fable. From my short experience with this tool it looks like it is much nicer option than FunScript, hopefully I will be able to port my other extensions to it! Whole source code of this sample application is on &lt;a href=&quot;https://github.com/Krzysztof-Cieslak/vscode-fable-demo&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
                <pubDate>Mon, 21 Mar 2016 00:00:00 +0100</pubDate>
                <link>http://kcieslak.io/Creating-VS-Code-plugins-with-F-and-Fable</link>
                <guid isPermaLink="true">http://kcieslak.io/Creating-VS-Code-plugins-with-F-and-Fable</guid>
                
                <category>F#</category>
                
                <category>Fable</category>
                
                <category>VS Code</category>
                
                
            </item>
        
    </channel>
</rss>